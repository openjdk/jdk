#
# Copyright 1999-2009 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Sun designates this
# particular file as subject to the "Classpath" exception as provided
# by Sun in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#

##
## errors
##

compiler.err.abstract.cant.be.instantiated=\
    {0} is abstract; cannot be instantiated
compiler.err.abstract.meth.cant.have.body=\
    abstract methods cannot have a body
compiler.err.already.annotated=\
    {0} {1} has already been annotated
compiler.err.already.defined=\
    {0} is already defined in {1}
compiler.err.already.defined.single.import=\
    {0} is already defined in a single-type import
compiler.err.already.defined.static.single.import=\
    {0} is already defined in a static single-type import
compiler.err.already.defined.this.unit=\
    {0} is already defined in this compilation unit
compiler.err.annotation.missing.default.value=\
    annotation {0} is missing {1}
compiler.err.annotation.not.valid.for.type=\
    annotation not valid for a value of type {0}
compiler.err.annotation.type.not.applicable=\
    annotation type not applicable to this kind of declaration
compiler.err.annotation.value.must.be.annotation=\
    annotation value must be an annotation
compiler.err.annotation.value.must.be.class.literal=\
    annotation value must be a class literal
compiler.err.annotation.value.must.be.name.value=\
    annotation values must be of the form ''name=value''
compiler.err.annotation.value.not.allowable.type=\
    annotation value not of an allowable type
compiler.err.anon.class.impl.intf.no.args=\
    anonymous class implements interface; cannot have arguments
compiler.err.anon.class.impl.intf.no.typeargs=\
    anonymous class implements interface; cannot have type arguments
compiler.err.anon.class.impl.intf.no.qual.for.new=\
    anonymous class implements interface; cannot have qualifier for new
compiler.err.array.and.varargs=\
    cannot declare both {0} and {1} in {2}
compiler.err.array.dimension.missing=\
    array dimension missing
compiler.err.array.req.but.found=\
    array required, but {0} found

compiler.err.assignment.from.super-bound=\
    assigning from wildcard {0}
compiler.err.assignment.to.extends-bound=\
    assigning to wildcard {0}
compiler.err.attribute.value.must.be.constant=\
    attribute value must be constant

compiler.err.break.outside.switch.loop=\
    break outside switch or loop

compiler.err.call.must.be.first.stmt.in.ctor=\
    call to {0} must be first statement in constructor
compiler.err.cant.apply.symbol=\
    {0} {1} in {4} {5} cannot be applied to given types\n\
    required: {2}\n\
    found: {3}
 compiler.err.cant.apply.symbol.1=\
    {0} {1} in {4} {5} cannot be applied to given types;\n\
    required: {2}\n\
    found: {3}\n\
    reason: {6}
compiler.err.cant.assign.val.to.final.var=\
    cannot assign a value to final variable {0}
compiler.err.cant.deref=\
    {0} cannot be dereferenced
compiler.err.cant.extend.intf.annotation=\
    ''extends'' not allowed for @interfaces
compiler.err.cant.inherit.from.final=\
    cannot inherit from final {0}
compiler.err.cant.ref.before.ctor.called=\
    cannot reference {0} before supertype constructor has been called
compiler.err.cant.ret.val.from.meth.decl.void=\
    cannot return a value from method whose result type is void
compiler.err.cant.select.static.class.from.param.type=\
    cannot select a static class from a parameterized type
compiler.err.cant.inherit.diff.arg=\
    {0} cannot be inherited with different arguments: <{1}> and <{2}>
compiler.err.catch.without.try=\
    ''catch'' without ''try''
compiler.err.clash.with.pkg.of.same.name=\
    {0} clashes with package of same name
compiler.err.const.expr.req=\
    constant expression required
compiler.err.enum.const.req=\
    unqualified enumeration constant name required
compiler.err.cont.outside.loop=\
    continue outside of loop
compiler.err.cyclic.inheritance=\
    cyclic inheritance involving {0}
compiler.err.cyclic.annotation.element=\
    cyclic annotation element type
compiler.err.call.to.super.not.allowed.in.enum.ctor=\
    call to super not allowed in enum constructor
compiler.err.no.superclass=\
    {0} has no superclass

compiler.err.concrete.inheritance.conflict=\
    methods {0} from {1} and {2} from {3} are inherited with the same signature

compiler.err.default.allowed.in.intf.annotation.member=\
    default value only allowed in an @interface member
compiler.err.doesnt.exist=\
    package {0} does not exist
compiler.err.duplicate.annotation=\
    duplicate annotation
compiler.err.duplicate.annotation.member.value=\
    duplicate annotation member value {0} in {1}
compiler.err.duplicate.class=\
    duplicate class: {0}
compiler.err.duplicate.case.label=\
    duplicate case label
compiler.err.duplicate.default.label=\
    duplicate default label

compiler.err.else.without.if=\
    ''else'' without ''if''
compiler.err.empty.bytecode.ident=\
    empty bytecode identifier
compiler.err.empty.char.lit=\
    empty character literal
compiler.err.encl.class.required=\
    an enclosing instance that contains {0} is required
compiler.err.enum.annotation.must.be.enum.constant=\
    an enum annotation value must be an enum constant

compiler.err.enum.cant.be.instantiated=\
    enum types may not be instantiated
compiler.err.enum.label.must.be.unqualified.enum=\
    an enum switch case label must be the unqualified name of an enumeration constant
compiler.err.enum.no.subclassing=\
    classes cannot directly extend java.lang.Enum
compiler.err.enum.types.not.extensible=\
    enum types are not extensible
compiler.err.enum.no.finalize=\
    enums cannot have finalize methods
compiler.err.error.reading.file=\
    error reading {0}; {1}
compiler.err.except.already.caught=\
    exception {0} has already been caught
compiler.err.except.never.thrown.in.try=\
    exception {0} is never thrown in body of corresponding try statement

compiler.err.final.parameter.may.not.be.assigned=\
    final parameter {0} may not be assigned
compiler.err.finally.without.try=\
    ''finally'' without ''try''
compiler.err.foreach.not.applicable.to.type=\
    foreach not applicable to expression type
compiler.err.fp.number.too.large=\
    floating point number too large
compiler.err.fp.number.too.small=\
    floating point number too small

compiler.err.generic.array.creation=\
    generic array creation
compiler.err.generic.throwable=\
    a generic class may not extend java.lang.Throwable

compiler.err.icls.cant.have.static.decl=\
    inner classes cannot have static declarations
compiler.err.illegal.bytecode.ident.char=\
    illegal bytecode identifier character: \\{0}
compiler.err.illegal.char=\
    illegal character: \\{0}
compiler.err.illegal.char.for.encoding=\
    unmappable character for encoding {0}
compiler.err.illegal.combination.of.modifiers=\
    illegal combination of modifiers: {0} and {1}
compiler.err.illegal.enum.static.ref=\
    illegal reference to static field from initializer
compiler.err.illegal.esc.char=\
    illegal escape character
compiler.err.illegal.forward.ref=\
    illegal forward reference
compiler.warn.forward.ref=\
    reference to variable ''{0}'' before it has been initialized
compiler.err.illegal.self.ref=\
    self-reference in initializer
compiler.warn.self.ref=\
    self-reference in initializer of variable ''{0}''
compiler.err.illegal.generic.type.for.instof=\
    illegal generic type for instanceof
compiler.err.illegal.initializer.for.type=\
    illegal initializer for {0}
compiler.err.illegal.line.end.in.char.lit=\
    illegal line end in character literal
compiler.err.illegal.nonascii.digit=\
    illegal non-ASCII digit
compiler.err.illegal.qual.not.icls=\
    illegal qualifier; {0} is not an inner class
compiler.err.illegal.start.of.expr=\
    illegal start of expression
compiler.err.illegal.start.of.type=\
    illegal start of type
compiler.err.illegal.unicode.esc=\
    illegal unicode escape
compiler.err.import.requires.canonical=\
    import requires canonical name for {0}
compiler.err.improperly.formed.type.param.missing=\
    improperly formed type, some parameters are missing
compiler.err.improperly.formed.type.inner.raw.param=\
    improperly formed type, type parameters given on a raw type
compiler.err.incomparable.types=\
    incomparable types: {0} and {1}
compiler.err.int.number.too.large=\
    integer number too large: {0}
compiler.err.internal.error.cant.instantiate=\
    internal error; cannot instantiate {0} at {1} to ({2})
compiler.err.intf.annotation.members.cant.have.params=\
    @interface members may not have parameters
compiler.err.intf.annotation.cant.have.type.params=\
    @interface may not have type parameters
compiler.err.intf.annotation.members.cant.have.type.params=\
    @interface members may not have type parameters
compiler.err.intf.annotation.member.clash=\
    @interface member clashes with method ''{0}'' in {1}
compiler.err.intf.expected.here=\
    interface expected here
compiler.err.intf.meth.cant.have.body=\
    interface methods cannot have body
compiler.err.invalid.annotation.member.type=\
    invalid type for annotation member
compiler.err.invalid.hex.number=\
    hexadecimal numbers must contain at least one hexadecimal digit
compiler.err.invalid.meth.decl.ret.type.req=\
    invalid method declaration; return type required

compiler.err.label.already.in.use=\
    label {0} already in use
compiler.err.local.var.accessed.from.icls.needs.final=\
    local variable {0} is accessed from within inner class; needs to be declared final
compiler.err.local.enum=\
    enum types must not be local
compiler.err.cannot.create.array.with.type.arguments=\
    cannot create array with type arguments

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=\
    code too large
compiler.err.limit.code.too.large.for.try.stmt=\
    code too large for try statement
compiler.err.limit.dimensions=\
    array type has too many dimensions
compiler.err.limit.locals=\
    too many local variables
compiler.err.limit.parameters=\
    too many parameters
compiler.err.limit.pool=\
    too many constants
compiler.err.limit.pool.in.class=\
    too many constants in class {0}
compiler.err.limit.stack=\
    code requires too much stack
compiler.err.limit.string=\
    constant string too long
compiler.err.limit.string.overflow=\
    UTF8 representation for string \"{0}...\" is too long for the constant pool

compiler.err.malformed.fp.lit=\
    malformed floating point literal
compiler.err.method.does.not.override.superclass=\
    method does not override or implement a method from a supertype
compiler.err.missing.meth.body.or.decl.abstract=\
    missing method body, or declare abstract
compiler.err.missing.ret.stmt=\
    missing return statement
compiler.err.missing.ret.val=\
    missing return value
compiler.err.mod.not.allowed.here=\
    modifier {0} not allowed here
compiler.err.intf.not.allowed.here=\
    interface not allowed here
compiler.err.enums.must.be.static=\
    enum declarations allowed only in static contexts

compiler.err.name.clash.same.erasure=\
    name clash: {0} and {1} have the same erasure
compiler.err.name.clash.same.erasure.no.override=\
    name clash: {0} in {1} and {2} in {3} have the same erasure, yet neither overrides the other
compiler.err.name.reserved.for.internal.use=\
    {0} is reserved for internal use
compiler.err.native.meth.cant.have.body=\
    native methods cannot have a body
compiler.err.neither.conditional.subtype=\
incompatible types for ?: neither is a subtype of the other\n\
second operand: {0}\n\
third operand : {1}
compiler.err.new.not.allowed.in.annotation=\
    ''new'' not allowed in an annotation
compiler.err.no.annotation.member=\
    no annotation member {0} in {1}
compiler.err.no.encl.instance.of.type.in.scope=\
    no enclosing instance of type {0} is in scope
compiler.err.no.intf.expected.here=\
    no interface expected here
compiler.err.no.match.entry=\
    {0} has no match in entry in {1}; required {2}
compiler.err.not.annotation.type=\
    {0} is not an annotation type
compiler.err.not.def.access.class.intf.cant.access=\
    {0} in {1} is defined in an inaccessible class or interface
compiler.err.not.def.public.cant.access=\
    {0} is not public in {1}; cannot be accessed from outside package
compiler.err.not.loop.label=\
    not a loop label: {0}
compiler.err.not.stmt=\
    not a statement
compiler.err.not.encl.class=\
    not an enclosing class: {0}

compiler.err.operator.cant.be.applied=\
    operator {0} cannot be applied to {1}

compiler.err.pkg.annotations.sb.in.package-info.java=\
    package annotations should be in file package-info.java
compiler.err.pkg.clashes.with.class.of.same.name=\
    package {0} clashes with class of same name

compiler.err.warnings.and.werror=\
    warnings found and -Werror specified

# Errors related to annotation processing

compiler.err.proc.cant.access=\
cannot access {0}\n\
{1}\n\
Consult the following stack trace for details.\n\
{2}

compiler.err.proc.cant.find.class=\
    Could not find class file for ''{0}''.

# Print a client-generated error message; assumed to be localized, no translation required
compiler.err.proc.messager=\
    {0}

compiler.err.proc.no.explicit.annotation.processing.requested=\
    Class names, ''{0}'', are only accepted if annotation processing is explicitly requested

compiler.err.proc.no.service=\
    A service loader class could not be found.\n\
    Either java.util.ServiceLoader or sun.misc.Service must be available.

compiler.err.proc.processor.bad.option.name=\
    Bad option name ''{0}'' provided by processor ''{1}''

compiler.err.proc.processor.cant.instantiate=\
    Could not instantiate an instance of processor ''{0}''

compiler.err.proc.processor.constructor.error=\
    Exception thrown while constructing Processor object: {0}

compiler.err.proc.processor.not.found=\
    Annotation processor ''{0}'' not found

compiler.err.proc.processor.wrong.type=\
    Annotation processor ''{0}'' does not implement javax.annotation.processing.Processor

compiler.err.proc.service.problem=\
    Error creating a service loader to load Processors.

compiler.err.proc.bad.config.file=\
    Bad service configuration file, or exception thrown while constructing Processor object: {0}

compiler.err.proc.cant.create.loader=\
    Could not create class loader for annotation processors: {0}

compiler.err.qualified.new.of.static.class=\
    qualified new of static class

compiler.err.recursive.ctor.invocation=\
    recursive constructor invocation
compiler.err.ref.ambiguous=\
    reference to {0} is ambiguous, both {1} {2} in {3} and {4} {5} in {6} match
compiler.err.repeated.annotation.target=\
    repeated annotation target
compiler.err.repeated.interface=\
    repeated interface
compiler.err.repeated.modifier=\
    repeated modifier
compiler.err.report.access=\
    {0} has {1} access in {2}
compiler.err.ret.outside.meth=\
    return outside method

compiler.err.signature.doesnt.match.supertype=\
    signature does not match {0}; incompatible supertype
compiler.err.signature.doesnt.match.intf=\
    signature does not match {0}; incompatible interfaces
compiler.err.does.not.override.abstract=\
    {0} is not abstract and does not override abstract method {1} in {2}
compiler.err.source.cant.overwrite.input.file=\
    error writing source; cannot overwrite input file {0}
compiler.err.stack.sim.error=\
    Internal error: stack sim error on {0}
compiler.err.static.imp.only.classes.and.interfaces=\
    static import only from classes and interfaces
compiler.err.synthetic.name.conflict=\
    the symbol {0} conflicts with a compiler-synthesized symbol in {1}

compiler.err.throws.not.allowed.in.intf.annotation=\
    throws clause not allowed in @interface members
compiler.err.try.without.catch.or.finally=\
    ''try'' without ''catch'' or ''finally''
compiler.err.type.doesnt.take.params=\
    type {0} does not take parameters
compiler.err.type.var.cant.be.deref=\
    cannot select from a type variable
compiler.err.type.var.may.not.be.followed.by.other.bounds=\
    a type variable may not be followed by other bounds
compiler.err.type.var.more.than.once=\
    type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
compiler.err.type.var.more.than.once.in.result=\
    type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
compiler.err.types.incompatible.diff.ret=\
    types {0} and {1} are incompatible; both define {2}, but with unrelated return types

compiler.err.unclosed.bytecode.ident=\
    unclosed bytecode identifier
compiler.err.unclosed.char.lit=\
    unclosed character literal
compiler.err.unclosed.comment=\
    unclosed comment
compiler.err.unclosed.str.lit=\
    unclosed string literal
compiler.err.unknown.enum.constant=\
    in class file {0}: unknown enum constant {1}.{2}
compiler.err.unsupported.encoding=\
    unsupported encoding: {0}
compiler.err.io.exception=\
    error reading source file: {0}
compiler.err.undef.label=\
    undefined label: {0}
compiler.err.undetermined.type=\
    type parameters of {0} cannot be determined
compiler.err.undetermined.type.1=\
    type parameters of {0} cannot be determined; {1}
compiler.err.unreachable.stmt=\
    unreachable statement
compiler.err.initializer.must.be.able.to.complete.normally=\
    initializer must be able to complete normally
compiler.err.unreported.exception.need.to.catch.or.throw=\
    unreported exception {0}; must be caught or declared to be thrown
compiler.err.unreported.exception.default.constructor=\
    unreported exception {0} in default constructor
compiler.err.unsupported.cross.fp.lit=\
    hexadecimal floating-point literals are not supported on this VM
compiler.err.void.not.allowed.here=\
    ''void'' type not allowed here

compiler.err.wrong.number.type.args=\
    wrong number of type arguments; required {0}

compiler.err.var.might.already.be.assigned=\
    variable {0} might already have been assigned
compiler.err.var.might.not.have.been.initialized=\
    variable {0} might not have been initialized
compiler.err.var.might.be.assigned.in.loop=\
    variable {0} might be assigned in loop

# In the following string, {1} will always be the detail message from
# java.io.IOException.
compiler.err.class.cant.write=\
    error while writing {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
compiler.err.class.public.should.be.in.file=\
    class {0} is public, should be declared in a file named {0}.java

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=\
    error:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=\
    cannot read: {0}

#####

# Fatal Errors

compiler.misc.fatal.err.no.java.lang=\
    Fatal Error: Unable to find package java.lang in classpath or bootclasspath
compiler.misc.fatal.err.cant.locate.meth=\
    Fatal Error: Unable to find method {0}
compiler.misc.fatal.err.cant.locate.field=\
    Fatal Error: Unable to find field {0}
compiler.misc.fatal.err.cant.locate.ctor=\
    Fatal Error: Unable to find constructor for {0}

#####

##
## miscellaneous strings
##

compiler.misc.source.unavailable=\
    (source unavailable)
compiler.misc.base.membership=\
    all your base class are belong to us
compiler.misc.x.print.processor.info=\
    Processor {0} matches {1} and returns {2}.
compiler.misc.x.print.rounds=\
    Round {0}:\n\tinput files: {1}\n\tannotations: {2}\n\tlast round: {3}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".
compiler.note.note=\
    Note:\u0020

compiler.note.deprecated.filename=\
    {0} uses or overrides a deprecated API.
compiler.note.deprecated.plural=\
    Some input files use or override a deprecated API.
# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=\
    Recompile with -Xlint:deprecation for details.

compiler.note.deprecated.filename.additional=\
    {0} has additional uses or overrides of a deprecated API.
compiler.note.deprecated.plural.additional=\
    Some input files additionally use or override a deprecated API.

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
compiler.note.proc.messager=\
    {0}

compiler.note.unchecked.filename=\
    {0} uses unchecked or unsafe operations.
compiler.note.unchecked.plural=\
    Some input files use unchecked or unsafe operations.
# The following string may appear after one of the above deprecation
# messages.
compiler.note.unchecked.recompile=\
    Recompile with -Xlint:unchecked for details.

compiler.note.unchecked.filename.additional=\
    {0} has additional unchecked or unsafe operations.
compiler.note.unchecked.plural.additional=\
    Some input files additionally use unchecked or unsafe operations.

#####

compiler.misc.count.error=\
    {0} error
compiler.misc.count.error.plural=\
    {0} errors
compiler.misc.count.warn=\
    {0} warning
compiler.misc.count.warn.plural=\
    {0} warnings

## extra output when using -verbose (JavaCompiler)

compiler.misc.verbose.checking.attribution=\
    [checking {0}]
compiler.misc.verbose.parsing.done=\
    [parsing completed {0}ms]
compiler.misc.verbose.parsing.started=\
    [parsing started {0}]
compiler.misc.verbose.total=\
    [total {0}ms]
compiler.misc.verbose.wrote.file=\
    [wrote {0}]

## extra output when using -verbose (Retro)
compiler.misc.verbose.retro=\
    [retrofitting {0}]
compiler.misc.verbose.retro.with=\
    \tretrofitting {0} with {1}
compiler.misc.verbose.retro.with.list=\
    \tretrofitting {0} with type parameters {1}, supertype {2}, interfaces {3}

## extra output when using -verbose (code/ClassReader)
compiler.misc.verbose.loading=\
    [loading {0}]

compiler.misc.verbose.sourcepath=\
    [search path for source files: {0}]

compiler.misc.verbose.classpath=\
    [search path for class files: {0}]

## extra output when using -checkclassfile (code/ClassReader)
compiler.misc.ccf.found.later.version=\
    class file has later version than expected: {0}
compiler.misc.ccf.unrecognized.attribute=\
    unrecognized attribute: {0}

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=\
    R)esume, A)bort>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=\
    warning:\u0020

compiler.warn.constant.SVUID=\
    [serial] serialVersionUID must be constant in class {0}

compiler.warn.dir.path.element.not.found=\
    [path] bad path element "{0}": no such directory

compiler.warn.finally.cannot.complete=\
    [finally] finally clause cannot complete normally

compiler.warn.has.been.deprecated=\
    [deprecation] {0} in {1} has been deprecated

compiler.warn.sun.proprietary=\
    {0} is Sun proprietary API and may be removed in a future release

compiler.warn.illegal.char.for.encoding=\
    unmappable character for encoding {0}
compiler.warn.improper.SVUID=\
    [serial] serialVersionUID must be declared static final in class {0}

compiler.warn.inexact.non-varargs.call=\
non-varargs call of varargs method with inexact argument type for last parameter;\n\
cast to {0} for a varargs call\n\
cast to {1} for a non-varargs call and to suppress this warning

compiler.warn.long.SVUID=\
    [serial] serialVersionUID must be of type long in class {0}

compiler.warn.missing.SVUID=\
    [serial] serializable class {0} has no definition of serialVersionUID

compiler.warn.override.varargs.missing=\
    {0}; overridden method has no ''...''
compiler.warn.override.varargs.extra=\
    {0}; overriding method is missing ''...''
compiler.warn.override.bridge=\
    {0}; overridden method is a bridge method

compiler.warn.pkg-info.already.seen=\
    [package-info] a package-info.java file has already been seen for package {0}
compiler.warn.path.element.not.found=\
    [path] bad path element "{0}": no such file or directory
compiler.warn.possible.fall-through.into.case=\
    [fallthrough] possible fall-through into case

compiler.warn.redundant.cast=\
    [cast] redundant cast to {0}

compiler.warn.position.overflow=\
    Position encoding overflows at line {0}

compiler.warn.big.major.version=\
    {0}: major version {1} is newer than {2}, the highest major version supported by this compiler.\n\
    It is recommended that the compiler be upgraded.

# Warnings related to annotation processing
compiler.warn.proc.package.does.not.exist=\
    package {0} does not exist
compiler.warn.proc.file.reopening=\
    Attempt to create a file for ''{0}'' multiple times

compiler.warn.proc.type.already.exists=\
    A file for type ''{0}'' already exists on the sourcepath or classpath

compiler.warn.proc.type.recreate=\
    Attempt to create a file for type ''{0}'' multiple times

compiler.warn.proc.illegal.file.name=\
    Cannot create file for illegal name ''{0}''.

compiler.warn.proc.file.create.last.round=\
    File for type ''{0}'' created in the last round will not be subject to annotation processing.

compiler.warn.proc.malformed.supported.string=\
    Malformed string ''{0}'' for a supported annotation type returned by processor ''{1}''

compiler.warn.proc.annotations.without.processors=\
    No processor claimed any of these annotations: {0}

compiler.warn.proc.processor.incompatible.source.version=\
    Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''

compiler.warn.proc.proc-only.requested.no.procs=\
    Annotation processing without compilation requested but no processors were found.

compiler.warn.proc.use.implicit=\
Implicitly compiled files were not subject to annotation processing.\n\
Use -implicit to specify a policy for implicit compilation.

compiler.warn.proc.use.proc.or.implicit=\
Implicitly compiled files were not subject to annotation processing.\n\
Use -proc:none to disable annotation processing or -implicit to specify a policy for implicit compilation.

# Print a client-generated warning; assumed to be localized, no translation required
compiler.warn.proc.messager=\
    {0}

compiler.warn.proc.unclosed.type.files=\
    Unclosed files for the types ''{0}''; these types will not undergo annotation processing

compiler.warn.proc.unmatched.processor.options=\
    The following options were not recognized by any processor: ''{0}''

compiler.warn.unchecked.assign=\
    [unchecked] unchecked assignment: {0} to {1}
compiler.warn.unchecked.assign.to.var=\
    [unchecked] unchecked assignment to variable {0} as member of raw type {1}
compiler.warn.unchecked.call.mbr.of.raw.type=\
    [unchecked] unchecked call to {0} as a member of the raw type {1}
compiler.warn.unchecked.cast.to.type=\
    [unchecked] unchecked cast to type {0}
compiler.warn.unchecked.meth.invocation.applied=\
    [unchecked] unchecked method invocation: {0} {1} in {4} {5} is applied to given types\n\
    required: {2}\n\
    found: {3}

compiler.warn.unchecked.generic.array.creation=\
    [unchecked] unchecked generic array creation of type {0} for varargs parameter

compiler.warn.missing.deprecated.annotation=\
    [dep-ann] deprecated item is not annotated with @Deprecated

compiler.warn.invalid.archive.file=\
    [path] Unexpected file on path: {0}

compiler.warn.unexpected.archive.file=\
    [path] Unexpected extension for archive file: {0}

compiler.warn.div.zero=\
    [divzero] division by zero

compiler.warn.empty.if=\
    [empty] empty statement after if

compiler.warn.annotation.method.not.found=\
    Cannot find annotation method ''{1}()'' in type ''{0}''

compiler.warn.annotation.method.not.found.reason=\
    Cannot find annotation method ''{1}()'' in type ''{0}'': {2}

compiler.warn.raw.class.use=\
    [rawtypes] found raw type: {0}\n\
    missing type parameters for generic class {1}

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=\
    <identifier>
compiler.misc.token.character=\
    <character>
compiler.misc.token.string=\
    <string>
compiler.misc.token.integer=\
    <integer>
compiler.misc.token.long-integer=\
    <long integer>
compiler.misc.token.float=\
    <float>
compiler.misc.token.double=\
    <double>
compiler.misc.token.bad-symbol=\
    <bad symbol>
compiler.misc.token.end-of-input=\
    <end of input>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
compiler.err.expected=\
    {0} expected
compiler.err.expected2=\
    {0} or {1} expected
compiler.err.expected3=\
    {0}, {1}, or {2} expected

compiler.err.premature.eof=\
    reached end of file while parsing

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.dot.class.expected=\
    ''.class'' expected

## The argument to this string will always be either 'case' or 'default'.
compiler.err.orphaned=\
    orphaned {0}

compiler.misc.anonymous.class=\
    <anonymous {0}>

compiler.misc.type.captureof=\
    capture#{0} of {1}

compiler.misc.type.captureof.1=\
    capture#{0}

compiler.misc.type.none=\
    <none>

compiler.misc.unnamed.package=\
    unnamed package

#####

compiler.err.cant.access=\
cannot access {0}\n\
{1}

compiler.misc.bad.class.file.header=\
bad class file: {0}\n\
{1}\n\
Please remove or make sure it appears in the correct subdirectory of the classpath.
compiler.misc.bad.source.file.header=\
bad source file: {0}\n\
{1}\n\
Please remove or make sure it appears in the correct subdirectory of the sourcepath.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=\
    bad class signature: {0}
compiler.misc.bad.enclosing.method=\
    bad enclosing method attribute: {0}
compiler.misc.bad.runtime.invisible.param.annotations=\
    bad RuntimeInvisibleParameterAnnotations attribute: {0}
compiler.misc.bad.const.pool.tag=\
    bad constant pool tag: {0}
compiler.misc.bad.const.pool.tag.at=\
    bad constant pool tag: {0} at {1}
compiler.misc.bad.signature=\
    bad signature: {0}
compiler.misc.class.file.wrong.class=\
    class file contains wrong class: {0}
compiler.misc.class.file.not.found=\
    class file for {0} not found
compiler.misc.file.doesnt.contain.class=\
    file does not contain class {0}
compiler.misc.file.does.not.contain.package=\
    file does not contain package {0}
compiler.misc.illegal.start.of.class.file=\
    illegal start of class file
compiler.misc.unable.to.access.file=\
    unable to access file: {0}
compiler.misc.unicode.str.not.supported=\
    unicode string in class file not supported
compiler.misc.undecl.type.var=\
    undeclared type variable: {0}
compiler.misc.wrong.version=\
    class file has wrong version {0}.{1}, should be {2}.{3}

#####

compiler.err.not.within.bounds=\
    type parameter {0} is not within its bound

compiler.err.not.within.bounds.explain=\
    type parameter {0} is not within its bound; {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

compiler.err.prob.found.req=\
{0}\n\
required: {2}\n\
found:    {1}
compiler.warn.prob.found.req=\
{0}\n\
required: {2}\n\
found:    {1}
compiler.err.prob.found.req.1=\
{0} {3}\n\
required: {2}\n\
found:    {1}

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.incompatible.types=\
    incompatible types
compiler.misc.incompatible.types.1=\
    incompatible types; {0}
compiler.misc.inconvertible.types=\
    inconvertible types
compiler.misc.possible.loss.of.precision=\
    possible loss of precision

compiler.misc.unchecked.assign=\
    [unchecked] unchecked conversion
# compiler.misc.storecheck=\
#     [unchecked] assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     [unchecked] assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=\
    [unchecked] unchecked cast

compiler.misc.assignment.from.super-bound=\
    assignment from super-bound type {0}
compiler.misc.assignment.to.extends-bound=\
    assignment to extends-bound type {0}
# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

#####

compiler.err.type.found.req=\
unexpected type\n\
required: {1}\n\
found:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=\
    class
compiler.misc.type.req.class.array=\
    class or array
compiler.misc.type.req.ref=\
    reference
compiler.misc.type.req.exact=\
    class or interface without bounds
compiler.misc.type.parameter=\
    type parameter {0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"
compiler.misc.undetermined.type=\
    undetermined type
ncompiler.misc.type.variable.has.undetermined.type=\
    type variable {0} has undetermined type
compiler.misc.no.unique.maximal.instance.exists=\
    no unique maximal instance exists for type variable {0} with upper bounds {1}
compiler.misc.no.unique.minimal.instance.exists=\
    no unique minimal instance exists for type variable {0} with lower bounds {1}
compiler.misc.no.conforming.instance.exists=\
    no instance(s) of type variable(s) {0} exist so that {1} conforms to {2}
compiler.misc.no.conforming.assignment.exists=\
    no instance(s) of type variable(s) {0} exist so that argument type {1} conforms to formal parameter type {2}
compiler.misc.arg.length.mismatch=\
    cannot instantiate from arguments because actual and formal argument lists differ in length
compiler.misc.inferred.do.not.conform.to.bounds=\
    inferred type argument(s) {0} do not conform to bounds of type variable(s) {1}

#####

## The first argument ({0}) is a "kindname".
compiler.err.abstract.cant.be.accessed.directly=\
    abstract {0} {1} in {2} cannot be accessed directly

## The first argument ({0}) is a "kindname".
compiler.err.non-static.cant.be.ref=\
    non-static {0} {1} cannot be referenced from a static context

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
compiler.err.unexpected.type=\
unexpected type\n\
required: {0}\n\
found:    {1}

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
compiler.err.cant.resolve=\
    cannot find symbol\n\
    symbol: {0} {1}

compiler.err.cant.resolve.args=\
    cannot find symbol\n\
    symbol: {0} {1}({3})

compiler.err.cant.resolve.args.params=\
    cannot find symbol\n\
    symbol: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The sixth argument {5} is the location type
compiler.err.cant.resolve.location=\
    cannot find symbol\n\
    symbol:   {0} {1}\n\
    location: {4} {5}

compiler.err.cant.resolve.location.args=\
    cannot find symbol\n\
    symbol:   {0} {1}({3})\n\
    location: {4} {5}

compiler.err.cant.resolve.location.args.params=\
    cannot find symbol\n\
    symbol:   {0} <{2}>{1}({3})\n\
    location: {4} {5}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=\
    @interface
compiler.misc.kindname.constructor=\
    constructor
compiler.misc.kindname.interface=\
    interface
compiler.misc.kindname.static=\
    static
compiler.misc.kindname.type.variable=\
    type variable
compiler.misc.kindname.type.variable.bound=\
    bound of type variable
compiler.misc.kindname.variable=\
    variable
compiler.misc.kindname.value=\
    value
compiler.misc.kindname.method=\
    method
compiler.misc.kindname.class=\
    class
compiler.misc.kindname.package=\
    package
#####

compiler.misc.no.args=\
    no arguments

compiler.err.override.static=\
    {0}; overriding method is static
compiler.err.override.meth=\
    {0}; overridden method is {1}

compiler.err.override.meth.doesnt.throw=\
    {0}; overridden method does not throw {1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
compiler.err.override.weaker.access=\
    {0}; attempting to assign weaker access privileges; was {1}

compiler.misc.override.incompatible.ret=\
    {0}; attempting to use incompatible return type

compiler.misc.override.unchecked.ret=\
    {0}; return type requires unchecked conversion

## The following are all possible strings for the first argument ({0}) of the
## above strings.
compiler.misc.cant.override=\
    {0} in {1} cannot override {2} in {3}
compiler.misc.cant.implement=\
    {0} in {1} cannot implement {2} in {3}
compiler.misc.clashes.with=\
    {0} in {1} clashes with {2} in {3}
compiler.misc.unchecked.override=\
    {0} in {1} overrides {2} in {3}
compiler.misc.unchecked.implement=\
    {0} in {1} implements {2} in {3}
compiler.misc.unchecked.clash.with=\
    {0} in {1} overrides {2} in {3}
compiler.misc.varargs.override=\
    {0} in {1} overrides {2} in {3}
compiler.misc.varargs.implement=\
    {0} in {1} implements {2} in {3}
compiler.misc.varargs.clash.with=\
    {0} in {1} overrides {2} in {3}

########################################
# Diagnostics for language feature changes
########################################
compiler.err.unsupported.fp.lit=\
    hexadecimal floating-point literals are not supported before -source 5

compiler.warn.enum.as.identifier=\
    as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n\
(use -source 5 or higher to use ''enum'' as a keyword)

compiler.warn.assert.as.identifier=\
    as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n\
(use -source 1.4 or higher to use ''assert'' as a keyword)

compiler.err.enum.as.identifier=\
    as of release 5, ''enum'' is a keyword, and may not be used as an identifier\n\
(use -source 1.4 or lower to use ''enum'' as an identifier)

compiler.err.assert.as.identifier=\
    as of release 1.4, ''assert'' is a keyword, and may not be used as an identifier\n\
(use -source 1.3 or lower to use ''assert'' as an identifier)

compiler.err.generics.not.supported.in.source=\
    generics are not supported in -source {0}\n\
(use -source 5 or higher to enable generics)

compiler.err.varargs.not.supported.in.source=\
    variable-arity methods are not supported in -source {0}\n\
(use -source 5 or higher to enable variable-arity methods)

compiler.err.annotations.not.supported.in.source=\
    annotations are not supported in -source {0}\n\
(use -source 5 or higher to enable annotations)

compiler.err.foreach.not.supported.in.source=\
    for-each loops are not supported in -source {0}\n\
(use -source 5 or higher to enable for-each loops)

compiler.err.static.import.not.supported.in.source=\
    static import declarations are not supported in -source {0}\n\
(use -source 5 or higher to enable static import declarations)

compiler.err.enums.not.supported.in.source=\
    enums are not supported in -source {0}\n\
(use -source 5 or higher to enable enums)

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=\
    <null>

# X#n (where n is an int id) is disambiguated tvar name
compiler.misc.type.var=\
    {0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
compiler.misc.captured.type=\
    CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
compiler.misc.intersection.type=\
    INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
compiler.misc.where.captured=\
    {0} extends {1} super: {2} from capture of {3}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
compiler.misc.where.captured.1=\
    {0} extends {1} from capture of {3}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
compiler.misc.where.typevar=\
    {0} extends {1} declared in {2} {3}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
compiler.misc.where.typevar.1=\
    {0} declared in {2} {3}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
compiler.misc.where.intersection=\
    {0} extends {1}

### Where clause headers ###
compiler.misc.where.description.captured=\
    where {0} is a fresh type-variable:
compiler.misc.where.description.typevar=\
    where {0} is a type-variable:
compiler.misc.where.description.intersection=\
    where {0} is an intersection type:
compiler.misc.where.description.captured.1=\
    where {0} are fresh type-variables:
compiler.misc.where.description.typevar.1=\
    where {0} are type-variables:
compiler.misc.where.description.intersection.1=\
    where {0} are intersection types:


