#
# Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

################################################################
#
# Check that GNU make and cygwin are recent enough.
# Setup common utility functions.
#
################################################################

ifndef _MAKEBASE_GMK
_MAKEBASE_GMK := 1

ifeq (,$(findstring 3.81,$(MAKE_VERSION)))
    ifeq (,$(findstring 3.82,$(MAKE_VERSION)))
        $(error This version of GNU Make is too low ($(MAKE_VERSION)). Please upgrade to 3.81 or newer.)
    endif
endif

ifneq (,$(CYGPATH))
    # Cygwin styff, if needed but most is going to be
    # done in configure!
    ifeq (yes,$(CHECK_FOR_VCINSTALLDIR))
        ifeq (,$(VCINSTALLDIR)) 
            $(info Could not find compiler paths!)
            $(info You probably configured the build from within a)
            $(info VS command prompt, but you are not using such a)
            $(info prompt right now.)
            $(info If you instead run configure from a plain cygwin shell, it)
            $(info will attempt to setup VS for you! Please try that.)
            $(error Giving up for now.)
        endif
    endif
endif

# The build times report is turned off by setting REPORT_BUILD_TIMES to nothing.
# This is necessary for the target clean which will erase the
# directories where the buildtimes are stored.
REPORT_BUILD_TIMES=1
# Store the build times in this directory.
BUILDTIMESDIR=$(OUTPUT_ROOT)/tmp/buildtimes

# Record starting time for build of a sub repository.
define RecordStartTime
$(MKDIR) -p $(BUILDTIMESDIR)
$(DATE) '+%Y %m %d %H %M %S' | $(NAWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)/build_time_start_$1
$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)/build_time_start_$1_human_readable
endef

# Indicate that we started to build a sub repository and record starting time. 
define MakeStart
$(call RecordStartTime,$1)
$(BUILD_LOG_WRAPPER) $(PRINTF) "\n\n%s\n%s\n##### %-60.60s #####\n%s\n\n" \
"########################################################################" \
"########################################################################" \
"Entering $1 for target(s) $2" \
"########################################################################"
endef

# Record ending time and calculate the difference and store it in a
# easy to read format. Handles builds that cross midnight. Expects
# that a build will never take 24 hours or more. 
define RecordEndTime
$(DATE) '+%Y %m %d %H %M %S' | $(NAWK) '{ print $$1,$$2,$$3,$$4,$$5,$$6,($$4*3600+$$5*60+$$6) }' > $(BUILDTIMESDIR)/build_time_end_$1
$(DATE) '+%Y-%m-%d %H:%M:%S' > $(BUILDTIMESDIR)/build_time_end_$1_human_readable
$(ECHO) `$(CAT) $(BUILDTIMESDIR)/build_time_start_$1` `$(CAT) $(BUILDTIMESDIR)/build_time_end_$1` $1 | \
  $(NAWK) '{ F=$$7; T=$$14; if (F > T) { T+=3600*24 }; D=T-F; H=int(D/3600); \
             M=int((D-H*3600)/60); S=D-H*3600-M*60; printf("%02d:%02d:%02d %s\n",H,M,S,$$15); }' \
  > $(BUILDTIMESDIR)/build_time_diff_$1
endef

# Check if the current target is the final target, as specified by
# the user on the command line. If so, call PrintEndMessage.
define CheckIfFinished
$(if $(filter $@,$(MAKECMDGOALS)),$(call PrintEndMessage))
# If no taget is given, "all" is default. Check for that, too.
# At most one of the tests can be true.
$(if $(MAKECMDGOALS),,$(if $(filter $@,all),$(call PrintEndMessage)))
endef

# Indicate that we are done.
# Record ending time and print out the total time it took to build.
define MakeFinish 
$(if $(REPORT_BUILD_TIMES),$(call RecordEndTime,$1),) 
$(BUILD_LOG_WRAPPER) $(PRINTF) "%s\n##### %-60.60s #####\n%s\n##### %-60.60s #####\n%s\n\n" \
"########################################################################" \
"Leaving $1 for target(s) $2" \
"########################################################################" \
$(if $(REPORT_BUILD_TIMES),"Build time `$(CAT) $(BUILDTIMESDIR)/build_time_diff_$1` for target(s) $2","") \
"########################################################################"
$(call CheckIfFinished)
endef

# Find all build_time_* files and print their contents in a list sorted
# on the name of the sub repository.
define ReportBuildTimes
$(BUILD_LOG_WRAPPER) $(PRINTF) -- "-- Build times ----------\nTarget %s\nStart %s\nEnd   %s\n%s\n%s\n-------------------------\n" \
"$1" \
"`$(CAT) $(BUILDTIMESDIR)/build_time_start_TOTAL_human_readable`" \
"`$(CAT) $(BUILDTIMESDIR)/build_time_end_TOTAL_human_readable`" \
"`$(LS) $(BUILDTIMESDIR)/build_time_diff_* | $(GREP) -v _TOTAL | $(XARGS) $(CAT) | $(SORT) -k 2`" \
"`$(CAT) $(BUILDTIMESDIR)/build_time_diff_TOTAL`"
endef

define ResetTimers
$$(shell $(MKDIR) -p $(BUILDTIMESDIR) &&  $(RM) $(BUILDTIMESDIR)/build_time_*)
endef

define StartTimer
	$(call RecordStartTime,TOTAL)
endef

define StopTimer
	$(if $(REPORT_BUILD_TIMES),$(call RecordEndTime,TOTAL) && $(call ReportBuildTimes,$1),)
endef

# Hook to be called as the very first thing when running a normal build
define AtRootMakeStart
	$(call PrintStartMessage)
	$(call StartTimer)
endef

# Hook to be called as the very last thing for targets that are "top level" targets
define AtRootMakeEnd
	$(call StopTimer)
	$(call CheckIfFinished)
endef

# If the variable that you want to send to stdout for piping into a file or otherwise,
# is potentially long, for example the a list of file paths, eg a list of all package directories.
# Then you need to use ListPathsSafely, which optimistically splits the output into several shell
# calls as well as use compression on recurrent file paths segments, to get around the potential
# command line length problem that exists in cygwin and other shells.
compress_pre:=$(strip $(shell cat $(SRC_ROOT)/common/makefiles/compress.pre))
compress_post:=$(strip $(shell cat $(SRC_ROOT)/common/makefiles/compress.post))
compress_paths=$(compress_pre)\
$(subst $(SRC_ROOT),X97,\
$(subst $(OUTPUT_ROOT),X98,\
$(subst X,X00,\
$(subst $(SPACE),\n,$(strip $1)))))\
$(compress_post)

decompress_paths=sed -f $(SRC_ROOT)/common/makefiles/uncompress.sed -e 's|X99|\\n|g' \
		     -e 's|X98|$(OUTPUT_ROOT)|g' -e 's|X97|$(SRC_ROOT)|g' \
		     -e 's|X00|X|g' | tr '\n' '$2'

define ListPathsSafely_If
    $(if $(word $3,$($1)),$(eval $1_LPS$3:=$(call compress_paths,$(wordlist $3,$4,$($1)))))
endef

define ListPathsSafely_Printf
    $(if $(strip $($1_LPS$4)),printf -- "$(strip $($1_LPS$4))\n" | $(decompress_paths) $3)
endef

# Receipt example:
#    rm -f thepaths
#    $(call ListPathsSafely,THEPATHS,\n, >> thepaths)
#    The \n argument means translate spaces into \n
#    if instead , , (a space) is supplied, then spaces remain spaces.
define ListPathsSafely
    $(if $(word 10001,$($1)),$(error Cannot list safely more than 10000 paths. $1 has $(words $($1)) paths!))
    $(call ListPathsSafely_If,$1,$2,1,250)
    $(call ListPathsSafely_If,$1,$2,251,500)
    $(call ListPathsSafely_If,$1,$2,501,750)
    $(call ListPathsSafely_If,$1,$2,751,1000)

    $(call ListPathsSafely_If,$1,$2,1001,1250)
    $(call ListPathsSafely_If,$1,$2,1251,1500)
    $(call ListPathsSafely_If,$1,$2,1501,1750)
    $(call ListPathsSafely_If,$1,$2,1751,2000)

    $(call ListPathsSafely_If,$1,$2,2001,2250)
    $(call ListPathsSafely_If,$1,$2,2251,2500)
    $(call ListPathsSafely_If,$1,$2,2501,2750)
    $(call ListPathsSafely_If,$1,$2,2751,3000)

    $(call ListPathsSafely_If,$1,$2,3001,3250)
    $(call ListPathsSafely_If,$1,$2,3251,3500)
    $(call ListPathsSafely_If,$1,$2,3501,3750)
    $(call ListPathsSafely_If,$1,$2,3751,4000)

    $(call ListPathsSafely_If,$1,$2,4001,4250)
    $(call ListPathsSafely_If,$1,$2,4251,4500)
    $(call ListPathsSafely_If,$1,$2,4501,4750)
    $(call ListPathsSafely_If,$1,$2,4751,5000)

    $(call ListPathsSafely_If,$1,$2,5001,5250)
    $(call ListPathsSafely_If,$1,$2,5251,5500)
    $(call ListPathsSafely_If,$1,$2,5501,5750)
    $(call ListPathsSafely_If,$1,$2,5751,6000)

    $(call ListPathsSafely_If,$1,$2,6001,6250)
    $(call ListPathsSafely_If,$1,$2,6251,6500)
    $(call ListPathsSafely_If,$1,$2,6501,6750)
    $(call ListPathsSafely_If,$1,$2,6751,7000)

    $(call ListPathsSafely_If,$1,$2,7001,7250)
    $(call ListPathsSafely_If,$1,$2,7251,7500)
    $(call ListPathsSafely_If,$1,$2,7501,7750)
    $(call ListPathsSafely_If,$1,$2,7751,8000)

    $(call ListPathsSafely_If,$1,$2,8001,8250)
    $(call ListPathsSafely_If,$1,$2,8251,8500)
    $(call ListPathsSafely_If,$1,$2,8501,8750)
    $(call ListPathsSafely_If,$1,$2,8751,9000)

    $(call ListPathsSafely_If,$1,$2,9001,9250)
    $(call ListPathsSafely_If,$1,$2,9251,9500)
    $(call ListPathsSafely_If,$1,$2,9501,9750)
    $(call ListPathsSafely_If,$1,$2,9751,10000)

    $(call ListPathsSafely_Printf,$1,$2,$3,1)
    $(call ListPathsSafely_Printf,$1,$2,$3,251)
    $(call ListPathsSafely_Printf,$1,$2,$3,501)
    $(call ListPathsSafely_Printf,$1,$2,$3,751)

    $(call ListPathsSafely_Printf,$1,$2,$3,1001)
    $(call ListPathsSafely_Printf,$1,$2,$3,1251)
    $(call ListPathsSafely_Printf,$1,$2,$3,1501)
    $(call ListPathsSafely_Printf,$1,$2,$3,1751)

    $(call ListPathsSafely_Printf,$1,$2,$3,2001)
    $(call ListPathsSafely_Printf,$1,$2,$3,2251)
    $(call ListPathsSafely_Printf,$1,$2,$3,2501)
    $(call ListPathsSafely_Printf,$1,$2,$3,2751)

    $(call ListPathsSafely_Printf,$1,$2,$3,3001)
    $(call ListPathsSafely_Printf,$1,$2,$3,3251)
    $(call ListPathsSafely_Printf,$1,$2,$3,3501)
    $(call ListPathsSafely_Printf,$1,$2,$3,3751)

    $(call ListPathsSafely_Printf,$1,$2,$3,4001)
    $(call ListPathsSafely_Printf,$1,$2,$3,4251)
    $(call ListPathsSafely_Printf,$1,$2,$3,4501)
    $(call ListPathsSafely_Printf,$1,$2,$3,4751)

    $(call ListPathsSafely_Printf,$1,$2,$3,5001)
    $(call ListPathsSafely_Printf,$1,$2,$3,5251)
    $(call ListPathsSafely_Printf,$1,$2,$3,5501)
    $(call ListPathsSafely_Printf,$1,$2,$3,5751)

    $(call ListPathsSafely_Printf,$1,$2,$3,6001)
    $(call ListPathsSafely_Printf,$1,$2,$3,6251)
    $(call ListPathsSafely_Printf,$1,$2,$3,6501)
    $(call ListPathsSafely_Printf,$1,$2,$3,6751)

    $(call ListPathsSafely_Printf,$1,$2,$3,7001)
    $(call ListPathsSafely_Printf,$1,$2,$3,7251)
    $(call ListPathsSafely_Printf,$1,$2,$3,7501)
    $(call ListPathsSafely_Printf,$1,$2,$3,7751)

    $(call ListPathsSafely_Printf,$1,$2,$3,8001)
    $(call ListPathsSafely_Printf,$1,$2,$3,8251)
    $(call ListPathsSafely_Printf,$1,$2,$3,8501)
    $(call ListPathsSafely_Printf,$1,$2,$3,8751)

    $(call ListPathsSafely_Printf,$1,$2,$3,9001)
    $(call ListPathsSafely_Printf,$1,$2,$3,9251)
    $(call ListPathsSafely_Printf,$1,$2,$3,9501)
    $(call ListPathsSafely_Printf,$1,$2,$3,9751)
endef

define ListPathsSafelyNow_IfPrintf
    ifneq (,$$(word $4,$$($1)))
        $$(eval $1_LPS$4:=$$(call compress_paths,$$(wordlist $4,$5,$$($1))))
        $$(shell printf -- "$$(strip $$($1_LPS$4))\n" | $(decompress_paths) $3)
    endif
endef

# And an non-receipt version:
define ListPathsSafelyNow
    ifneq (,$$(word 10001,$$($1)))
        $$(error Cannot list safely more than 10000 paths. $1 has $$(words $$($1)) paths!)
    endif
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,1,250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,251,500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,501,750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,751,1000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,1001,1250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,1251,1500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,1501,1750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,1751,2000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,2001,2250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,2251,2500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,2501,2750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,2751,3000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,3001,3250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,3251,3500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,3501,3750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,3751,4000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,4001,4250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,4251,4500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,4501,4750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,4751,5000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,5001,5250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,5251,5500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,5501,5750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,5751,6000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,6001,6250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,6251,6500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,6501,6750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,6751,7000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,7001,7250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,7251,7500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,7501,7750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,7751,8000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,8001,8250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,8251,8500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,8501,8750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,8751,9000)

    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,9001,9250)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,9251,9500)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,9501,9750)
    $(call ListPathsSafelyNow_IfPrintf,$1,$2,$3,9751,10000)

endef

# The source tips can come from the Mercurial repository, or in the files
#   $(HGTIP_FILENAME) which contains the tip but is also positioned in the same
#   directory as the original $(HGDIR) directory.
#   These should not be := assignments, only used from the root Makefile.
HG_VERSION = $(shell $(HG) version 2> /dev/null)
HG_DIRECTORY=.hg
HGTIP_FILENAME=.hgtip
HG_SEARCH = ./REPO ./*/REPO ./*/*/REPO ./*/*/*/REPO
REPO_LIST = $(patsubst ./%,%,$(patsubst %/,%,$(sort $(dir \
    $(shell $(CD) $(SRC_ROOT) ; ( $(LS) -d $(HG_SEARCH:%/REPO=%/$(HG_DIRECTORY)) ; \
                                   $(LS)    $(HG_SEARCH:%/REPO=%/$(HGTIP_FILENAME)) ) \
	        2> /dev/null)))))

# Emit the repo:tip pairs to $@
define GetSourceTips
$(CD) $(SRC_ROOT) ; \
for i in $(REPO_LIST) IGNORE ; do \
  if [ "$${i}" = "IGNORE" ] ; then \
    continue; \
  elif [ -d $${i}/$(HG_DIRECTORY) -a "$(HG_VERSION)" != "" ] ; then \
    $(PRINTF) " %s:%s" \
      "$${i}" `$(HG) tip --repository $${i} --template '{node|short}\n'` ; \
  elif [ -f $${i}/$(HGTIP_FILENAME) ] ; then \
    $(PRINTF) " %s:%s" \
      "$${i}" `$(CAT) $${i}/$(HGTIP_FILENAME)` ; \
  fi; \
done >> $@
$(PRINTF) "\n" >> $@
endef

# Create the HGTIP_FILENAME file. Called from jdk/make/closed/bundles.gmk
define CreateHgTip
$(HG) tip --repository $1 --template '{node|short}\n' > $1/$(HGTIP_FILENAME);\
$(ECHO) $1/$(HGTIP_FILENAME)
endef

define SetupLogging
    ifneq ($(findstring $(LOG),debug trace),)
        # Shell redefinition trick inspired by http://www.cmcrossroads.com/ask-mr-make/6535-tracing-rule-execution-in-gnu-make
        OLD_SHELL:=$$(SHELL)
        SHELL = $$(warning Building $$@$$(if $$<, (from $$<))$(if $$?, ($$? newer)))$$(OLD_SHELL) -x
    endif
endef

# Make sure logging is setup for everyone that includes MakeBase.gmk.
$(eval $(call SetupLogging))

endif # _MAKEBASE_GMK
