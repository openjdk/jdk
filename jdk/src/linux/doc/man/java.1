'\" t
.\"  Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
.\"
.\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
.\"
.\" This code is free software; you can redistribute it and/or modify it
.\" under the terms of the GNU General Public License version 2 only, as
.\" published by the Free Software Foundation.
.\"
.\" This code is distributed in the hope that it will be useful, but WITHOUT
.\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
.\" FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
.\" version 2 for more details (a copy is included in the LICENSE file that
.\" accompanied this code).
.\"
.\" You should have received a copy of the GNU General Public License version
.\" 2 along with this work; if not, write to the Free Software Foundation,
.\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
.\"
.\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
.\" or visit www.oracle.com if you need additional information or have any
.\" questions.
.\"
.\"     Arch: generic
.\"     Software: JDK 8
.\"     Date: 21 November 2013
.\"     SectDesc: Basic Tools
.\"     Title: java.1
.\"
.if n .pl 99999
.TH java 1 "21 November 2013" "JDK 8" "Basic Tools"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------

.SH NAME    
java \- Launches a Java application\&.
.SH SYNOPSIS    
.sp     
.nf     

\fBjava\fR [\fIoptions\fR] \fIclassname\fR [\fIargs\fR]
.fi     
.nf     

\fBjava\fR [\fIoptions\fR] \fB\-jar\fR \fIfilename\fR [\fIargs\fR]
.fi     
.sp     
.TP     
\fIoptions\fR
Command-line options separated by spaces\&. See Options\&.
.TP     
\fIclassname\fR
The name of the class to be launched\&.
.TP     
\fIfilename\fR
The name of the Java Archive (JAR) file to be called\&. Used only with the \f3-jar\fR option\&.
.TP     
\fIargs\fR
The arguments passed to the \f3main()\fR method separated by spaces\&.
.SH DESCRIPTION    
The \f3java\fR command starts a Java application\&. It does this by starting the Java Runtime Environment (JRE), loading the specified class, and calling that class\&'s \f3main()\fR method\&. The method must be declared \fIpublic\fR and \fIstatic\fR, it must not return any value, and it must accept a \f3String\fR array as a parameter\&. The method declaration has the following form:
.sp     
.nf     
\f3public static void main(String[] args)\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     
The \f3java\fR command can be used to launch a JavaFX application by loading a class that either has a \f3main()\fR method or that extends \f3javafx\&.application\&.Application\fR\&. In the latter case, the launcher constructs an instance of the \f3Application\fR class, calls its \f3init()\fR method, and then calls the \f3start(javafx\&.stage\&.Stage)\fR method\&.
.PP
By default, the first argument that is not an option of the \f3java\fR command is the fully qualified name of the class to be called\&. If the \f3-jar\fR option is specified, its argument is the name of the JAR file containing class and resource files for the application\&. The startup class must be indicated by the \f3Main-Class\fR manifest header in its source code\&.
.PP
The JRE searches for the startup class (and other classes used by the application) in three sets of locations: the bootstrap class path, the installed extensions, and the user\(cqs class path\&.
.PP
Arguments after the class file name or the JAR file name are passed to the \f3main()\fR method\&.
.SH OPTIONS    
The \f3java\fR command supports a wide range of options that can be divided into the following categories:
.TP 0.2i    
\(bu
Standard Options
.TP 0.2i    
\(bu
Non-Standard Options
.TP 0.2i    
\(bu
Advanced Runtime Options
.TP 0.2i    
\(bu
Advanced JIT Compiler Options
.TP 0.2i    
\(bu
Advanced Serviceability Options
.TP 0.2i    
\(bu
Advanced Garbage Collection Options
.PP
Standard options are guaranteed to be supported by all implementations of the Java Virtual Machine (JVM)\&. They are used for common actions, such as checking the version of the JRE, setting the class path, enabling verbose output, and so on\&.
.PP
Non-standard options are general purpose options that are specific to the Java HotSpot Virtual Machine, so they are not guaranteed to be supported by all JVM implementations, and are subject to change\&. These options start with \f3-X\fR\&.
.PP
Advanced options are not recommended for casual use\&. These are developer options used for tuning specific areas of the Java HotSpot Virtual Machine operation that often have specific system requirements and may require privileged access to system configuration parameters\&. They are also not guaranteed to be supported by all JVM implementations, and are subject to change\&. Advanced options start with \f3-XX\fR\&.
.PP
To keep track of the options that were deprecated or removed in the latest release, there is a section named Deprecated and Removed Options at the end of the document\&.
.PP
Boolean options are used to either enable a feature that is disabled by default or disable a feature that is enabled by default\&. Such options do not require a parameter\&. Boolean \f3-XX\fR options are enabled using the plus sign (\f3-XX:+\fR\fIOptionName\fR) and disabled using the minus sign (\f3-XX:-\fR\fIOptionName\fR)\&.
.PP
For options that require an argument, the argument may be separated from the option name by a space, a colon (:), or an equal sign (=), or the argument may directly follow the option (the exact syntax differs for each option)\&. If you are expected to specify the size in bytes, you can use no suffix, or use the suffix \f3k\fR or \f3K\fR for kilobytes (KB), \f3m\fR or \f3M\fR for megabytes (MB), \f3g\fR or \f3G\fR for gigabytes (GB)\&. For example, to set the size to 8 GB, you can specify either \f38g\fR, \f38192m\fR, \f38388608k\fR, or \f38589934592\fR as the argument\&. If you are expected to specify the percentage, use a number from 0 to 1 (for example, specify \f30\&.25\fR for 25%)\&.
.SS STANDARD\ OPTIONS    
These are the most commonly used options that are supported by all implementations of the JVM\&.
.TP
-agentlib:\fIlibname\fR[=\fIoptions\fR]
.br
Loads the specified native agent library\&. After the library name, a comma-separated list of options specific to the library can be used\&.

If the option \f3-agentlib:foo\fR is specified, then the JVM attempts to load the library named \f3libfoo\&.so\fR in the location specified by the \f3LD_LIBRARY_PATH\fR system variable (on OS X this variable is \f3DYLD_LIBRARY_PATH\fR)\&.

The following example shows how to load the heap profiling tool (HPROF) library and get sample CPU information every 20 ms, with a stack depth of 3:
.sp     
.nf     
\f3\-agentlib:hprof=cpu=samples,interval=20,depth=3\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The following example shows how to load the Java Debug Wire Protocol (JDWP) library and listen for the socket connection on port 8000, suspending the JVM before the main class loads:
.sp     
.nf     
\f3\-agentlib:jdwp=transport=dt_socket,server=y,address=8000\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


For more information about the native agent libraries, refer to the following:
.RS     
.TP 0.2i    
\(bu
The \f3java\&.lang\&.instrument\fR package description at http://docs\&.oracle\&.com/javase/8/docs/api/java/lang/instrument/package-summary\&.html
.TP 0.2i    
\(bu
Agent Command Line Options in the JVM Tools Interface guide at http://docs\&.oracle\&.com/javase/8/docs/platform/jvmti/jvmti\&.html#starting
.RE     

.TP
-agentpath:\fIpathname\fR[=\fIoptions\fR]
.br
Loads the native agent library specified by the absolute path name\&. This option is equivalent to \f3-agentlib\fR but uses the full path and file name of the library\&.
.TP
-client
.br
Selects the Java HotSpot Client VM\&. The 64-bit version of the Java SE Development Kit (JDK) currently ignores this option and instead uses the Server JVM\&.

For default JVM selection, see Server-Class Machine Detection at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/vm/server-class\&.html
.TP
-D\fIproperty\fR=\fIvalue\fR
.br
Sets a system property value\&. The \fIproperty\fR variable is a string with no spaces that represents the name of the property\&. The \fIvalue\fR variable is a string that represents the value of the property\&. If \fIvalue\fR is a string with spaces, then enclose it in quotation marks (for example \f3-Dfoo="foo bar"\fR)\&.
.TP
-d32
.br
Runs the application in a 32-bit environment\&. If a 32-bit environment is not installed or is not supported, then an error will be reported\&. By default, the application is run in a 32-bit environment unless a 64-bit system is used\&.
.TP
-d64
.br
Runs the application in a 64-bit environment\&. If a 64-bit environment is not installed or is not supported, then an error will be reported\&. By default, the application is run in a 32-bit environment unless a 64-bit system is used\&.

Currently only the Java HotSpot Server VM supports 64-bit operation, and the \f3-server\fR option is implicit with the use of \f3-d64\fR\&. The \f3-client\fR option is ignored with the use of \f3-d64\fR\&. This is subject to change in a future release\&.
.TP
.nf
-disableassertions[:[\fIpackagename\fR]\&.\&.\&.|:\fIclassname\fR], -da[:[\fIpackagename\fR]\&.\&.\&.|:\fIclassname\fR]
.br
.fi
Disables assertions\&. By default, assertions are disabled in all packages and classes\&.

With no arguments, \f3-disableassertions\fR (\f3-da\fR) disables assertions in all packages and classes\&. With the \fIpackagename\fR argument ending in \f3\&.\&.\&.\fR, the switch disables assertions in the specified package and any subpackages\&. If the argument is simply \f3\&.\&.\&.\fR, then the switch disables assertions in the unnamed package in the current working directory\&. With the \fIclassname\fR argument\f3\fR, the switch disables assertions in the specified class\&.

The \f3-disableassertions\fR (\f3-da\fR) option applies to all class loaders and to system classes (which do not have a class loader)\&. There is one exception to this rule: if the option is provided with no arguments, then it does not apply to system classes\&. This makes it easy to disable assertions in all classes except for system classes\&. The \f3-disablesystemassertions\fR option enables you to disable assertions in all system classes\&.

To explicitly enable assertions in specific packages or classes, use the \f3-enableassertions\fR (\f3-ea\fR) option\&. Both options can be used at the same time\&. For example, to run the \f3MyClass\fR application with assertions enabled in package \f3com\&.wombat\&.fruitbat\fR (and any subpackages) but disabled in class \f3com\&.wombat\&.fruitbat\&.Brickbat\fR, use the following command:
.sp     
.nf     
\f3java \-ea:com\&.wombat\&.fruitbat\&.\&.\&. \-da:com\&.wombat\&.fruitbat\&.Brickbat MyClass\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-disablesystemassertions, -dsa
.br
Disables assertions in all system classes\&.
.TP
.nf
-enableassertions[:[\fIpackagename\fR]\&.\&.\&.|:\fIclassname\fR], -ea[:[\fIpackagename\fR]\&.\&.\&.|:\fIclassname\fR]
.br
.fi
Enables assertions\&. By default, assertions are disabled in all packages and classes\&.

With no arguments, \f3-enableassertions\fR (\f3-ea\fR) enables assertions in all packages and classes\&. With the \fIpackagename\fR argument ending in \f3\&.\&.\&.\fR, the switch enables assertions in the specified package and any subpackages\&. If the argument is simply \f3\&.\&.\&.\fR, then the switch enables assertions in the unnamed package in the current working directory\&. With the \fIclassname\fR argument\f3\fR, the switch enables assertions in the specified class\&.

The \f3-enableassertions\fR (\f3-ea\fR) option applies to all class loaders and to system classes (which do not have a class loader)\&. There is one exception to this rule: if the option is provided with no arguments, then it does not apply to system classes\&. This makes it easy to enable assertions in all classes except for system classes\&. The \f3-enablesystemassertions\fR option provides a separate switch to enable assertions in all system classes\&.

To explicitly disable assertions in specific packages or classes, use the \f3-disableassertions\fR (\f3-da\fR) option\&. If a single command contains multiple instances of these switches, then they are processed in order before loading any classes\&. For example, to run the \f3MyClass\fR application with assertions enabled only in package \f3com\&.wombat\&.fruitbat\fR (and any subpackages) but disabled in class \f3com\&.wombat\&.fruitbat\&.Brickbat\fR, use the following command:
.sp     
.nf     
\f3java \-ea:com\&.wombat\&.fruitbat\&.\&.\&. \-da:com\&.wombat\&.fruitbat\&.Brickbat MyClass\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-enablesystemassertions, -esa
.br
Enables assertions in all system classes\&.
.TP
-help, -?
.br
Displays usage information for the \f3java\fR command without actually running the JVM\&.
.TP
-jar \fIfilename\fR
.br
Executes a program encapsulated in a JAR file\&. The \fIfilename\fR argument is the name of a JAR file with a manifest that contains a line in the form \f3Main-Class:\fR\fIclassname\fR that defines the class with the \f3public static void main(String[] args)\fR method that serves as your application\&'s starting point\&.

When you use the \f3-jar\fR option, the specified JAR file is the source of all user classes, and other class path settings are ignored\&.

For more information about JAR files, see the following resources:
.RS     
.TP 0.2i    
\(bu
jar(1)
.TP 0.2i    
\(bu
The Java Archive (JAR) Files guide at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/jar/index\&.html
.TP 0.2i    
\(bu
Lesson: Packaging Programs in JAR Files at http://docs\&.oracle\&.com/javase/tutorial/deployment/jar/index\&.html
.RE     

.TP
-javaagent:\fIjarpath\fR[=\fIoptions\fR]
.br
Loads the specified Java programming language agent\&. For more information about instrumenting Java applications, see the \f3java\&.lang\&.instrument\fR package description in the Java API documentation at http://docs\&.oracle\&.com/javase/8/docs/api/java/lang/instrument/package-summary\&.html
.TP
-jre-restrict-search
.br
Includes user-private JREs in the version search\&.
.TP
-no-jre-restrict-search
.br
Excludes user-private JREs from the version search\&.
.TP
-server
.br
Selects the Java HotSpot Server VM\&. The 64-bit version of the JDK supports only the Server VM, so in that case the option is implicit\&.

For default JVM selection, see Server-Class Machine Detection at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/vm/server-class\&.html
.TP
-showversion
.br
Displays version information and continues execution of the application\&. This option is equivalent to the \f3-version\fR option except that the latter instructs the JVM to exit after displaying version information\&.
.TP
-splash:\fIimgname\fR
.br
Shows the splash screen with the image specified by \fIimgname\fR\&. For example, to show the \f3splash\&.gif\fR file from the \f3images\fR directory when starting your application, use the following option:
.sp     
.nf     
\f3\-splash:images/splash\&.gif\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-verbose:class
.br
Displays information about each loaded class\&.
.TP
-verbose:gc
.br
Displays information about each garbage collection (GC) event\&.
.TP
-verbose:jni
.br
Displays information about the use of native methods and other Java Native Interface (JNI) activity\&.
.TP
-version
.br
Displays version information and then exits\&. This option is equivalent to the \f3-showversion\fR option except that the latter does not instruct the JVM to exit after displaying version information\&.
.TP
-version:\fIrelease\fR
.br
Specifies the release version to be used for running the application\&. If the version of the \f3java\fR command called does not meet this specification and an appropriate implementation is found on the system, then the appropriate implementation will be used\&.

The \fIrelease\fR argument specifies either the exact version string, or a list of version strings and ranges separated by spaces\&. A \fIversion string\fR is the developer designation of the version number in the following form: \f31\&.\fR\fIx\fR\f3\&.0_\fR\fIu\fR (where \fIx\fR is the major version number, and \fIu\fR is the update version number)\&. A \fIversion range\fR is made up of a version string followed by a plus sign (\f3+\fR) to designate this version or later, or a part of a version string followed by an asterisk (\f3*\fR) to designate any version string with a matching prefix\&. Version strings and ranges can be combined using a space for a logical \fIOR\fR combination, or an ampersand (\f3&\fR) for a logical \fIAND\fR combination of two version strings/ranges\&. For example, if running the class or JAR file requires either JRE 6u13 (1\&.6\&.0_13), or any JRE 6 starting from 6u10 (1\&.6\&.0_10), specify the following:
.sp     
.nf     
\f3\-version:"1\&.6\&.0_13 1\&.6* & 1\&.6\&.0_10+"\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


Quotation marks are necessary only if there are spaces in the \fIrelease\fR parameter\&.

For JAR files, the preference is to specify version requirements in the JAR file manifest rather than on the command line\&.
.SS NON-STANDARD\ OPTIONS    
These options are general purpose options that are specific to the Java HotSpot Virtual Machine\&.
.TP
-X
.br
Displays help for all available \f3-X\fR options\&.
.TP
-Xbatch
.br
Disables background compilation\&. By default, the JVM compiles the method as a background task, running the method in interpreter mode until the background compilation is finished\&. The \f3-Xbatch\fR flag disables background compilation so that compilation of all methods proceeds as a foreground task until completed\&.

This option is equivalent to \f3-XX:-BackgroundCompilation\fR\&.
.TP
-Xbootclasspath:\fIpath\fR
.br
Specifies a list of directories, JAR files, and ZIP archives separated by colons (:) to search for boot class files\&. These are used in place of the boot class files included in the JDK\&.

\fI\fRDo not deploy applications that use this option to override a class in \f3rt\&.jar\fR, because this violates the JRE binary code license\&.
.TP
-Xbootclasspath/a:\fIpath\fR
.br
Specifies a list of directories, JAR files, and ZIP archives separated by colons (:) to append to the end of the default bootstrap class path\&.

Do not deploy applications that use this option to override a class in \f3rt\&.jar\fR, because this violates the JRE binary code license\&.
.TP
-Xbootclasspath/p:\fIpath\fR
.br
Specifies a list of directories, JAR files, and ZIP archives separated by colons (:) to prepend to the front of the default bootstrap class path\&.

Do not deploy applications that use this option to override a class in \f3rt\&.jar\fR, because this violates the JRE binary code license\&.
.TP
-Xboundthreads
.br
Binds user-level threads to kernel threads\&.
.TP
-Xcheck:jni
.br
Performs additional checks for Java Native Interface (JNI) functions\&. Specifically, it validates the parameters passed to the JNI function and the runtime environment data before processing the JNI request\&. Any invalid data encountered indicates a problem in the native code, and the JVM will terminate with an irrecoverable error in such cases\&. Expect a performance degradation when this option is used\&.
.TP
-Xcomp
.br
Disables interpretation of Java code and compile methods on first invocation\&. By default, the JIT compiler performs 10,000 interpreted method invocations to gather information for efficient compilation\&. To increase compilation performance at the expense of efficiency, use the \f3-Xcomp\fR flag to disable interpreted method invocations\&.

You can also change the number of interpreted method invocations before compilation using the \f3-XX:CompileThreshold\fR option\&.
.TP
-Xdebug
.br
Does nothing\&. Provided for backward compatibility\&.
.TP
-Xdiag
.br
Shows additional diagnostic messages\&.
.TP
-Xfuture
.br
Enables strict class-file format checks that enforce close conformance to the class-file format specification\&. Developers are encouraged to use this flag when developing new code because the stricter checks will become the default in future releases\&.
.TP
-Xincgc
.br
Enables incremental GC\&.
.TP
-Xint
.br
Runs the application in interpreted-only mode\&. Compilation to native code is disabled, and all bytecode is executed by the interpreter\&. The performance benefits offered by the just in time (JIT) compiler are not present in this mode\&.
.TP
-Xinternalversion
.br
Displays more detailed JVM version information than the \f3-version\fR option, and then exits\&.
.TP
-Xloggc:\fIfilename\fR
.br
Sets the file to which verbose GC events information should be redirected for logging\&. The information written to this file is similar to the output of \f3-verbose:gc\fR with the time elapsed since the first GC event preceding each logged event\&. The \f3-Xloggc\fR option overrides \f3-verbose:gc\fR if both are given with the same \f3java\fR command\&.

Example:
.sp     
.nf     
\f3\-Xloggc:garbage\-collection\&.log\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-Xmaxjitcodesize=\fIsize\fR
.br
Specifies the maximum code cache size (in bytes) for JIT-compiled code\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the value is set to 48 MB:
.sp     
.nf     
\f3\-Xmaxjitcodesize=48m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


This option is equivalent to \f3-XX:ReservedCodeCacheSize\fR\&.
.TP
-Xmixed
.br
Executes all bytecode by the interpreter except for hot methods, which are compiled to native code\&.
.TP
-Xmn\fIsize\fR
.br
Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&.

The young generation region of the heap is used for new objects\&. GC is performed in this region more often than in other regions\&. If the size for the young generation is too small, then a lot of minor garbage collections will be performed\&. If the size is too large, then only full garbage collections will be performed, which can take a long time to complete\&. Oracle recommends that you keep the size for the young generation between a half and a quarter of the overall heap size\&.

The following examples show how to set the initial and maximum size of young generation to 256 MB using various units:
.sp     
.nf     
\f3\-Xmn256m\fP
.fi     
.nf     
\f3\-Xmn262144k\fP
.fi     
.nf     
\f3\-Xmn268435456\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


Instead of the \f3-Xmn\fR option to set both the initial and maximum size of the heap for the young generation, you can use \f3-XX:NewSize\fR to set the initial size and \f3-XX:MaxNewSize\fR to set the maximum size\&.
.TP
-Xms\fIsize\fR
.br
Sets the initial size (in bytes) of the heap\&. This value must be a multiple of 1024 and greater than 1 MB\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&.

The following examples show how to set the size of allocated memory to 6 MB using various units:
.sp     
.nf     
\f3\-Xms6291456\fP
.fi     
.nf     
\f3\-Xms6144k\fP
.fi     
.nf     
\f3\-Xms6m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


If you do not set this option, then the initial size will be set as the sum of the sizes allocated for the old generation and the young generation\&. The initial size of the heap for the young generation can be set using the \f3-Xmn\fR option or the \f3-XX:NewSize\fR option\&.
.TP
-Xmx\fIsize\fR
.br
Specifies the maximum size (in bytes) of the memory allocation pool in bytes\&. This value must be a multiple of 1024 and greater than 2 MB\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value is chosen at runtime based on system configuration\&. For server deployments, \f3-Xms\fR and \f3-Xmx\fR are often set to the same value\&. For more information, see Garbage Collector Ergonomics at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/vm/gc-ergonomics\&.html

The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units:
.sp     
.nf     
\f3\-Xmx83886080\fP
.fi     
.nf     
\f3\-Xmx81920k\fP
.fi     
.nf     
\f3\-Xmx80m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The \f3-Xmx\fR option is equivalent to \f3-XX:MaxHeapSize\fR\&.
.TP
-Xnoclassgc
.br
Disables garbage collection (GC) of classes\&. This can save some GC time, which shortens interruptions during the application run\&.

When you specify \f3-Xnoclassgc\fR at startup, the class objects in the application will be left untouched during GC and will always be considered live\&. This can result in more memory being permanently occupied which, if not used carefully, will throw an out of memory exception\&.
.TP
-Xprof
.br
Profiles the running program and sends profiling data to standard output\&. This option is provided as a utility that is useful in program development and is not intended to be used in production systems\&.
.TP
-Xrs
.br
Reduces the use of operating system signals by the JVM\&.

Shutdown hooks enable orderly shutdown of a Java application by running user cleanup code (such as closing database connections) at shutdown, even if the JVM terminates abruptly\&.

The JVM catches signals to implement shutdown hooks for unexpected termination\&. The JVM uses \f3SIGHUP\fR, \f3SIGINT\fR, and \f3SIGTERM\fR to initiate the running of shutdown hooks\&.

The JVM uses a similar mechanism to implement the feature of dumping thread stacks for debugging purposes\&. The JVM uses \f3SIGQUIT\fR to perform thread dumps\&.

Applications embedding the JVM frequently need to trap signals such as \f3SIGINT\fR or \f3SIGTERM\fR, which can lead to interference with the JVM signal handlers\&. The \f3-Xrs\fR option is available to address this issue\&. When \f3-Xrs\fR is used, the signal masks for \f3SIGINT\fR, \f3SIGTERM\fR, \f3SIGHUP\fR, and \f3SIGQUIT\fR are not changed by the JVM, and signal handlers for these signals are not installed\&.

There are two consequences of specifying \f3-Xrs\fR:
.RS     
.TP 0.2i    
\(bu
\f3SIGQUIT\fR thread dumps are not available\&.
.TP 0.2i    
\(bu
User code is responsible for causing shutdown hooks to run, for example, by calling \f3System\&.exit()\fR when the JVM is to be terminated\&.
.RE     

.TP
-Xshare:\fImode\fR
.br
Sets the class data sharing mode\&. Possible \fImode\fR arguments for this option include the following:
.RS     
.TP     
auto
Use shared class data if possible\&. This is the default value for Java HotSpot 32-Bit Client VM\&.
.TP     
on
Require the use of class data sharing\&. Print an error message and exit if class data sharing cannot be used\&.
.TP     
off
Do not use shared class data\&. This is the default value for Java HotSpot 32-Bit Server VM, Java HotSpot 64-Bit Client VM, and Java HotSpot 64-Bit Server VM\&.
.TP     
dump
Manually generate the class data sharing archive\&.
.RE     

.TP
-XshowSettings:\fIcategory\fR
.br
Shows settings and continues\&. Possible \fIcategory\fR arguments for this option include the following:
.RS     
.TP     
all
Shows all categories of settings\&. This is the default value\&.
.TP     
locale
Shows settings related to locale\&.
.TP     
properties
Shows settings related to system properties\&.
.TP     
vm
Shows the settings of the JVM\&.
.RE     

.TP
-Xss\fIsize\fR
.br
Sets the thread stack size (in bytes)\&. Append the letter \f3k\fR or \f3K\fR to indicate KB, \f3m\fR or \f3M\fR to indicate MB, \f3g\fR or \f3G\fR to indicate GB\&. The default value depends on the platform:
.RS     
.TP 0.2i    
\(bu
Linux/ARM (32-bit): 320 KB
.TP 0.2i    
\(bu
Linux/i386 (32-bit): 320 KB
.TP 0.2i    
\(bu
Linux/x64 (64-bit): 1024 KB
.TP 0.2i    
\(bu
OS X (64-bit): 1024 KB
.TP 0.2i    
\(bu
Oracle Solaris/i386 (32-bit): 320 KB
.TP 0.2i    
\(bu
Oracle Solaris/x64 (64-bit): 1024 KB
.TP 0.2i    
\(bu
Windows: depends on virtual memory
.RE
.RS
The following examples set the thread stack size to 1024 KB in different units:
.sp     
.nf     
\f3\-Xss1m\fP
.fi     
.nf     
\f3\-Xss1024k\fP
.fi     
.nf     
\f3\-Xss1048576\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


This option is equivalent to \f3-XX:ThreadStackSize\fR\&.

.RE
.TP
-Xusealtsigs
.br
Use alternative signals instead of \f3SIGUSR1\fR and \f3SIGUSR2\fR for JVM internal signals\&. This option is equivalent to \f3-XX:+UseAltSigs\fR\&.
.TP
-Xverify:\fImode\fR
.br
Sets the mode of the bytecode verifier\&. Bytecode verification helps to troubleshoot some problems, but it also adds overhead to the running application\&. Possible \fImode\fR arguments for this option include the following:
.RS     
.TP     
none
Do not verify the bytecode\&. This reduces startup time and also reduces the protection provided by Java\&.
.TP     
remote
Verify only those classes that are loaded remotely over the network\&. This is the default behavior if you do not specify the \f3-Xverify\fR option\&.
.TP     
all
Verify all classes\&.
.RE     

.SS ADVANCED\ RUNTIME\ OPTIONS    
These options control the runtime behavior of the Java HotSpot VM\&.
.TP
-XX:+DisableAttachMechanism
.br
Enables the option that disables the mechanism that lets tools attach to the JVM\&. By default, this option is disabled, meaning that the attach mechanism is enabled and you can use tools such as \f3jcmd\fR, \f3jstack\fR, \f3jmap\fR, and \f3jinfo\fR\&.
.TP
-XX:ErrorFile=\fIfilename\fR
.br
Specifies the path and file name to which error data is written when an irrecoverable error occurs\&. By default, this file is created in the current working directory and named \f3hs_err_pid\fR\fIpid\fR\f3\&.log\fR where \fIpid\fR is the identifier of the process that caused the error\&. The following example shows how to set the default log file (note that the identifier of the process is specified as \f3%p\fR):
.sp     
.nf     
\f3\-XX:ErrorFile=\&./hs_err_pid%p\&.log\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The following example shows how to set the error log to \f3/var/log/java/java_error\&.log\fR:
.sp     
.nf     
\f3\-XX:ErrorFile=/var/log/java/java_error\&.log\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


If the file cannot be created in the specified directory (due to insufficient space, permission problem, or another issue), then the file is created in the temporary directory for the operating system\&. The temporary directory is \f3/tmp\fR\&.
.TP
-XX:LargePageSizeInBytes=\fIsize\fR
.br
Sets the maximum size (in bytes) for large pages used for Java heap\&. The \fIsize\fR argument must be a power of 2 (2, 4, 8, 16, \&.\&.\&.)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the size is set to 0, meaning that the JVM chooses the size for large pages automatically\&.

The following example illustrates how to set the large page size to 4 megabytes (MB):
.sp     
.nf     
\f3\-XX:LargePageSizeInBytes=4m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxDirectMemorySize=\fIsize\fR
.br
Sets the maximum total size (in bytes) of the New I/O (the \f3java\&.nio\fR package) direct-buffer allocations\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the size is set to 0, meaning that the JVM chooses the size for NIO direct-buffer allocations automatically\&.

The following examples illustrate how to set the NIO size to 1024 KB in different units:
.sp     
.nf     
\f3\-XX:MaxDirectMemorySize=1m\fP
.fi     
.nf     
\f3\-XX:MaxDirectMemorySize=1024k\fP
.fi     
.nf     
\f3\-XX:MaxDirectMemorySize=1048576\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:NativeMemoryTracking=\fImode\fR
.br
Specifies the mode for tracking JVM native memory usage\&. Possible \fImode\fR arguments for this option include the following:
.RS     
.TP     
off
Do not track JVM native memory usage\&. This is the default behavior if you do not specify the \f3-XX:NativeMemoryTracking\fR option\&.
.TP     
summary
Only track memory usage by JVM subsystems, such as Java heap, class, code, and thread\&.
.TP     
detail
In addition to tracking memory usage by JVM subsystems, track memory usage by individual \f3CallSite\fR, individual virtual memory region and its committed regions\&.
.RE     

.TP
-XX:OnError=\fIstring\fR
.br
Sets a custom command or a series of semicolon-separated commands to run when an irrecoverable error occurs\&. If the string contains spaces, then it must be enclosed in quotation marks\&.

\fI\fRThe following example shows how the \f3-XX:OnError\fR option can be used to run the \f3gcore\fR command to create the core image, and the debugger is started to attach to the process in case of an irrecoverable error (the \f3%p\fR designates the current process):
.sp     
.nf     
\f3\-XX:OnError="gcore %p;dbx \- %p"\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:OnOutOfMemoryError=\fIstring\fR
.br
Sets a custom command or a series of semicolon-separated commands to run when an \f3OutOfMemoryError\fR exception is first thrown\&. If the string contains spaces, then it must be enclosed in quotation marks\&. For an example of a command string, see the description of the \f3-XX:OnError\fR option\&.
.TP
-XX:+PrintCommandLineFlags
.br
Enables printing of ergonomically selected JVM flags that appeared on the command line\&. It can be useful to know the ergonomic values set by the JVM, such as the heap space size and the selected garbage collector\&. By default, this option is disabled and flags are not printed\&.
.TP
-XX:+PrintNMTStatistics
.br
Enables printing of collected native memory tracking data at JVM exit when native memory tracking is enabled (see \f3-XX:NativeMemoryTracking\fR)\&. By default, this option is disabled and native memory tracking data is not printed\&.
.TP
-XX:+ShowMessageBoxOnError
.br
Enables displaying of a dialog box when the JVM experiences an irrecoverable error\&. This prevents the JVM from exiting and keeps the process active so that you can attach a debugger to it to investigate the cause of the error\&. By default, this option is disabled\&.
.TP
-XX:ThreadStackSize=\fIsize\fR
.br
Sets the thread stack size (in bytes)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value depends on the platform:
.RS     
.TP 0.2i    
\(bu
Linux/ARM (32-bit): 320 KB
.TP 0.2i    
\(bu
Linux/i386 (32-bit): 320 KB
.TP 0.2i    
\(bu
Linux/x64 (64-bit): 1024 KB
.TP 0.2i    
\(bu
OS X (64-bit): 1024 KB
.TP 0.2i    
\(bu
Oracle Solaris/i386 (32-bit): 320 KB
.TP 0.2i    
\(bu
Oracle Solaris/x64 (64-bit): 1024 KB
.TP 0.2i    
\(bu
Windows: depends on virtual memory
.RE
.RS
The following examples show how to set the thread stack size to 1024 KB in different units:
.sp     
.nf     
\f3\-XX:ThreadStackSize=1m\fP
.fi     
.nf     
\f3\-XX:ThreadStackSize=1024k\fP
.fi     
.nf     
\f3\-XX:ThreadStackSize=1048576\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


This option is equivalent to \f3-Xss\fR\&.

.RE
.TP
-XX:+TraceClassLoading
.br
Enables tracing of classes as they are loaded\&. By default, this option is disabled and classes are not traced\&.
.TP
-XX:+TraceClassLoadingPreorder
.br
Enables tracing of all loaded classes in the order in which they are referenced\&. By default, this option is disabled and classes are not traced\&.
.TP
-XX:+TraceClassResolution
.br
Enables tracing of constant pool resolutions\&. By default, this option is disabled and constant pool resolutions are not traced\&.
.TP
-XX:+TraceClassUnloading
.br
Enables tracing of classes as they are unloaded\&. By default, this option is disabled and classes are not traced\&.
.TP
-XX:+TraceLoaderConstraints
.br
Enables tracing of the loader constraints recording\&. By default, this option is disabled and loader constraints recoding is not traced\&.
.TP
-XX:+UseAltSigs
.br
Enables the use of alternative signals instead of \f3SIGUSR1\fR and \f3SIGUSR2\fR for JVM internal signals\&. By default, this option is disabled and alternative signals are not used\&. This option is equivalent to \f3-Xusealtsigs\fR\&.
.TP
-XX:+UseBiasedLocking
.br
Enables the use of biased locking\&. Some applications with significant amounts of uncontended synchronization may attain significant speedups with this flag enabled, whereas applications with certain patterns of locking may see slowdowns\&. For more information about the biased locking technique, see the example in Java Tuning White Paper at http://www\&.oracle\&.com/technetwork/java/tuning-139912\&.html#section4\&.2\&.5

By default, this option is disabled and biased locking is not used\&.
.TP
-XX:+UseCompressedOops
.br
Enables the use of compressed pointers\&. When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB\&. This option works only for 64-bit JVMs\&.

By default, this option is disabled and compressed pointers are not used\&.
.TP
-XX:+UseLargePages
.br
Enables the use of large page memory\&. This option is enabled by default\&. To disable the use of large page memory, specify \f3-XX:-UseLargePages\fR\&.

For more information, see Java Support for Large Memory Pages at http://www\&.oracle\&.com/technetwork/java/javase/tech/largememory-jsp-137182\&.html
.TP
-XX:+UseMembar
.br
Enables issuing of membars on thread state transitions\&. This option is disabled by default on all platforms except Power PC and ARM servers, where it is enabled\&. To disable issuing of membars on thread state transitions for Power PC and ARM, specify \f3-XX:-UseMembar\fR\&.
.TP
-XX:+UsePerfData
.br
Enables the \f3perfdata\fR feature\&. This option is enabled by default to allow JVM monitoring and performance testing\&. Disabling it suppresses the creation of the \f3hsperfdata_userid\fR directories\&. To disable the \f3perfdata\fR feature, specify \f3-XX:-UsePerfData\fR\&.
.TP
-XX:+AllowUserSignalHandlers
.br
Enables installation of signal handlers by the application\&. By default, this option is disabled and the application is not allowed to install signal handlers\&.
.SS ADVANCED\ JIT\ COMPILER\ OPTIONS    
These options control the dynamic just-in-time (JIT) compilation performed by the Java HotSpot VM\&.
.TP
-XX:+AggressiveOpts
.br
Enables the use of aggressive performance optimization features, which are expected to become default in upcoming releases\&. By default, this option is disabled and experimental performance features are not used\&.
.TP
-XX:AllocateInstancePrefetchLines=\fIlines\fR
.br
Sets the number of lines to prefetch ahead of the instance allocation pointer\&. By default, the number of lines to prefetch is set to 1:
.sp     
.nf     
\f3\-XX:AllocateInstancePrefetchLines=1\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:AllocatePrefetchInstr=\fIinstruction\fR
.br
Sets the prefetch instruction to prefetch ahead of the allocation pointer\&. Possible values are from 0 to 3\&. The actual instructions behind the values depend on the platform\&. By default, the prefetch instruction is set to 0:
.sp     
.nf     
\f3\-XX:AllocatePrefetchInstr=0\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:AllocatePrefetchStepSize=\fIsize\fR
.br
Sets the step size (in bytes) for sequential prefetch instructions\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the step size is set to 16 bytes:
.sp     
.nf     
\f3\-XX:AllocatePrefetchStepSize=16\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+BackgroundCompilation
.br
Enables background compilation\&. This option is enabled by default\&. To disable background compilation, specify \f3-XX:-BackgroundCompilation\fR (this is equivalent to specifying \f3-Xbatch\fR)\&.
.TP
-XX:CICompilerCount=\fIthreads\fR
.br
Sets the number of compiler threads to use for compilation\&. By default, the number of threads is set to 2 for the server JVM, to 1 for the client JVM, and it scales to the number of cores if tiered compilation is used\&. The following example shows how to set the number of threads to 2:
.sp     
.nf     
\f3\-XX:CICompilerCount=2\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:CodeCacheMinimumFreeSpace=\fIsize\fR
.br
Sets the minimum free space (in bytes) required for compilation\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. When less than the minimum free space remains, compiling stops\&. By default, this option is set to 500 KB\&. The following example shows how to set the minimum free space to 1024 MB:
.sp     
.nf     
\f3\-XX:CodeCacheMinimumFreeSpace=1024m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
.nf
-XX:CompileCommand=\fIcommand\fR,\fIclass\fR\&.\fImethod\fR[,\fIoption\fR]
.br
.fi
Attaches a line to the \f3\&.hotspot_compiler\fR file with the command for the specific method of the class\&. For example, to exclude the \f3indexOf()\fR method of the \f3String\fR class from being compiled, use the following:
.sp     
.nf     
\f3\-XX:CompileCommand=exclude,java/lang/String\&.indexOf\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


Note that you must specify the full class name, including all packages and subpackages separated by a slash (\f3/\fR)\&.

To add several commands, either specify this option multiple times, or separate each argument with the newline separator (\f3\en\fR)\&. To better understand the syntax of the JVM compiler commands, refer to the description of the \f3-XX:CompileCommandFile\fR option, which enables you to specify the file from which to read compiler commands\&. Notice how the syntax of the command file differs rom the syntax of the argument for the \f3-XX:CompileCommand\fR option\&. The commas and periods in the argument are aliases for spaces in the command file, making it easier to pass compiler commands through a shell\&. To pass arguments to \f3-XX:CompileCommand\fR with the same syntax as that used in the command file, you can enclose the argument in quotation marks:
.sp     
.nf     
\f3\-XX:CompileCommand="exclude java/lang/String indexOf"\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


For easier cut and paste operations, it is also possible to use the method name format produced by the \f3-XX:+PrintCompilation\fR and \f3-XX:+LogCompilation\fR options:
.sp     
.nf     
\f3\-XX:CompileCommand="exclude java\&.lang\&.String::indexOf"\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The following commands are available:
.RS     
.TP     
break
Set a breakpoint when debugging the JVM to stop at the beginning of compilation of the specified method\&.
.TP     
compileonly
Exclude all methods from compilation except for the specified method\&.
.TP     
dontinline
Prevent inlining of the specified method\&.
.TP     
exclude
Exclude the specified method from compilation\&.
.TP     
help
Print a help message for the \f3-XX:CompileCommand\fR option\&.
.TP     
inline
Attempt to inline the specified method\&.
.TP     
log
Exclude compilation logging (with the \f3-XX:+LogCompilation\fR option) for all methods except for the specified method\&. By default, logging is performed for all compiled methods\&.
.TP     
print
Print generated assembler code after compilation of the specified method\&.
.TP     
quiet
Do not print the compile commands\&. By default, the commands that you specify with the -\f3XX:CompileCommand\fR option are printed; for example, if you exclude from compilation the \f3indexOf()\fR method of the \f3String\fR class, then the following will be printed to standard output:
.sp     
.nf     
\f3CompilerOracle: exclude java/lang/String\&.indexOf\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


You can suppress this by specifying the \f3-XX:CompileCommand=quiet\fR option before other \f3-XX:CompileCommand\fR options\&.
.RE     


.RS
The optional last argument (\fIoption\fR) can be used to pass a JIT compilation option to the specified method\&. The compilation option is set at the end, after the method name\&. For example, to enable the \f3BlockLayoutByFrequency\fR option for the \f3append()\fR method of the \f3StringBuffer\fR class, use the following:
.sp     
.nf     
\f3\-XX:CompileCommand=option,java/lang/StringBuffer\&.append,BlockLayoutByFrequency\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


.RE
.TP
-XX:CompileCommandFile=\fIfilename\fR
.br
Sets the file from which compiler commands are read\&. By default, the \f3\&.hotspot_compiler\fR file is used to store commands performed by the JVM compiler\&.

Each line in the command file represents a command, a class name, and a method name for which the command is used (all three parts are separated by spaces)\&. For example, this line prints assembly code for the \f3toString()\fR method of the \f3String\fR class:
.sp     
.nf     
\f3print java/lang/String toString\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


To add commands to the beginning of the \f3\&.hotspot_compiler\fR file, use the \f3-XX:CompileCommand\fR option\&. Note how the syntax of the command file is different from the syntax of the argument for the \f3-XX:CompileCommand\fR option\&. The commas and periods in the argument are aliases for spaces in the command file, making it easier to pass compiler commands through a shell\&. Although it is possible to pass arguments to \f3-XX:CompileCommand\fR with the same syntax as that used in the command file, you would have to enclose the string argument in quotation marks\&.
.TP
-XX:CompileOnly=\fImethods\fR
.br
Sets the list of methods (separated by commas) to which compilation should be restricted\&. Only the specified methods will be compiled\&. Specify each method with the full class name (including the packages and subpackages)\&. For example, to compile only the \f3length()\fR method of the \f3String\fR class and the \f3size()\fR method of the \f3List\fR class, use the following:
.sp     
.nf     
\f3\-XX:CompileOnly=java/lang/String\&.length,java/util/List\&.size\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:CompileThreshold=\fIinvocations\fR
.br
Sets the number of interpreted method invocations before compilation\&. By default, in the server JVM, the JIT compiler performs 10,000 interpreted method invocations to gather information for efficient compilation\&. For the client JVM, the default setting is 1,500 invocations\&. The following example shows how to set the number of interpreted method invocations to 5,000:
.sp     
.nf     
\f3\-XX:CompileThreshold=5000\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


You can completely disable interpretation of Java methods before compilation by specifying the \f3-Xcomp\fR option\&.
.TP
-XX:+DoEscapeAnalysis
.br
Enables the use of escape analysis\&. This option is enabled by default\&. To disable the use of escape analysis, specify \f3-XX:-DoEscapeAnalysis\fR\&.
.TP
-XX:+FailOverToOldVerifier
.br
Enables automatic failover to the old verifier when the new type checker fails\&. By default, this option is disabled and it is ignored (that is, treated as disabled) for classes with a recent bytecode version\&. You can enable it for classes with older versions of the bytecode\&.
.TP
-XX:InitialCodeCacheSize=\fIsize\fR
.br
Sets the initial code cache size (in bytes)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value is set to 500 KB\&. The following example shows how to set the initial code cache size to 32 KB:
.sp     
.nf     
\f3\-XX:InitialCodeCacheSize=32k\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+Inline
.br
Enables method inlining\&. This option is enabled by default to increase performance\&. To disable method inlining, specify \f3-XX:-Inline\fR\&.
.TP
-XX:InlineSmallCode=\fIsize\fR
.br
Sets the maximum code size (in bytes) for compiled methods that should be inlined\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. Only compiled methods with the size smaller than the specified size will be inlined\&. By default, the maximum code size is set to 1000 bytes:
.sp     
.nf     
\f3\-XX:InlineSmallCode=1000\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+LogCompilation
.br
Enables logging of compilation activity to a file named \f3hotspot\&.log\fR in the current working directory\&. You can specify a different log file path and name using the \f3-XX:LogFile\fR option\&.

By default, this option is disabled and compilation activity is not logged\&. The \f3-XX:+LogCompilation\fR option has to be used together with the \f3-XX:UnlockDiagnosticVMOptions\fR option that unlocks diagnostic JVM options\&.

You can enable verbose diagnostic output with a message printed to the console every time a method is compiled by using the \f3-XX:+PrintCompilation\fR option\&.
.TP
-XX:MaxInlineSize=\fIsize\fR
.br
Sets the maximum bytecode size (in bytes) of a method to be inlined\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the maximum bytecode size is set to 35 bytes:
.sp     
.nf     
\f3\-XX:MaxInlineSize=35\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxNodeLimit=\fInodes\fR
.br
Sets the maximum number of nodes to be used during single method compilation\&. By default, the maximum number of nodes is set to 65,000:
.sp     
.nf     
\f3\-XX:MaxNodeLimit=65000\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxTrivialSize=\fIsize\fR
.br
Sets the maximum bytecode size (in bytes) of a trivial method to be inlined\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. By default, the maximum bytecode size of a trivial method is set to 6 bytes:
.sp     
.nf     
\f3\-XX:MaxTrivialSize=6\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+OptimizeStringConcat
.br
Enables the optimization of \f3String\fR concatenation operations\&. This option is enabled by default\&. To disable the optimization of \f3String\fR concatenation operations, specify \f3-XX:-OptimizeStringConcat\fR\&.
.TP
-XX:+PrintAssembly
.br
Enables printing of assembly code for bytecoded and native methods by using the external \f3disassembler\&.so\fR library\&. This enables you to see the generated code, which may help you to diagnose performance issues\&.

By default, this option is disabled and assembly code is not printed\&. The \f3-XX:+PrintAssembly\fR option has to be used together with the \f3-XX:UnlockDiagnosticVMOptions\fR option that unlocks diagnostic JVM options\&.
.TP
-XX:+PrintCompilation
.br
Enables verbose diagnostic output from the JVM by printing a message to the console every time a method is compiled\&. This enables you to see which methods actually get compiled\&. By default, this option is disabled and diagnostic output is not printed\&.

You can also log compilation activity to a file by using the \f3-XX:+LogCompilation\fR option\&.
.TP
-XX:+PrintInlining
.br
Enables printing of inlining decisions\&. This enables you to see which methods are getting inlined\&.

By default, this option is disabled and inlining information is not printed\&. The \f3-XX:+PrintInlining\fR option has to be used together with the \f3-XX:+UnlockDiagnosticVMOptions\fR option that unlocks diagnostic JVM options\&.
.TP
-XX:+RelaxAccessControlCheck
.br
Decreases the amount of access control checks in the verifier\&. By default, this option is disabled, and it is ignored (that is, treated as disabled) for classes with a recent bytecode version\&. You can enable it for classes with older versions of the bytecode\&.
.TP
-XX:ReservedCodeCacheSize=\fIsize\fR
.br
Sets the maximum code cache size (in bytes) for JIT-compiled code\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. This option is equivalent to \f3-Xmaxjitcodesize\fR\&.
.TP
-XX:+TieredCompilation
.br
Enables the use of tiered compilation\&. By default, this option is disabled and tiered compilation is not used\&.
.TP
-XX:+UseCodeCacheFlushing
.br
Enables flushing of the code cache before shutting down the compiler\&. This option is enabled by default\&. To disable flushing of the code cache before shutting down the compiler, specify \f3-XX:-UseCodeCacheFlushing\fR\&.
.TP
-XX:+UseCondCardMark
.br
Enables checking of whether the card is already marked before updating the card table\&. This option is disabled by default and should only be used on machines with multiple sockets, where it will increase performance of Java applications that rely heavily on concurrent operations\&.
.TP
-XX:+UseSuperWord
.br
Enables the transformation of scalar operations into superword operations\&. This option is enabled by default\&. To disable the transformation of scalar operations into superword operations, specify \f3-XX:-UseSuperWord\fR\&.
.SS ADVANCED\ SERVICEABILITY\ OPTIONS    
These options provide the ability to gather system information and perform extensive debugging\&.
.TP
-XX:+ExtendedDTraceProbes
.br
Enables additional \f3dtrace\fR tool probes that impact the performance\&. By default, this option is disabled and \f3dtrace\fR performs only standard probes\&.
.TP
-XX:+HeapDumpOnOutOfMemory
.br
Enables the dumping of the Java heap to a file in the current directory by using the heap profiler (HPROF) when a \f3java\&.lang\&.OutOfMemoryError\fR exception is thrown\&. You can explicitly set the heap dump file path and name using the \f3-XX:HeapDumpPath\fR option\&. By default, this option is disabled and the heap is not dumped when an \f3OutOfMemoryError\fR exception is thrown\&.
.TP
-XX:HeapDumpPath=\fIpath\fR
.br
Sets the path and file name for writing the heap dump provided by the heap profiler (HPROF) when the \f3-XX:+HeapDumpOnOutOfMemoryError\fR option is set\&. By default, the file is created in the current working directory, and it is named \f3java_pid\fR\fIpid\fR\f3\&.hprof\fR where \fIpid\fR is the identifier of the process that caused the error\&. The following example shows how to set the default file explicitly (\f3%p\fR represents the current process identificator):
.sp     
.nf     
\f3\-XX:HeapDumpPath=\&./java_pid%p\&.hprof\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


\fI\fRThe following example shows how to set the heap dump file to \f3/var/log/java/java_heapdump\&.hprof\fR:
.sp     
.nf     
\f3\-XX:HeapDumpPath=/var/log/java/java_heapdump\&.hprof\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:LogFile=\fIpath\fR
.br
Sets the path and file name where log data is written\&. By default, the file is created in the current working directory, and it is named \f3hotspot\&.log\fR\&.

\fI\fRThe following example shows how to set the log file to \f3/var/log/java/hotspot\&.log\fR:
.sp     
.nf     
\f3\-XX:LogFile=/var/log/java/hotspot\&.log\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+PrintClassHistogram
.br
\fI\fREnables printing of a class instance histogram after a \f3Control+C\fR event (\f3SIGTERM\fR)\&. By default, this option is disabled\&.

Setting this option is equivalent to running the \f3jmap -histo\fR command, or the \f3jcmd\fR\fIpid\fR\f3GC\&.class_histogram\fR command, where \fIpid\fR is the current Java process identifier\&.
.TP     
-XX:+PrintConcurrentLocks


Enables printing of j\f3ava\&.util\&.concurrent\fR locks after a \f3Control+C\fR event (\f3SIGTERM\fR)\&. By default, this option is disabled\&.

Setting this option is equivalent to running the \f3jstack -l\fR command or the \f3jcmd\fR\fIpid\fR\f3Thread\&.print -l\fR command, where \fIpid\fR is the current Java process identifier\&.
.TP
-XX:+UnlockDiagnosticVMOptions
.br
Unlocks the options intended for diagnosing the JVM\&. By default, this option is disabled and diagnostic options are not available\&.
.SS ADVANCED\ GARBAGE\ COLLECTION\ OPTIONS    
These options control how garbage collection (GC) is performed by the Java HotSpot VM\&.
.TP
-XX:+AggressiveHeap
.br
Enables Java heap optimization\&. This sets various parameters to be optimal for long-running jobs with intensive memory allocation, based on the configuration of the computer (RAM and CPU)\&. By default, the option is disabled and the heap is not optimized\&.
.TP
-XX:AllocatePrefetchDistance=\fIsize\fR
.br
Sets the size (in bytes) of the prefetch distance for object allocation\&. Memory about to be written with the value of new objects is prefetched up to this distance starting from the address of the last allocated object\&. Each Java thread has its own allocation point\&.

Negative values denote that prefetch distance is chosen based on the platform\&. Positive values are bytes to prefetch\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value is set to -1\&.

The following example shows how to set the prefetch distance to 1024 bytes:
.sp     
.nf     
\f3\-XX:AllocatePrefetchDistance=1024\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:AllocatePrefetchLines=\fIlines\fR
.br
Sets the number of cache lines to load after the last object allocation by using the prefetch instructions generated in compiled code\&. The default value is 1 if the last allocated object was an instance, and 3 if it was an array\&.

The following example shows how to set the number of loaded cache lines to 5:
.sp     
.nf     
\f3\-XX:AllocatePrefetchLines=5\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:AllocatePrefetchStyle=\fIstyle\fR
.br
Sets the generated code style for prefetch instructions\&. The \fIstyle\fR argument is an integer from 0 to 3:
.RS     
.TP     
0
Do not generate prefetch instructions\&.
.TP     
1
Execute prefetch instructions after each allocation\&. This is the default parameter\&.
.TP     
2
Use the thread-local allocation block (TLAB) watermark pointer to determine when prefetch instructions are executed\&.
.TP     
3
Use BIS instruction on SPARC for allocation prefetch\&.
.RE     

.TP
-XX:+AlwaysPreTouch
.br
Enables touching of every page on the Java heap during JVM initialization\&. This gets all pages into the memory before entering the \f3main()\fR method\&. The option can be used in testing to simulate a long-running system with all virtual memory mapped to physical memory\&. By default, this option is disabled and all pages are committed as JVM heap space fills\&.
.TP
-XX:+CMSClassUnloadingEnabled
.br
Enables class unloading when using the concurrent mark-sweep (CMS) garbage collector\&. This option is enabled by default\&. To disable class unloading for the CMS garbage collector, specify \f3-XX:-CMSClassUnloadingEnabled\fR\&.
.TP
-XX:CMSExpAvgFactor=\fIpercent\fR
.br
Sets the percentage of time (0 to 100) used to weight the current sample when computing exponential averages for the concurrent collection statistics\&. By default, the exponential averages factor is set to 25%\&. The following example shows how to set the factor to 15%:
.sp     
.nf     
\f3\-XX:CMSExpAvgFactor=15\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:CMSIncrementalDutyCycle=\fIpercent\fR
.br
Sets the percentage of time (0 to 100) between minor collections that the concurrent collector is allowed to run\&. When \f3-XX:+CMSIncrementalPacing\fR is enabled, the duty cycle is set automatically, and this option sets only the initial value\&.

By default, the duty cycle is set to 10%\&. The following example shows how to set the duty cycle to 20%:
.sp     
.nf     
\f3\-XX:CMSIncrementalDutyCycle=20\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:CMSIncrementalDutyCycleMin=\fIpercent\fR
.br
Sets the percentage of time (0 to 100) between minor collections that is the lower bound for the duty cycle when \f3-XX:+CMSIncrementalPacing\fR is enabled\&. By default, the lower bound for the duty cycle is set to 0%\&. The following example shows how to set the lower bound to 10%:
.sp     
.nf     
\f3\-XX:CMSIncrementalDutyCycleMin=10\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+CMSIncrementalMode
.br
Enables the incremental mode for the CMS collector\&. This option is disabled by default and should only be enabled for configurations with no more than two GC threads\&. All options that start with \f3CMSIncremental\fR apply only when this option is enabled\&.
.TP
-XX:CMSIncrementalOffset=\fIpercent\fR
.br
Sets the percentage of time (0 to 100) by which the incremental mode duty cycle is shifted to the right within the period between minor collections\&. By default, the offset is set to 0%\&. The following example shows how to set the duty cycle offset to 25%:
.sp     
.nf     
\f3\-XX:CMSIncrementalOffset=25\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+CMSIncrementalPacing
.br
Enables automatic adjustment of the incremental mode duty cycle based on statistics collected while the JVM is running\&. This option is enabled by default\&. To disable automatic adjustment of the incremental mode duty cycle, specify \f3-XX:-CMSIncrementalPacing\fR\&.
.TP
-XX:CMSIncrementalSafetyFactor=\fIpercent\fR
.br
Sets the percentage of time (0 to 100) used to add conservatism when computing the duty cycle\&. By default, the safety factor is set to 10%\&. The example below shows how to set the safety factor to 5%:
.sp     
.nf     
\f3\-XX:CMSIncrementalSafetyFactor=5\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:CMSInitiatingOccupancyFraction=\fIpercent\fR
.br
Sets the percentage of the old generation occupancy (0 to 100) at which to start a CMS collection cycle\&. The default value is set to -1\&. Any negative value (including the default) implies that \f3-XX:CMSTriggerRatio\fR is used to define the value of the initiating occupancy fraction\&.

The following example shows how to set the occupancy fraction to 20%:
.sp     
.nf     
\f3\-XX:CMSInitiatingOccupancyFraction=20\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+CMSScavengeBeforeRemark
.br
Enables scavenging attempts before the CMS remark step\&. By default, this option is disabled\&.
.TP
-XX:CMSTriggerRatio=\fIpercent\fR
.br
Sets the percentage (0 to 100) of the value specified by \f3-XX:MinHeapFreeRatio\fR that is allocated before a CMS collection cycle commences\&. The default value is set to 80%\&.

The following example shows how to set the occupancy fraction to 75%:
.sp     
.nf     
\f3\-XX:CMSTriggerRatio=75\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:ConcGCThreads=\fIthreads\fR
.br
Sets the number of threads used for concurrent GC\&. The default value depends on the number of CPUs available to the JVM\&.

For example, to set the number of threads for concurrent GC to 2, specify the following option:
.sp     
.nf     
\f3\-XX:ConcGCThreads=2\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+DisableExplicitGC
.br
Enables the option that disables processing of calls to \f3System\&.gc()\fR\&. This option is disabled by default, meaning that calls to \f3System\&.gc()\fR are processed\&. If processing of calls to \f3System\&.gc()\fR is disabled, the JVM still performs GC when necessary\&.
.TP
-XX:+ExplicitGCInvokesConcurrent
.br
Enables invoking of concurrent GC by using the \f3System\&.gc()\fR request\&. This option is disabled by default and can be enabled only together with the \f3-XX:+UseConcMarkSweepGC\fR option\&.
.TP
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
.br
Enables invoking of concurrent GC by using the \f3System\&.gc()\fR request and unloading of classes during the concurrent GC cycle\&. This option is disabled by default and can be enabled only together with the \f3-XX:+UseConcMarkSweepGC\fR option\&.
.TP
-XX:G1HeapRegionSize=\fIsize\fR
.br
Sets the size of the regions into which the Java heap is subdivided when using the garbage-first (G1) collector\&. The value can be between 1 MB and 32 MB\&. The default region size is determined ergonomically based on the heap size\&.

The following example shows how to set the size of the subdivisions to 16 MB:
.sp     
.nf     
\f3\-XX:G1HeapRegionSize=16m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+G1PrintHeapRegions
.br
Enables the printing of information about which regions are allocated and which are reclaimed by the G1 collector\&. By default, this option is disabled\&.
.TP
-XX:G1ReservePercent=\fIpercent\fR
.br
Sets the percentage of the heap (0 to 50) that is reserved as a false ceiling to reduce the possibility of promotion failure for the G1 collector\&. By default, this option is set to 10%\&.

The following example shows how to set the reserved heap to 20%:
.sp     
.nf     
\f3\-XX:G1ReservePercent=20\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:InitialHeapSize=\fIsize\fR
.br
Sets the initial size (in bytes) of the memory allocation pool\&. This value must be either 0, or a multiple of 1024 and greater than 1 MB\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value is chosen at runtime based on system configuration\&. For more information, see Garbage Collector Ergonomics at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/vm/gc-ergonomics\&.html

The following examples show how to set the size of allocated memory to 6 MB using various units:
.sp     
.nf     
\f3\-XX:InitialHeapSize=6291456\fP
.fi     
.nf     
\f3\-XX:InitialHeapSize=6144k\fP
.fi     
.nf     
\f3\-XX:InitialHeapSize=6m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


If you set this option to 0, then the initial size will be set as the sum of the sizes allocated for the old generation and the young generation\&. The size of the heap for the young generation can be set using the \f3-XX:NewSize\fR option\&.
.TP
-XX:InitialSurvivorRatio=\fIratio\fR
.br
Sets the initial survivor space ratio used by the throughput garbage collector (which is enabled by the \f3-XX:+UseParallelGC\fR and/or -\f3XX:+UseParallelOldGC\fR options)\&. Adaptive sizing is enabled by default with the throughput garbage collector by using the \f3-XX:+UseParallelGC\fR and \f3-XX:+UseParallelOldGC\fR options, and survivor space is resized according to the application behavior, starting with the initial value\&. If adaptive sizing is disabled (using the \f3-XX:-UseAdaptiveSizePolicy\fR option), then the \f3-XX:SurvivorRatio\fR option should be used to set the size of the survivor space for the entire execution of the application\&.

The following formula can be used to calculate the initial size of survivor space (S) based on the size of the young generation (Y), and the initial survivor space ratio (R):
.sp     
.nf     
\f3S=Y/(R+2)\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The 2 in the equation denotes two survivor spaces\&. The larger the value specified as the initial survivor space ratio, the smaller the initial survivor space size\&.

By default, the initial survivor space ratio is set to 8\&. If the default value for the young generation space size is used (2 MB), the initial size of the survivor space will be 0\&.2 MB\&.

The following example shows how to set the initial survivor space ratio to 4:
.sp     
.nf     
\f3\-XX:InitialSurvivorRatio=4\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:InitiatingHeapOccupancyPercent=\fIpercent\fR
.br
Sets the percentage of the heap occupancy (0 to 100) at which to start a concurrent GC cycle\&. It is used by garbage collectors that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations (for example, the G1 garbage collector)\&.

By default, the initiating value is set to 45%\&. A value of 0 implies nonstop GC cycles\&. The following example shows how to set the initiating heap occupancy to 75%:
.sp     
.nf     
\f3\-XX:InitiatingHeapOccupancyPercent=75\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxGCPauseMillis=\fItime\fR
.br
Sets a target for the maximum GC pause time (in milliseconds)\&. This is a soft goal, and the JVM will make its best effort to achieve it\&. By default, there is no maximum pause time value\&.

The following example shows how to set the maximum target pause time to 500 ms:
.sp     
.nf     
\f3\-XX:MaxGCPauseMillis=500\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxHeapSize=\fIsize\fR
.br
Sets the maximum size (in byes) of the memory allocation pool\&. This value must be a multiple of 1024 and greater than 2 MB\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. The default value is chosen at runtime based on system configuration\&. For server deployments, \f3-XX:InitialHeapSize\fR and \f3-XX:MaxHeapSize\fR are often set to the same value\&. For more information, see Garbage Collector Ergonomics at http://docs\&.oracle\&.com/javase/8/docs/technotes/guides/vm/gc-ergonomics\&.html

The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units:
.sp     
.nf     
\f3\-XX:MaxHeapSize=83886080\fP
.fi     
.nf     
\f3\-XX:MaxHeapSize=81920k\fP
.fi     
.nf     
\f3\-XX:MaxHeapSize=80m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


On Oracle Solaris 7 and Oracle Solaris 8 SPARC platforms, the upper limit for this value is approximately 4,000 MB minus overhead amounts\&. On Oracle Solaris 2\&.6 and x86 platforms, the upper limit is approximately 2,000 MB minus overhead amounts\&. On Linux platforms, the upper limit is approximately 2,000 MB minus overhead amounts\&.

The \f3-XX:MaxHeapSize\fR option is equivalent to \f3-Xmx\fR\&.
.TP
-XX:MaxHeapFreeRatio=\fIpercent\fR
.br
Sets the maximum allowed percentage of free heap space (0 to 100) after a GC event\&. If free heap space expands above this value, then the heap will be shrunk\&. By default, this value is set to 70%\&.

The following example shows how to set the maximum free heap ratio to 75%:
.sp     
.nf     
\f3\-XX:MaxHeapFreeRatio=75\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxMetaspaceSize=\fIsize\fR
.br
Sets the maximum amount of native memory that can be allocated for class metadata\&. By default, the size is not limited\&. The amount of metadata for an application depends on the application itself, other running applications, and the amount of memory available on the system\&.

The following example shows how to set the maximum class metadata size to 256 MB:
.sp     
.nf     
\f3\-XX:MaxMetaspaceSize=256m\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MaxNewSize=\fIsize\fR
.br
Sets the maximum size (in bytes) of the heap for the young generation (nursery)\&. The default value is set ergonomically\&.
.TP
-XX:MaxTenuringThreshold=\fIthreshold\fR
.br
Sets the maximum tenuring threshold for use in adaptive GC sizing\&. The largest value is 15\&. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector\&.

The following example shows how to set the maximum tenuring threshold to 10:
.sp     
.nf     
\f3\-XX:MaxTenuringThreshold=10\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:MetaspaceSize=\fIsize\fR
.br
Sets the size of the allocated class metadata space that will trigger a garbage collection the first time it is exceeded\&. This threshold for a garbage collection is increased or decreased depending on the amount of metadata used\&. The default size depends on the platform\&.
.TP
-XX:MinHeapFreeRatio=\fIpercent\fR
.br
Sets the minimum allowed percentage of free heap space (0 to 100) after a GC event\&. If free heap space falls below this value, then the heap will be expanded\&. By default, this value is set to 40%\&.

The following example shows how to set the minimum free heap ratio to 25%:
.sp     
.nf     
\f3\-XX:MinHeapFreeRatio=25\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:NewRatio=\fIratio\fR
.br
Sets the ratio between young and old generation sizes\&. By default, this option is set to 2\&. The following example shows how to set the young/old ratio to 1:
.sp     
.nf     
\f3\-XX:NewRatio=1\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:NewSize=\fIsize\fR
.br
Sets the initial size (in bytes) of the heap for the young generation (nursery)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&.

The young generation region of the heap is used for new objects\&. GC is performed in this region more often than in other regions\&. If the size for the young generation is too low, then a large number of minor GCs will be performed\&. If the size is too high, then only full GCs will be performed, which can take a long time to complete\&. Oracle recommends that you keep the size for the young generation between a half and a quarter of the overall heap size\&.

The following examples show how to set the initial size of young generation to 256 MB using various units:
.sp     
.nf     
\f3\-XX:NewSize=256m\fP
.fi     
.nf     
\f3\-XX:NewSize=262144k\fP
.fi     
.nf     
\f3\-XX:NewSize=268435456\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


The \f3-XX:NewSize\fR option is equivalent to \f3-Xmn\fR\&.
.TP
-XX:ParallelGCThreads=\fIthreads\fR
.br
Sets the number of threads used for parallel garbage collection in the young and old generations\&. The default value depends on the number of CPUs available to the JVM\&.

For example, to set the number of threads for parallel GC to 2, specify the following option:
.sp     
.nf     
\f3\-XX:ParallelGCThreads=2\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+ParallelRefProcEnabled
.br
Enables parallel reference processing\&. By default, this option is disabled\&.
.TP
-XX:+PrintAdaptiveSizePolicy
.br
Enables printing of information about adaptive generation sizing\&. By default, this option is disabled\&.
.TP
-XX:+PrintGC
.br
Enables printing of messages at every GC\&. By default, this option is disabled\&.
.TP
-XX:+PrintGCApplicationConcurrentTime
.br
Enables printing of how much time elapsed since the last pause (for example, a GC pause)\&. By default, this option is disabled\&.
.TP
-XX:+PrintGCApplicationStoppedTime
.br
Enables printing of how much time the pause (for example, a GC pause) lasted\&. By default, this option is disabled\&.
.TP
-XX+PrintGCDateStamp
.br
Enables printing of a date stamp at every GC\&. By default, this option is disabled\&.
.TP
-XX:+PrintGCDetails
.br
Enables printing of detailed messages at every GC\&. By default, this option is disabled\&.
.TP
-XX:+PrintGCTaskTimeStamps
.br
Enables printing of time stamps for every individual GC worker thread task\&. By default, this option is disabled\&.
.TP
-XX:+PrintGCTimeStamp
.br
Enables printing of time stamps at every GC\&. By default, this option is disabled\&.
.TP
-XX:+PrintTenuringDistribution
.br
Enables printing of tenuring age information\&. The following is an example of the output:
.sp     
.nf     
\f3Desired survivor size 48286924 bytes, new threshold 10 (max 10)\fP
.fi     
.nf     
\f3\- age 1: 28992024 bytes, 28992024 total\fP
.fi     
.nf     
\f3\- age 2: 1366864 bytes, 30358888 total\fP
.fi     
.nf     
\f3\- age 3: 1425912 bytes, 31784800 total\fP
.fi     
.nf     
\f3\&.\&.\&.\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     


Age 1 objects are the youngest survivors (they were created after the previous scavenge, survived the latest scavenge, and moved from eden to survivor space)\&. Age 2 objects have survived two scavenges (during the second scavenge they were copied from one survivor space to the next)\&. And so on\&.

In the preceding example, 28 992 024 bytes survived one scavenge and were copied from eden to survivor space, 1 366 864 bytes are occupied by age 2 objects, etc\&. The third value in each row is the cumulative size of objects of age n or less\&.

By default, this option is disabled\&.
.TP
-XX:+ScavengeBeforeFullGC
.br
Enables GC of the young generation before each full GC\&. This option is enabled by default\&. Oracle recommends that you \fIdo not\fR disable it, because scavenging the young generation before a full GC can reduce the number of objects reachable from the old generation space into the young generation space\&. To disable GC of the young generation before each full GC, specify \f3-XX:-ScavengeBeforeFullGC\fR\&.
.TP
-XX:SoftRefLRUPolicyMSPerMB=\fItime\fR
.br
Sets the amount of time (in milliseconds) a softly reachable object is kept active on the heap after the last time it was referenced\&. The default value is one second of lifetime per free megabyte in the heap\&. The \f3-XX:SoftRefLRUPolicyMSPerMB\fR option accepts integer values representing milliseconds per one megabyte of the current heap size (for Java HotSpot Client VM) or the maximum possible heap size (for Java HotSpot Server VM)\&. This difference means that the Client VM tends to flush soft references rather than grow the heap, whereas the Server VM tends to grow the heap rather than flush soft references\&. In the latter case, the value of the \f3-Xmx\fR option has a significant effect on how quickly soft references are garbage collected\&.

The following example shows how to set the value to 2\&.5 seconds:
.sp     
.nf     
\f3\-XX:SoftRefLRUPolicyMSPerMB=2500\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:SurvivorRatio=\fIratio\fR
.br
Sets the ratio between eden space size and survivor space size\&. By default, this option is set to 8\&. The following example shows how to set the eden/survivor space ratio to 4:
.sp     
.nf     
\f3\-XX:SurvivorRatio=4\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:TargetSurvivorRatio=\fIpercent\fR
.br
Sets the desired percentage of survivor space (0 to 100) used after young garbage collection\&. By default, this option is set to 50%\&.

The following example shows how to set the target survivor space ratio to 30%:
.sp     
.nf     
\f3\-XX:TargetSurvivorRatio=30\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:TLABSize=\fIsize\fR
.br
Sets the initial size (in bytes) of a thread-local allocation buffer (TLAB)\&. Append the letter \f3k\fR or \f3K\fR to indicate kilobytes, \f3m\fR or \f3M\fR to indicate megabytes, \f3g\fR or \f3G\fR to indicate gigabytes\&. If this option is set to 0, then the JVM chooses the initial size automatically\&.

The following example shows how to set the initial TLAB size to 512 KB:
.sp     
.nf     
\f3\-XX:TLABSize=512k\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     

.TP
-XX:+UseAdaptiveSizePolicy
.br
Enables the use of adaptive generation sizing\&. This option is enabled by default\&. To disable adaptive generation sizing, specify \f3-XX:-UseAdaptiveSizePolicy\fR and set the size of the memory allocation pool explicitly (see the \f3-XX:SurvivorRatio\fR option)\&.
.TP
-XX:+UseCMSInitiatingOccupancyOnly
.br
Enables the use of the occupancy value as the only criterion for initiating the CMS collector\&. By default, this option is disabled and other criteria may be used\&.
.TP
-XX:+UseConcMarkSweepGC
.br
Enables the use of the CMS garbage collector for the old generation\&. Oracle recommends that you use the CMS garbage collector when application latency requirements cannot be met by the throughput (\f3-XX:+UseParallelGC\fR) garbage collector\&. The G1 garbage collector (\f3-XX:+UseG1GC\fR) is another alternative\&.

By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM\&. When this option is enabled, the \f3-XX:+UseParNewGC\fR option is automatically set\&.
.TP
-XX:+UseG1GC
.br
Enables the use of the G1 garbage collector\&. It is a server-style garbage collector, targeted for multiprocessor machines with a large amount of RAM\&. It meets GC pause time goals with high probability, while maintaining good throughput\&. The G1 collector is recommended for applications requiring large heaps (sizes of around 6 GB or larger) with limited GC latency requirements (stable and predictable pause time below 0\&.5 seconds)\&.

By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM\&.
.TP
-XX:+UseGCOverheadLimit
.br
Enables the use of a policy that limits the proportion of time spent by the JVM on GC before an \f3OutOfMemoryError\fR exception is thrown\&. This option is enabled, by default and the parallel GC will throw an \f3OutOfMemoryError\fR if more than 98% of the total time is spent on garbage collection and less than 2% of the heap is recovered\&. When the heap is small, this feature can be used to prevent applications from running for long periods of time with little or no progress\&. To disable this option, specify \f3-XX:-UseGCOverheadLimit\fR\&.
.TP
-XX:+UseNUMA
.br
Enables performance optimization of an application on a machine with nonuniform memory architecture (NUMA) by increasing the application\&'s use of lower latency memory\&. By default, this option is disabled and no optimization for NUMA is made\&. The option is only available when the parallel garbage collector is used (\f3-XX:+UseParallelGC\fR)\&.
.TP
-XX:+UseParallelGC
.br
Enables the use of the parallel scavenge garbage collector (also known as the throughput collector) to improve the performance of your application by leveraging multiple processors\&.

By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM\&. If it is enabled, then the \f3-XX:+UseParallelOldGC\fR option is automatically enabled, unless you explicitly disable it\&.
.TP
-XX:+UseParallelOldGC
.br
Enables the use of the parallel garbage collector for full GCs\&. By default, this option is disabled\&. Enabling it automatically enables the \f3-XX:+UseParallelGC\fR option\&.
.TP
-XX:+UseParNewGC
.br
Enables the use of parallel threads for collection in the young generation\&. By default, this option is disabled\&. It is automatically enabled when you set the \f3-XX:+UseConcMarkSweepGC\fR option\&.
.TP
-XX:+UseSerialGC
.br
Enables the use of the serial garbage collector\&. This is generally the best choice for small and simple applications that do not require any special functionality from garbage collection\&. By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM\&.
.TP
-XX:+UseTLAB
.br
Enables the use of thread-local allocation blocks (TLABs) in the young generation space\&. This option is enabled by default\&. To disable the use of TLABs, specify \f3-XX:-UseTLAB\fR\&.
.SS DEPRECATED\ AND\ REMOVED\ OPTIONS    
These options were included in the previous release, but have since been considered unnecessary\&.
.TP
-Xrun\fIlibname\fR
.br
Loads the specified debugging/profiling library\&. This option was superseded by the \f3-agentlib\fR option\&.
.TP
-XX:CMSInitiatingPermOccupancyFraction=\fIpercent\fR
.br
Sets the percentage of the permanent generation occupancy (0 to 100) at which to start a GC\&. This option was deprecated in JDK 8 with no replacement\&.
.TP
-XX:MaxPermSize=\fIsize\fR
.br
Sets the maximum permanent generation space size (in bytes)\&. This option was deprecated in JDK 8, and superseded by the \f3-XX:MaxMetaspaceSize\fR option\&.
.TP
-XX:PermSize=\fIsize\fR
.br
Sets the space (in bytes) allocated to the permanent generation that triggers a garbage collection if it is exceeded\&. This option was deprecated un JDK 8, and superseded by the \f3-XX:MetaspaceSize\fR option\&.
.TP
-XX:+UseSplitVerifier
.br
Enables splitting of the verification process\&. By default, this option was enabled in the previous releases, and verification was split into two phases: type referencing (performed by the compiler) and type checking (performed by the JVM runtime)\&. This option was deprecated in JDK 8, and verification is now split by default without a way to disable it\&.
.TP
-XX:+UseStringCache
.br
Enables caching of commonly allocated strings\&. This option was removed from JDK 8 with no replacement\&.
.SH PERFORMANCE\ TUNING\ EXAMPLES    
The following examples show how to use experimental tuning flags to either optimize throughput or to provide lower response time\&.
.PP
\f3Example 1 Tuning for Higher Throughput\fR
.sp     
.nf     
\f3java \-d64 \-server \-XX:+AggressiveOpts \-XX:+UseLargePages \-Xmn10g  \-Xms26g \-Xmx26g\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     
\f3Example 2 Tuning for Lower Response Time\fR
.sp     
.nf     
\f3java \-d64 \-XX:+UseG1GC \-Xms26g Xmx26g \-XX:MaxGCPauseMillis=500 \-XX:+PrintGCTimeStamp\fP
.fi     
.nf     
\f3\fP
.fi     
.sp     
.SH EXIT\ STATUS    
The following exit values are typically returned by the launcher when the launcher is called with the wrong arguments, serious errors, or exceptions thrown by the JVM\&. However, a Java application may choose to return any value by using the API call \f3System\&.exit(exitValue)\fR\&. The values are:
.TP 0.2i    
\(bu
\f30\fR: Successful completion
.TP 0.2i    
\(bu
\f3>0\fR: An error occurred
.SH SEE\ ALSO    
.TP 0.2i    
\(bu
javac(1)
.TP 0.2i    
\(bu
jdb(1)
.TP 0.2i    
\(bu
javah(1)
.TP 0.2i    
\(bu
jar(1)
.RE
.br
'pl 8.5i
'bp
