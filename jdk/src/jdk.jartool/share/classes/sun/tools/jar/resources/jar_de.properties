#
# Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

error.multiple.main.operations=Sie k\u00F6nnen nicht mehrere "-cuxtid"-Optionen angeben
error.cant.open=\u00D6ffnen nicht m\u00F6glich: {0}
error.illegal.option=Ung\u00FCltige Option: {0}
error.unrecognized.option=Unbekannte Option: {0}
error.missing.arg=F\u00FCr die Option {0} ist ein Argument erforderlich
error.bad.file.arg=Fehler beim Parsen der Dateiargumente
error.bad.option=Eine der Optionen -{ctxu} muss angegeben werden.
error.bad.cflag=Kennzeichen "c" erfordert Angabe von Manifest oder Eingabedateien.
error.bad.uflag=Kennzeichen "u" erfordert Angabe von Manifest, Kennzeichen "e" oder Eingabedateien.
error.bad.eflag=Kennzeichen "e" und Manifest mit dem Attribut "Main-Class" k\u00F6nnen nicht zusammen angegeben\nwerden.
error.nosuch.fileordir={0}: Datei oder Verzeichnis nicht vorhanden
error.write.file=Fehler beim Schreiben in vorhandener JAR-Datei
error.create.dir={0}: Verzeichnis konnte nicht erstellt werden
error.incorrect.length=Falsche L\u00E4nge bei der Verarbeitung: {0}
error.create.tempfile=Es konnte keine tempor\u00E4re Datei erstellt werden
error.hash.dep=Abh\u00E4ngigkeiten bei Hashing-Modul {0}. Modul {1} kann nicht im Modulpfad gefunden werden
error.module.options.without.info=--module-version oder --hash-modules ohne module-info.class
error.unexpected.module-info=Unerwarteter Moduldeskriptor {0}
error.module.descriptor.not.found=Moduldeskriptor nicht gefunden
error.validator.info.without.root=module-info.class in einem versionierten Verzeichnis gefunden, in der Root ist module-info.class jedoch nicht vorhanden
error.validator.info.name.notequal=module-info.class in einem versionierten Verzeichnis enth\u00E4lt falschen Namen
error.validator.info.requires.public=module-info.class in einem versionierten Verzeichnis enth\u00E4lt zus\u00E4tzlichen "requires public"
error.validator.info.requires.added=module-info.class in einem versionierten Verzeichnis enth\u00E4lt zus\u00E4tzlichen "requires"
error.validator.info.requires.dropped=module-info.class in einem versionierten Verzeichnis enth\u00E4lt fehlenden "requires"
error.validator.info.exports.notequal=module-info.class in einem versionierten Verzeichnis enth\u00E4lt unterschiedliche "exports"
error.validator.info.provides.notequal=module-info.class in einem versionierten Verzeichnis enth\u00E4lt unterschiedliche "provides"
error.invalid.versioned.module.attribute=Ung\u00FCltiges Moduldeskriptorattribut {0}
error.missing.provider=Serviceprovider nicht gefunden: {0}
error.release.value.notnumber=Release {0} nicht g\u00FCltig
error.release.value.toosmall=Release {0} nicht g\u00FCltig, muss >= 9 sein
error.validator.jarfile.exception={0} kann nicht validiert werden: {1}
error.validator.jarfile.invalid=ung\u00FCltige Multi-Release-JAR-Datei {0} gel\u00F6scht
error.validator.bad.entry.name=Eintragsname hat das falsche Format, {0}
error.validator.version.notnumber=Eintragsname {0} hat keine Versionsnummer
error.validator.entryname.tooshort=Eintragsname {0} zu kurz, kein Verzeichnis
error.validator.isolated.nested.class=Eintrag {0} ist eine isolierte verschachtelte Klasse
error.validator.new.public.class=Eintrag {0} enth\u00E4lt eine neue \u00F6ffentliche Klasse, die in Basiseintr\u00E4gen nicht gefunden wird
error.validator.incompatible.class.version=Eintrag {0} weist eine Klassenversion auf, die mit einer fr\u00FCheren Version inkompatibel ist
error.validator.different.api=Eintrag {0} enth\u00E4lt eine Klasse mit einer anderen API als in der fr\u00FCheren Version
error.validator.names.mismatch=Eintrag {0} enth\u00E4lt eine Klasse mit dem internen Namen {1}, Namen stimmen nicht \u00FCberein
warn.validator.identical.entry=Warnung - Eintrag {0} enth\u00E4lt eine Klasse, die mit einem Eintrag identisch ist, der bereits in der JAR-Datei enthalten ist
warn.validator.resources.with.same.name=Warnung - Eintrag {0}, mehrere Ressourcen mit demselben Namen
warn.validator.concealed.public.class=Warnung - Eintrag {0} ist eine \u00F6ffentliche Klasse in einem verdeckten Package, \nwenn diese JAR-Datei in den Classpath gesetzt wird, kommt es zu nicht kompatiblen \u00F6ffentlichen Schnittstellen
out.added.manifest=Manifest wurde hinzugef\u00FCgt
out.added.module-info=module-info hinzugef\u00FCgt: {0}
out.update.manifest=Manifest wurde aktualisiert
out.update.module-info=module-info aktualisiert: {0}
out.ignore.entry=Eintrag {0} wird ignoriert
out.adding={0} wird hinzugef\u00FCgt
out.deflated=({0} % verkleinert)
out.stored=(0 % gespeichert)
out.create=\  erstellt: {0}
out.extracted=extrahiert: {0}
out.inflated=\ vergr\u00F6\u00DFert: {0}
out.size=(ein = {0}) (aus = {1})

usage.compat=Kompatibilit\u00E4tsschnittstelle:\nVerwendung:  jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] Dateien] ...\nOptionen:\n    -c  Neues Archiv erstellen\n    -t  Inhaltsverzeichnis f\u00FCr Archiv anzeigen\n    -x  Benannte (oder alle) Dateien aus Archiv extrahieren\n    -u  Vorhandenes Archiv aktualisieren\n    -v  Ausgabe im Verbose-Modus aus Standardausgabe generieren\n    -f  Dateinamen f\u00FCr Archiv angeben\n    -m  Manifestinformationen aus angegebener Manifestdatei aufnehmen\n    -n  Pack200-Normalisierung nach Erstellung eines neuen Archivs ausf\u00FChren\n    -e  Anwendungseinstiegspunkt f\u00FCr in ausf\u00FChrbare JAR-Datei \n        geb\u00FCndelte Standalone-Anwendung angeben\n    -0  Nur speichern; keine ZIP-Komprimierung verwenden\n    -P  Komponenten mit vorangestelltem "/" (absoluter Pfad) und ".." (\u00FCbergeordnetes Verzeichnis) aus Dateinamen beibehalten\n        -M  Keine Manifestdatei f\u00FCr die Eintr\u00E4ge erstellen\n    -i  Indexinformationen f\u00FCr die angegebenen JAR-Dateien erstellen\n    -C  Zum angegebenen Verzeichnis wechseln und folgende Datei ber\u00FCcksichtigen\nDateien, die Verzeichnisse sind, werden rekursiv verarbeitet.\nDer Name der Manifestdatei, der Name der Archivdatei und der Name des Einstiegspunktes werden\nin derselben Reihenfolge wie die Kennzeichen "m", "f" und "e" angegeben.\n\nBeispiel 1: Zwei Klassendateien in ein Archiv "classes.jar" archivieren: \n       jar cvf classes.jar Foo.class Bar.class \nBeispiel 2: Mit der vorhandenen Manifestdatei "mymanifest" alle\n           Dateien im Verzeichnis foo/ in "classes.jar" archivieren: \n       jar cvfm classes.jar mymanifest -C foo/ .\n

main.usage.summary=Verwendung: jar [OPTION...] [ [--release VERSION] [-C dir] Dateien] ...
main.usage.summary.try=Verwenden Sie "jar --help", um weitere Informationen anzuzeigen.

main.help.preopt=Verwendung: jar [OPTION...] [ [--release VERSION] [-C dir] Dateien] ...\njar erstellt ein Archiv f\u00FCr Klassen und Ressourcen und kann individuelle\nKlassen oder Ressourcen aus einem Archiv bearbeiten oder wiederherstellen.\n\n Beispiele:\n # Ein Archiv namens classes.jar mit zwei Klassendateien erstellen:\n jar --create --file classes.jar Foo.class Bar.class\n # Ein Archiv mit einem vorhandenen Manifest mit allen Dateien in foo/ erstellen:\n jar --create --file classes.jar --manifest mymanifest -C foo/ .\n # Ein modulares JAR-Archiv erstellen, dessen Moduldeskriptor sich in\n # classes/module-info.class befindet:\n jar --create --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ classes resources\n # Ein vorhandenes nicht modulares JAR-Archiv in ein modulares JAR-Archiv aktualisieren:\n jar --update --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ module-info.class\n # Multi-Release-JAR-Datei erstellen, wobei einige Dateien in das Verzeichnis META-INF/versions/9 gespeichert werden:\n jar --create --file mr.jar -C foo classes --release 9 -C foo9 classes
main.help.opt.main=\ Hauptvorgangsmodus:\n
main.help.opt.main.create=\  -c, --create               Archiv erstellen
main.help.opt.main.generate-index=\  -i, --generate-index=FILE  Indexinformationen f\u00FCr die angegebenen JAR-\n                             Archive generieren
main.help.opt.main.list=\  -t, --list                 Das Inhaltsverzeichnis f\u00FCr das Archiv auflisten
main.help.opt.main.update=\  -u, --update               Ein vorhandenes JAR-Archiv aktualisieren
main.help.opt.main.extract=\  -x, --extract              Benannte (oder alle) Dateien aus dem Archiv extrahieren
main.help.opt.main.print-module-descriptor=\  -d, --print-module-descriptor  Moduldeskriptor drucken
main.help.opt.any=\ In jedem Modus g\u00FCltige Vorgangsmodifikatoren:\n\n  -C DIR                     Zum angegebenen Verzeichnis wechseln und die folgende\n                             Datei aufnehmen
main.help.opt.any.file=-f, --file=FILE            Der Name der Archivdatei\n      --release VERSION      Die folgenden Dateien werden in ein versioniertes Verzeichnis\n                             der JAR-Datei gespeichert (d.h. META-INF/versions/VERSION/)
main.help.opt.any.verbose=\  -v, --verbose              Verbose-Ausgabe bei Standardausgabe generieren
main.help.opt.create.update=\ Vorgangsmodifikatoren, die nur im Erstellungs- und Aktualisierungsmodus g\u00FCltig sind:\n
main.help.opt.create.update.main-class=\  -e, --main-class=CLASSNAME Der Anwendungseinstiegspunkt f\u00FCr Standalone-\n                             Anwendungen, die in einem modularen oder ausf\u00FChrbaren\n                             JAR-Archiv geb\u00FCndelt sind
main.help.opt.create.update.manifest=\  -m, --manifest=FILE        Die Manifestinformationen aus der angegebenen\n                             Manifestdatei aufnehmen
main.help.opt.create.update.no-manifest=\  -M, --no-manifest          Keine Manifestdatei f\u00FCr die Eintr\u00E4ge erstellen
main.help.opt.create.update.module-version=\      --module-version=VERSION    Die Modulversion beim Erstellen eines modularen\n                             JAR-Archivs oder Aktualisieren eines nicht modularen JAR-Archivs
main.help.opt.create.update.hash-modules=\      --hash-modules=PATTERN Berechnet und zeichnet die Hashes von Modulen auf, \n                             die mit einem bestimmten Muster \u00FCbereinstimmen, und direkt oder\n                             indirekt von einem modularen JAR-Archiv abh\u00E4ngen, das erstellt\n                             wird, oder einem nicht-modularen JAR-Archiv, das aktualisiert wird
main.help.opt.create.update.module-path=\  -p, --module-path         Speicherort von Modulabh\u00E4ngigkeit zur Generierung\n                             von Hash
main.help.opt.create.update.index=\ Vorgangsmodifikatoren, die nur im Erstellungs-, Aktualisierungs- und Indexgenerierungsmodus g\u00FCltig sind:\n
main.help.opt.create.update.index.no-compress=\  -0, --no-compress          Nur speichern, keine ZIP-Komprimierung verwenden
main.help.opt.other=\ Weitere Optionen:\n
main.help.opt.other.help=\  -?, --help[:compat]        Diese Meldung oder optional die Kompatibilit\u00E4t, Hilfe angeben
main.help.opt.other.version=\      --version              Programmversion ausgeben
main.help.postopt=\ Ein Archiv ist ein modulares JAR-Archiv, wenn der Moduldeskriptor "module-info.class"\n in der Root der angegebenen Verzeichnisse oder in der Root des JAR-Archivs selbst\n vorhanden ist. Die folgenden Vorg\u00E4nge sind nur g\u00FCltig, wenn Sie ein modulares JAR-Archiv\n erstellen oder ein vorhandenes nicht modulares JAR-Archiv aktualisieren: "--module-version",\n "--hash-modules" und "--modulepath".\n\n Obligatorische oder optionale Argumente zu langen Optionen sind auch f\u00FCr die jeweils\n zugeh\u00F6rigen kurzen Optionen obligatorisch oder optional.
