#
# Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

javac.err.internal=\
	Internal error.
javac.err.eof.in.comment=\
	Comment not terminated at end of input.
javac.err.eof.in.string=\
	String not terminated at end of input.
javac.err.newline.in.string=\
	String not terminated at end of line.
javac.err.invalid.char.constant=\
	Invalid character constant.
javac.err.unbalanced.paren=\
	Unbalanced parentheses.
javac.err.invalid.escape.char=\
	Invalid escape character.
javac.err.invalid.hex.number=\
	Hexadecimal numbers must contain at least one hexadecimal digit.
javac.err.invalid.octal.number=\
	Invalid character in octal number.
javac.err.invalid.number=\
	Invalid character in number.
javac.err.funny.char=\
	Invalid character in input.
javac.err.float.format=\
	Invalid floating point format.
javac.err.overflow.int.oct=\
	Integer literal out of range.  Octal int literals must be in \
	the range 00 to 037777777777.
javac.err.overflow.int.dec=\
	Integer literal out of range.  Decimal int literals must be in \
	the range -2147483648 to 2147483647.
javac.err.overflow.int.hex=\
	Integer literal out of range.  Hexadecimal int literals must be in \
	the range 0x0 to 0xffffffff.
javac.err.overflow.long.oct=\
	Integer literal out of range.  Octal long literals must be in \
	the range 00L to 01777777777777777777777L.
javac.err.overflow.long.dec=\
	Integer literal out of range.  Decimal long literals must be in \
	the range -9223372036854775808L to 9223372036854775807L.
javac.err.overflow.long.hex=\
	Integer literal out of range.  Hexadecimal long literals must be in \
	the range 0x0L to 0xffffffffffffffffL.
javac.err.overflow.float=\
	Numeric overflow: float literal too large.
javac.err.overflow.double=\
	Numeric overflow: double literal too large.
javac.err.underflow.float=\
	Numeric underflow: float literal too small.
javac.err.underflow.double=\
	Numeric underflow: double literal too small.
javac.err.token.expected=\
	''{0}'' expected.
javac.err.statement.expected=\
	Statement expected.
javac.err.type.expected=\
	Type expected.
javac.err.identifier.expected=\
	Identifier expected.
javac.err.class.expected=\
	''class'' or ''interface'' keyword expected.
javac.err.toplevel.expected=\
	Class or interface declaration expected.
javac.err.missing.term=\
	Missing term.
javac.err.assign.in.conditionalexpr=\
	Assignment expressions are not permitted as the third subexpression \
	of a conditional expression (that is, a ? : expression).  \
	Try parenthesizing this assignment expression.
javac.err.else.without.if=\
	''else'' without ''if''.
javac.err.catch.without.try=\
	''catch'' without ''try''.
javac.err.finally.without.try=\
	''finally'' without ''try''.
javac.err.try.without.catch.finally=\
	''try'' without ''catch'' or ''finally''.
javac.err.case.without.switch=\
	''case'' outside switch statement.
javac.err.default.without.switch=\
	''default'' outside switch statement.
javac.err.io.exception=\
	I/O error in {0}.
javac.err.io.exception.package=\
	I/O error while checking for existence of package {0}.
javac.err.malformed.attribute=\
	The class file containing {0} has a malformed ''{1}'' attribute.
javac.err.array.index.required=\
	Array index required.
javac.err.not.array=\
	[] can only be applied to arrays. It can''t be applied to {0}.
javac.err.array.dim.in.decl=\
	Can''t specify array dimension in a declaration.
javac.err.array.dim.in.type=\
	Can''t specify array dimension in a type expression.
javac.err.invalid.array.expr=\
	Array constants can only be used in initializers.
javac.err.invalid.array.init=\
	Invalid initializer for type {0}.
javac.err.invalid.lhs.assignment=\
	Invalid left hand side of assignment.
javac.err.invalid.args=\
	Invalid arguments to {0}.
javac.err.invalid.cast=\
	Invalid cast from {0} to {1}.
javac.err.invalid.instanceof=\
	Impossible for {0} to be instance of {1}.
javac.err.invalid.type.expr=\
	Invalid type expression.
javac.err.anonymous.extends=\
	Only named classes can have ''extends'' or ''implements'' clauses.
javac.err.invalid.field.reference=\
	Attempt to reference field {0} in a {1}.
javac.err.no.such.field=\
	No variable {0} defined in {1}.
javac.err.no.field.access=\
	Variable {0} in {1} not accessible from {2}.
javac.err.no.type.access=\
	Inner type {0} in {1} not accessible from {2}.
javac.err.cant.access.member.type=\
	The type {1} to which the member {0} belongs is not accessible from {2}.
javac.err.inner.class.expected=\
	No inner class {0} found in {1}.
javac.err.no.static.field.access=\
	Can''t make a static reference to nonstatic variable {0} in {1}.
javac.err.inner.static.ref=\
	Can''t make a static reference to inner class {0}.
javac.err.ambig.field=\
	Reference to {0} is ambiguous. It is defined in {1} and {2}.
javac.err.invalid.field=\
	Attempt to reference method {0} in {1} as an instance variable.
javac.err.assign.to.final=\
	Can''t assign a value to a final variable: {0}
javac.err.assign.to.blank.final=\
	Can''t assign a second value to a blank final variable: {0}
javac.err.qualified.static.final.assign=\
	The variable in an assignment to a static blank final must be a simple name (it may not follow a dot ''.'').
javac.err.bad.qualified.final.assign=\
	The variable in an assignment to a blank final must be a simple name or a simple name qualified by ''this'': ''{0}'' or ''this.{0}''.
javac.err.assign.to.blank.final.in.loop=\
	Attempt to assign a blank final variable {0} in a loop. The initialization must occur exactly once.
javac.err.assign.to.uplevel=\
	Attempt to assign to a variable {0} in a different method. From enclosing blocks, only final local variables are available.
javac.err.invalid.uplevel=\
	Attempt to use a non-final variable {0} from a different method. From enclosing blocks, only final local variables are available.
javac.err.undef.var=\
	Undefined variable: {0}
javac.err.undef.var.super=\
	Undefined variable: {0}.  The "super" keyword may only be used for member access and constructor invocation.
javac.err.undef.var.or.package=\
	Undefined variable or package name: {0}
javac.err.undef.class.or.package=\
	Undefined class or package name: {0}
javac.err.undef.var.class.or.package=\
	Undefined variable, class, or package name: {0}
javac.err.undef.class=\
	Undefined class name: {0}
javac.err.undef.var.or.class=\
	Undefined variable or class name: {0}
javac.err.var.not.initialized=\
	Variable {0} may not have been initialized.
javac.err.final.var.not.initialized=\
	Blank final variable ''{0}'' may not have been initialized. It must be assigned a value in an initializer, or in every constructor.
javac.err.access.inst.before.super=\
	Can''t reference {0} before the superclass constructor has been called.
javac.err.ambig.class=\
	Ambiguous class: {0} and {1}
javac.err.invalid.arg=\
	Invalid argument to {0}.
javac.err.invalid.arg.type=\
	Invalid argument type {0} for {1}.
javac.err.invalid.length=\
	''length'' applied to {0}, which is not an array.
javac.err.invalid.constr.invoke=\
	Only constructors can invoke constructors.
javac.err.constr.invoke.not.first=\
	Constructor invocation must be the first thing in a method.
javac.err.invalid.method.invoke=\
	Can''t invoke a method on a {0}.
javac.err.undef.meth=\
	Method {0} not found in {1}.
javac.err.no.meth.access=\
	Method {0} in {1} is not accessible from {2}.
#warning:
javac.err.no.override.access=\
	Note: Method {0} in {1} does not override the corresponding method in {2}.  If you are trying to override this method, you cannot do so because it is private to a different package.
javac.err.no.static.meth.access=\
	Can''t make static reference to method {0} in {1}.
javac.err.invalid.protected.method.use=\
	Can''t access protected method {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.protected.field.use=\
	Can''t access protected field {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.protected.type.use=\
	Can''t access protected inner type {0} in {1}. {2} is not a subclass of the current class.
javac.err.invalid.protected.constructor.use=\
	Can''t access protected constructor of {0}.  Instance creation is permitted only within the package in which the constructor is defined.
javac.err.invalid.method=\
	Reference to variable {0} in {1} as if it were a method.
javac.err.invalid.var=\
	Reference to method {0} in {1} as if it were a variable.
javac.err.synchronized.null=\
	The null literal is not a legal argument for the synchronized statement.
#all messages related to deprecation are warnings:
javac.err.class.is.deprecated=\
	Note: {0} has been deprecated.
javac.err.meth.is.deprecated=\
	Note: The method {0} in {1} has been deprecated.
javac.err.constr.is.deprecated=\
	Note: The constructor {0} has been deprecated.
javac.err.field.is.deprecated=\
	Note: The variable {0} in {1} has been deprecated.
javac.err.note.deprecations=\
	Note: {0} files use or override a deprecated API.  Please consult the documentation for a better alternative in each case.
javac.err.note.1deprecation=\
	Note: {0} uses or overrides a deprecated API.  Please consult the documentation for a better alternative.
javac.err.note.deprecations.silent=\
	Note: {0} files use or override a deprecated API.  Recompile with "-deprecation" for details.
javac.err.note.1deprecation.silent=\
	Note: {0} uses or overrides a deprecated API.  Recompile with "-deprecation" for details.
javac.err.invalid.array.dim=\
	Invalid array dimension.
javac.err.ambig.constr=\
	Constructor is ambiguous: {0}, {1}
javac.err.explicit.cast.needed=\
	Incompatible type for {0}. Explicit cast needed to convert {1} to {2}.
javac.err.incompatible.type=\
	Incompatible type for {0}. Can''t convert {1} to {2}.
javac.err.invalid.term=\
	Invalid term.
javac.err.abstract.class=\
	{0} must be declared abstract. It does not define {1} from {2}.
javac.err.abstract.class.cannot.override=\
	{0} must be declared abstract.  The package-private abstract method {1} in superclass {2} is inaccessible and cannot be overridden.
javac.err.new.intf=\
	{0} is an interface. It can''t be instantiated.
javac.err.invoke.abstract=\
	Can''t directly invoke abstract method {0} in {1}.
javac.err.unmatched.meth=\
	No method matching {0} found in {1}.
javac.err.unmatched.constr=\
	No constructor matching {0} found in {1}.
javac.err.wrong.number.args=\
	Wrong number of arguments in {0}.
javac.err.forward.ref=\
	Can''t make forward reference to {0} in {1}.
javac.err.array.dim.missing=\
	Array dimension missing.
javac.err.new.abstract=\
	{0} is an abstract class. It can''t be instantiated.
javac.err.label.not.found=\
	No label definition found for {0}.
javac.err.invalid.break=\
	''break'' must be in loop or switch.
javac.err.invalid.continue=\
	''continue'' must be in loop.
javac.err.branch.to.uplevel=\
	a ''break'' or ''continue'' must transfer control within the same method.
javac.err.invalid.decl=\
	Invalid declaration.
javac.err.return.with.value=\
	''return'' with value from {0}.
javac.err.return.without.value=\
	''return'' without value from {0}.
javac.err.return.inside.static.initializer=\
	''return'' inside static initializer.
javac.err.invalid.label=\
	Invalid label.
javac.err.return.required.at.end=\
	Return required at end of {0}.
javac.err.duplicate.label=\
	Duplicate case label: {0}
javac.err.switch.overflow=\
	Case label {0} too large for ''switch'' on {1}
javac.err.nested.duplicate.label=\
	A statement cannot be labeled with the same identifier as one of its enclosing statements: {0}
javac.err.declaration.with.label=\
	A declaration cannot be labeled: {0}
javac.err.const.expr.required=\
	Constant expression required.
javac.err.duplicate.default=\
	Duplicate ''default'' label.
javac.err.not.supported=\
	''{0}'' not supported.
javac.err.return.with.value.constr=\
	''return'' with value from constructor: {0}
javac.err.package.repeated=\
	Only one package declaration allowed.
javac.err.class.multidef=\
	Class {0} already defined in {1}.
javac.err.class.multidef.import=\
	Class name {0} clashes with imported class {1}.
javac.err.intf.constructor=\
	Interfaces can''t have constructors.
javac.err.constr.modifier=\
	Constructors can''t be native, abstract, static, synchronized, or final: {0}
javac.err.intf.initializer=\
	Interfaces can''t have static initializers.
javac.err.intf.modifier.method=\
	Interface methods can''t be native, static, synchronized, final, private, or protected : {0}
javac.err.intf.modifier.field=\
	Interface fields can''t be private or protected: {0}
javac.err.transient.meth=\
	Method {0} can''t be transient. Only variables can be transient.
javac.err.volatile.meth=\
	Method {0} can''t be volatile. Only variables can be volatile.
javac.err.abstract.private.modifier=\
	Abstract methods can''t be private: {0}
javac.err.abstract.static.modifier=\
	Abstract methods can''t be static: {0}
javac.err.abstract.final.modifier=\
	Abstract methods can''t be final: {0}
javac.err.abstract.native.modifier=\
	Abstract methods can''t be native: {0}
javac.err.abstract.synchronized.modifier=\
	Abstract methods can''t be synchronized: {0}
javac.err.invalid.meth.body=\
	Abstract and native methods can''t have a body: {0}
javac.err.var.modifier=\
	Variables can''t be synchronized, abstract or native: {0}
javac.err.var.floatmodifier=\
	Variables can''t be declared strict: {0}
javac.err.inner.modifier=\
	Inner classes can''t be volatile, transient, native, or synchronized: {0}
javac.err.transient.modifier=\
	Transient variables can''t be members of interfaces: {0}
javac.err.volatile.modifier=\
	Volatile variables can''t be final or members of interfaces: {0}
javac.err.initializer.needed=\
	This final variable must be initialized: {0}
javac.err.meth.multidef=\
	Duplicate method declaration: {0}
javac.err.meth.redef.rettype=\
	Methods can''t be redefined with a different return type: {0} was {1}
javac.err.var.multidef=\
	Duplicate variable declaration: {0} was {1}
javac.err.inner.class.multidef=\
	Duplicate inner class declaration: {0} is already defined in this scope.
javac.err.intf.super.class=\
	Superclass of {0} can''t be an interface: {1}
javac.err.cant.access.class=\
	Can''t access {0}. Class or interface must be public, in same package, or an accessible member class.
javac.err.unqualified.name.required=\
	The type name in a qualified 'new' expression must be an unqualified identifier.
javac.err.repeated.modifier=\
	Repeated modifier.
javac.err.inconsistent.modifier=\
	Inconsistent member declaration. At most one of public, private, or protected may be specified.
javac.err.super.is.final=\
	Can''t subclass final classes: {0}
javac.err.super.is.intf=\
	Can''t subclass interfaces: {0}
javac.err.cyclic.super=\
	Cyclic class inheritance.
javac.err.super.is.inner=\
	Cyclic class inheritance:  A subclass cannot enclose a superclass.
javac.err.cyclic.intf=\
	Cyclic interface inheritance.
javac.err.cyclic.scoping=\
	Cyclic class inheritance or scoping.
javac.err.not.intf=\
	{0} must be an interface.
javac.err.final.intf=\
	Interfaces can''t be final: {0}
javac.err.intf.impl.intf=\
	An interface can''t implement anything; it can only extend other interfaces.
javac.err.multiple.inherit=\
	Multiple inheritance is not supported.
javac.err.intf.repeated=\
	Interface {0} repeated.
javac.err.class.format=\
	Invalid class file format in {0}.  {1}
javac.err.truncated.class=\
	Unexpected end of file encountered while reading the class file {0}.
javac.err.no.meth.body=\
	Method {0} requires a method body. Otherwise declare it as abstract.
javac.err.no.constructor.body=\
	Constructor {0} requires a method body.
javac.err.bad.constructor.modifier=\
	Constructors may not be modified by strictfp.
javac.err.void.inst.var=\
	Instance variables can''t be void: {0}
javac.err.invalid.method.decl=\
	Invalid method declaration; return type required.
javac.err.invalid.method.decl.name=\
	Invalid method declaration; method name required.
javac.err.invalid.method.decl.qual=\
	Invalid qualified constructor name.
javac.err.super.not.found=\
	Superclass {0} of {1} not found.
javac.err.intf.not.found=\
	Interface {0} of {1} not found.
javac.err.final.abstract=\
        Class {0} can''t be declared both abstract and final.
javac.err.void.array=\
	Array of void is not a valid type.
javac.err.void.argument=\
	Argument can''t have type void: {0}
javac.err.invalid.expr=\
	Invalid expression statement.
javac.err.catch.not.reached=\
	catch not reached.
javac.err.stat.not.reached=\
	Statement not reached.
javac.err.init.no.normal.completion=\
	Initializer must be able to complete normally.
javac.err.arithmetic.exception=\
	Arithmetic exception.
javac.err.generic=\
	{0}
javac.err.public.class.file=\
	Public {0} must be defined in a file called "{1}".
javac.err.package.class.file=\
	{0} is defined in {1}. Because it is used outside of its source file, it should be defined in a file called "{2}".
javac.err.lose.precision=\
	Possible loss of precision. Use an explicit cast to convert {0} to {1}.
javac.err.duplicate.argument=\
	Variable ''{0}'' is used twice in the argument list of this method.
javac.err.local.redefined=\
	Variable ''{0}'' is already defined in this method.
javac.err.local.class.redefined=\
	Local class ''{0}'' is already defined in this method.
javac.err.inner.redefined=\
	The class name ''{0}'' is already defined in this scope.  An inner class may not have the same simple name as any of its enclosing classes.
javac.err.inherited.hides.field=\
	Variable ''{0}'' is inherited in {1}, and hides a variable of the same name in {2}. An explicit ''this'' qualifier must be used to select the desired instance.
javac.err.inherited.hides.local=\
	Variable ''{0}'' is inherited in {1}, and hides a local variable of the same name. An explicit ''this'' qualifier must be used to select the variable, or the local must be renamed.
javac.err.inherited.hides.method=\
	Method ''{0}'' is inherited in {1}, and hides a method of the same name in {2}. An explicit ''this'' qualifier must be used to select the desired instance.
javac.err.inherited.hides.type=\
	Type ''{0}'' is inherited in {1}, and hides a type of the same name in an enclosing scope. An explicit qualifier prefix must be used to name this type.
javac.err.private.class=\
	The type {0} can''t be private. Package members are always accessible within the current package.
javac.err.static.class=\
	The type {0} can''t be declared static. It is already top-level, since it is a member of a package.
javac.err.protected.class=\
	The type {0} can''t be made protected. Package members can either be public or local to the current package.
javac.err.recursive.constr=\
	Recursive constructor invocation: {0}.
javac.err.wrong.class=\
	File {0} does not contain {1} as expected, but {2}. Please remove the file, or make sure it appears in the correct subdirectory of the class path.
javac.err.wrong.source=\
	File {0} does not contain {1} as expected. Please adjust the class path so that the file does not appear in the {2}.
javac.err.class.not.found=\
	Class {0} not found in {1}.
javac.err.class.not.found.no.context=\
	Class {0} not found.
javac.err.package.not.found=\
	Package {0} not found in {1}.
javac.err.package.not.found.strong=\
	Package {0} not found.  Please adjust the classpath so that package {0} is accessible.
javac.err.class.package.conflict=\
	A type and a package cannot have the same name.  The name {0} cannot be used to name a class while the package {0} is accessible.
javac.err.package.class.conflict=\
	A type and a package cannot have the same name.  The name {0} cannot be used to name a package while the class {1} is accessible.
javac.err.package.class.conflict.strong=\
	The name {0} must refer to a package.  It is illegal for there to be an accessible class named {1} because types and packages cannot have the same name.  The class {1} should be renamed or taken off the classpath.
javac.err.illegal.mangled.name=\
	Invalid name {0} for {1}.
javac.err.class.and.package=\
	Ambiguous name: {0} is both a class and a package.
javac.err.throws.not.throwable=\
	{0} in throws clause must be a subclass of class java.lang.Throwable.
javac.err.throw.not.throwable=\
	Can''t throw {0}; it must be a subclass of class java.lang.Throwable.
javac.err.catch.not.throwable=\
	Can''t catch {0}; it must be a subclass of class java.lang.Throwable.
javac.err.initializer.exception=\
	Exception {0} can''t be thrown in initializer.
javac.err.cant.read=\
	Can''t read: {0}
javac.err.cant.write=\
	Can''t write: {0}
javac.err.fatal.error=\
	An error has occurred in the compiler; please file a bug report (http://bugreport.java.com/bugreport/).
javac.err.fatal.exception=\
	An exception has occurred in the compiler; please file a bug report (http://bugreport.java.com/bugreport/).
javac.err.no.inner.classes=\
	Support for inner classes has been disabled.
javac.err.uncaught.exception=\
	Exception {0} must be caught, or it must be declared in the throws clause of this method.
javac.err.constructor.exception=\
	Exception {0} must be caught, or it must be declared in the throws clause of this constructor.
javac.err.def.constructor.exception=\
	A default constructor cannot be created for this class because the constructor of its superclass throws the exception {0}.  Define the constructor for this class explicitly.
javac.err.catch.not.thrown=\
	Exception {0} is never thrown in the body of the corresponding try statement.
#warning:
javac.err.array.clone.supported=\
	Note: The cloning of an array does not throw any checked exceptions, and therefore does not require any catch clauses.  Please remove unused catch clauses, or if you wish to retain compatibility with older compilers, you may insert an artificial throw as follows:  if (false) throw new CloneNotSupportedException();
javac.err.no.outer.arg=\
	No enclosing instance of {0} is in scope; \
	an explicit one must be provided when creating {1}, \
	as in "outer. new Inner()" or "outer. super()".
javac.err.no.default.outer.arg=\
	No enclosing instance of {0} is in scope; \
	cannot create a default constructor for {1}.
javac.err.no.outer.base=\
	No enclosing instance of {0} is in scope; \
	an explicit one must be provided when accessing {1}, \
	as in "outer.member".
javac.err.inner.interface=\
	Member interfaces can only occur in interfaces and top-level classes.
javac.err.static.inner.class=\
	The type {0} can''t be static.  Static members can only occur in interfaces and top-level classes.
javac.err.static.inner.field=\
	Variable {0} can''t be static in {1}.  Only members of interfaces and top-level classes can be static.
javac.err.static.inner.method=\
	Method {0} can''t be static in {1}.  Only members of interfaces and top-level classes can be static.
javac.err.too.many.errors=\
	Too many errors.  (The limit on reported errors is {0}.)
javac.err.override.static.with.instance=\
	The instance method {0} declared in {1} cannot override the static \
	method of the same signature declared in {2}.  It is illegal to \
	override a static method.
javac.err.hide.instance.with.static=\
	The static method {0} declared in {1} cannot hide the instance \
	method of the same signature declared in {2}.  It is illegal to \
	hide an instance method.
javac.err.override.final.method=\
	The method {0} declared in {1} cannot override the final method of \
	the same signature declared in {2}.  Final methods cannot be \
	overridden.
javac.err.override.is.deprecated=\
	The method {0} declared in {1} is not deprecated, but \
	overrides a deprecated method of the \
	same signature declared in {2}.
javac.err.override.more.restrictive=\
	The method {0} declared in {1} cannot override the method of the \
	same signature declared in {2}.  The access modifier is made more \
	restrictive.
javac.err.override.different.return=\
	The method {0} declared in {1} cannot override the method of the \
	same signature declared in {2}.  They must have the same return \
	type.	
javac.err.override.incompatible.exceptions=\
	The method {0} declared in {1} cannot override the method of the \
	same signature declared in {2}.  Their throws clauses are \
	incompatible.
javac.err.meet.different.return=\
	The method {0} inherited from {1} is incompatible with the method of \
	the same signature inherited from {2}.  They must have the same \
	return type.
javac.err.nontrivial.meet=\
	The definitions of method {0} inherited from {1} and {2} are \
	compatible, but the combination of them is nontrivial and has not \
	been implemented.  As a workaround, declare {0} explicitly in this \
	class.
javac.err.method.too.long=\
	This code requires generating a method with more than \
	64K bytes.  Virtual machines may refuse the resulting class file.
#
javac.err.version.too.old=\
	The major version ''{0}'' is too old for this tool to understand.
javac.err.version.too.recent=\
	The major.minor version ''{0}'' is too recent for this tool \
	to understand.
#
benv.parsed_in=[parsed {0} in {1} ms]
benv.loaded_in=[loaded {0} in {1} ms]
benv.failed_to_close_class_path=failed to close class path: {0}
#
main.usage=\
Usage: {0} <options> <source files>\n\
\n\
where <options> includes:\n\
\ \ -g                     Generate all debugging info\n\
\ \ -g:none                Generate no debugging info\n\
\ \ -g:'{'lines,vars,source'}' Generate only some debugging info\n\
\ \ -O                     Optimize; may hinder debugging or enlarge class files\n\
\ \ -nowarn                Generate no warnings\n\
\ \ -verbose               Output messages about what the compiler is doing\n\
\ \ -deprecation           Output source locations where deprecated APIs are used\n\
\ \ -classpath <path>      Specify where to find user class files\n\
\ \ -sourcepath <path>     Specify where to find input source files\n\
\ \ -bootclasspath <path>  Override location of bootstrap class files\n\
\ \ -extdirs <dirs>        Override location of installed extensions\n\
\ \ -d <directory>         Specify where to place generated class files\n\
\ \ -encoding <encoding>   Specify character encoding used by source files\n\
\ \ -target <release>      Generate class files for specific VM version
#
main.unsupported.usage=\
\ \ -Xdepend         Recursively search for more recent source files to recompile\n\
\ \ -Xstdout         Send messages to System.out\n\
\ \ -Xverbosepath    Describe how paths and standard extensions were searched\n\
\ \ -J<runtime flag> Pass argument to the java interpreter\n\
\n\
The -X and -J options are non-standard and subject to change without notice.
#
main.conflicting.options=The options {0} and {1} may not be used at the same time.
main.option.already.seen=The {0} option may be specified no more than once.
main.option.requires.argument=The {0} option requires an argument.
main.bad.debug.option=The {0} option is not well formed.  Only specify "lines", "vars", and "source" separated by commas.
main.no.such.directory=The {0} directory does not exist.
main.no.such.option={0} is an invalid option or argument.
main.unknown.release=The release ''{0}'' is unknown to this compiler.
main.wrote=[wrote {0}]
main.errors={0} errors
main.1error=1 error
main.warnings={0} warnings
main.1warning=1 warning
main.done_in=[done in {0} ms]
main.no.memory=\
	The compiler has run out of memory.  Consider using the "-J-mx<number>" command line option to increase the maximum heap size.
main.stack.overflow=\
	The compiler has run out of stack space.  Consider using the "-J-oss<number>" command line option to increase the memory allocated for the Java stack.
main.path.msg=\
	[The source classpath is "{0}"]\n\
	[The library classpath is "{1}"]
javac.err.invalid.encoding.char=\
	The source file encoding may be different with this platform encoding. Please use -encoding option to adjust file encoding, or make sure source file converted to ASCII encoding.
