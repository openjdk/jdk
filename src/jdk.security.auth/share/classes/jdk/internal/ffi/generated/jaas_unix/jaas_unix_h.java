/*
 * Copyright (c) 2025, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

// Generated by jextract

package jdk.internal.ffi.generated.jaas_unix;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

@SuppressWarnings("restricted")
public class jaas_unix_h extends jaas_unix_h$shared {

    jaas_unix_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = jaas_unix_h.C_INT;

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jaas_unix_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid(void)
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid(void)
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid(void)
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid(void)
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jaas_unix_h.C_INT,
            jaas_unix_h.C_INT,
            jaas_unix_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int __gidsetsize, gid_t[])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int __gidsetsize, gid_t[])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int __gidsetsize, gid_t[])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int __gidsetsize, gid_t[])
     * }
     */
    public static int getgroups(int __gidsetsize, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", __gidsetsize, x1);
            }
            return (int)mh$.invokeExact(__gidsetsize, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jaas_unix_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid(void)
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid(void)
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid(void)
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid(void)
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpwuid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            jaas_unix_h.C_INT,
            jaas_unix_h.C_INT,
            jaas_unix_h.C_POINTER,
            jaas_unix_h.C_POINTER,
            jaas_unix_h.C_LONG,
            jaas_unix_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpwuid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)
     * }
     */
    public static FunctionDescriptor getpwuid_r$descriptor() {
        return getpwuid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)
     * }
     */
    public static MethodHandle getpwuid_r$handle() {
        return getpwuid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)
     * }
     */
    public static MemorySegment getpwuid_r$address() {
        return getpwuid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)
     * }
     */
    public static int getpwuid_r(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = getpwuid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpwuid_r", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}
