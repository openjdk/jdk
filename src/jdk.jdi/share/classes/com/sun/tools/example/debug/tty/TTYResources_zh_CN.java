/*
 * Copyright (c) 2001, 2023, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.tty;

/**
 * <p> This class represents the <code>ResourceBundle</code>
 * for the following package(s):
 *
 * <ol>
 * <li> com.sun.tools.example.debug.tty
 * </ol>
 *
 */
public class TTYResources_zh_CN extends java.util.ListResourceBundle {


    /**
     * Returns the contents of this <code>ResourceBundle</code>.
     *
     * <p>
     *
     * @return the contents of this <code>ResourceBundle</code>.
     */
    @Override
    public Object[][] getContents() {
        Object[][] temp = new Object[][] {
        // NOTE: The value strings in this file containing "{0}" are
        //       processed by the java.text.MessageFormat class.  Any
        //       single quotes appearing in these strings need to be
        //       doubled up.
        //
        // LOCALIZE THIS
        {"** classes list **", "** 类列表 **\n{0}"},
        {"** fields list **", "** 字段列表 **\n{0}"},
        {"** methods list **", "** 方法列表 **\n{0}"},
        {"*** Reading commands from", "*** 正在从{0}读取命令"},
        {"All threads resumed.", "已恢复所有线程。"},
        {"All threads suspended.", "已挂起所有线程。"},
        {"Argument is not defined for connector:", "没有为连接器{1}定义参数{0}"},
        {"Arguments match no method", "参数不与任何方法匹配"},
        {"Array:", "数组: {0}"},
        {"Array element is not a method", "数组元素不是方法"},
        {"Array index must be a integer type", "数组索引必须为整数类型"},
        {"base directory:", "基目录: {0}"},
        {"Breakpoint hit:", "断点命中: "},
        {"breakpoint", "断点{0}"},
        {"Breakpoints set:", "断点集:"},
        {"Breakpoints can be located only in classes.", "断点只能位于类中。{0}是接口或数组。"},
        {"Can only trace", "只能跟踪 'methods'、'method exit' 或 'method exits'"},
        {"cannot redefine existing connection", "{0}无法重新定义现有连接"},
        {"Cannot assign to a method invocation", "无法分配到方法调用"},
        {"Cannot specify command line with connector:", "无法指定带有连接器的命令行: {0}"},
        {"Cannot specify target vm arguments with connector:", "无法指定带有连接器的目标 VM 参数: {0}"},
        {"Class containing field must be specified.", "必须指定包含字段的类。"},
        {"Class:", "类: {0}"},
        {"Classic VM no longer supported.", "不再支持经典 VM。"},
        {"classpath:", "类路径: {0}"},
        {"colon mark", ":"},
        {"colon space", ": "},
        {"Command is not supported on the target VM", "目标 VM 不支持命令 ''{0}''"},
        {"Command is not supported on a read-only VM connection", "只读 VM 连接不支持命令 ''{0}''"},
        {"Command not valid until the VM is started with the run command", "在使用 ''run'' 命令启动 VM 前, 命令 ''{0}'' 是无效的"},
        {"Condition must be boolean", "条件必须是布尔型"},
        {"Connector and Transport name", "  连接器: {0}, 传输: {1}"},
        {"Connector argument nodefault", "    参数: {0} (无默认值)"},
        {"Connector argument default", "    参数: {0}, 默认值: {1}"},
        {"Connector description", "    说明: {0}"},
        {"Connector required argument nodefault", "    所需的参数: {0} (无默认值)"},
        {"Connector required argument default", "    所需的参数: {0}, 默认值: {1}"},
        {"Connectors available", "可用连接器为:"},
        {"Constant is not a method", "常量不是方法"},
        {"Could not open:", "无法打开: {0}"},
        {"Current method is native", "当前方法为本机方法"},
        {"Current thread died. Execution continuing...", "当前线程{0}已成为死线程。继续执行..."},
        {"Current thread isnt suspended.", "当前线程未挂起。"},
        {"Current thread not set.", "当前线程未设置。"},
        {"dbgtrace flag value must be an integer:", "dbgtrace 标记值必须为整数: {0}"},
        {"dbgtrace command value must be an integer:", "dbgtrace 命令值必须为整数：{0}"},
        {"Deferring.", "正在延迟{0}。\n将在加载类后设置。"},
        {"End of stack.", "堆栈结束。"},
        {"EOF", "EOF"},
        {"Error popping frame", "使帧出栈时出错 - {0}"},
        {"Error reading file", "读取 ''{0}'' 时出错 - {1}"},
        {"Error redefining class to file", "将{0}重新定义为{1}时出错 - {2}"},
        {"exceptionSpec all", "所有{0}"},
        {"exceptionSpec caught", "捕获的 {0}"},
        {"exceptionSpec uncaught", "未捕获的 {0}"},
        {"Exception in expression:", "表达式中出现异常错误: {0}"},
        {"Exception occurred caught", "出现异常错误: {0} (将在以下位置捕获: {1})"},
        {"Exception occurred uncaught", "出现异常错误: {0} (未捕获)"},
        {"Exceptions caught:", "出现这些异常错误时中断:"},
        {"Expected at, in, or an integer <thread_id>:", "应为 \"at\"、\"in\" 或以整数表示的 <thread_id>：{0}"},
        {"expr is null", "{0} = 空值"},
        {"expr is value", "{0} = {1}"},
        {"expr is value <collected>", "  {0} = {1} <已收集>"},
        {"Expression cannot be void", "表达式不能为空"},
        {"Expression must evaluate to an object", "表达式的计算结果必须为对象"},
        {"extends:", "扩展: {0}"},
        {"Extra tokens after breakpoint location", "端点位置后面有额外的标记"},
        {"Failed reading output", "无法读取子 Java 解释器的输出。"},
        {"Fatal error", "致命错误:"},
        {"Field access encountered before after", "字段 ({0}) 为{1}, 将为{2}: "},
        {"Field access encountered", "遇到字段 ({0}) 访问: "},
        {"Field to unwatch not specified", "未指定要取消监视的字段。"},
        {"Field to watch not specified", "未指定要监视的字段。"},
        {"GC Disabled for", "已对{0}禁用 GC:"},
        {"GC Enabled for", "已对{0}启用 GC:"},
        {"grouping begin character", "{"},
        {"grouping end character", "}"},
        {"Illegal Argument Exception", "非法参数异常错误"},
        {"Illegal connector argument", "非法连接器参数: {0}"},
        {"Illegal thread state", "非法线程状态"},
        {"Illegal thread state (virtual thread not suspended)", "非法线程状态（未挂起虚拟线程）"},
        {"implementor:", "实现者: {0}"},
        {"implements:", "实现: {0}"},
        {"Initializing progname", "正在初始化{0}..."},
        {"Input stream closed.", "输入流已关闭。"},
        {"Interface:", "接口: {0}"},
        {"Internal debugger error.", "内部调试器错误。"},
        {"Internal error: null ThreadInfo created", "内部错误: 创建了空值 ThreadInfo"},
        {"Internal error; unable to set", "内部错误; 无法设置{0}"},
        {"Internal exception during operation:", "操作期间出现内部异常错误:\n    {0}"},
        {"Internal exception:", "内部异常错误:"},
        {"Invalid argument type name", "参数类型名称无效"},
        {"Invalid assignment syntax", "赋值语法无效"},
        {"Invalid command syntax", "命令语法无效"},
        {"Invalid connect type", "连接类型无效"},
        {"Invalid consecutive invocations", "连续调用无效"},
        {"Invalid exception object", "异常错误对象无效"},
        {"Invalid line number specified", "指定的行号无效"},
        {"Invalid <method_name> specification:", "<method_name> 规范无效：{0}"},
        {"Invalid option on class command", "类命令的选项无效"},
        {"invalid option", "选项无效: {0}"},
        {"Invalid thread status.", "线程状态无效。"},
        {"Invalid <thread_id>:", "<thread_id> 无效：{0}"},
        {"Invalid transport name:", "传输名称无效: {0}"},
        {"Invalid <class>.<method_name> specification", "<class>.<method_name> 规范无效"},
        {"I/O exception occurred:", "出现 I/O 异常错误: {0}"},
        {"is an ambiguous method name in", "\"{0}\" 在 \"{1}\" 中是不明确的方法名称"},
        {"is an invalid line number for",  "{0,number,integer} 是{1}的无效行号"},
        {"is not a valid class name", "\"{0}\" 不是有效的类名。"},
        {"is not a valid field name", "\"{0}\" 不是有效的字段名。"},
        {"is not a valid id or class name", "\"{0}\" 不是有效的 ID 或类名。"},
        {"is not a valid line number or method name for", "\"{0}\" 不是类 \"{1}\" 的有效行号或方法名"},
        {"is not a valid method name", "\"{0}\" 不是有效的方法名。"},
        {"is not a valid thread id", "\"{0}\" 不是有效的线程 ID。"},
        {"is not a valid threadgroup name", "\"{0}\" 不是有效的线程组名称。"},
        {"jdb prompt with no current thread", "> "},
        {"jdb prompt thread name and current stack frame", "{0}[{1,number,integer}] "},
        {"killed", "{0}已终止"},
        {"killing thread:", "正在终止线程: {0}"},
        {"Line number information not available for", "此位置的源行号不可用。"},
        {"line number", ":{0,number,integer}"},
        {"list field typename and name", "{0} {1}\n"},
        {"list field typename and name inherited", "{0} {1} (继承自{2})\n"},
        {"list field typename and name hidden", "{0} {1} (隐藏)\n"},
        {"Listening at address:", "监听地址: {0}"},
        {"Local variable information not available.", "本地变量信息不可用。请使用 -g 编译以生成变量信息"},
        {"Local variables:", "本地变量:"},
        {"<location unavailable>", "<位置不可用>"},
        {"location", "\"线程={0}\", {1}"},
        {"locationString", "{0}.{1}(), 行={2,number,integer} bci={3,number,integer}"},
        {"Main class and arguments must be specified", "必须指定主类和参数"},
        {"Method arguments:", "方法参数:"},
        {"Method entered:", "已进入方法："},
        {"Method exited:",  "已退出方法"},
        {"Method exitedValue:", "已退出方法: 返回值 = {0}, "},
        {"Method is overloaded; specify arguments", "已重载方法{0}; 请指定参数"},
        {"minus version", "这是{0}版本 {1,number,integer}.{2,number,integer} (Java SE 版本 {3})"},
        {"Missing at or in", "缺少 \"at\" 或 \"in\""},
        {"Monitor information for thread", "监视线程{0}的信息:"},
        {"Monitor information for expr", "监视{0} ({1}) 的信息:"},
        {"More than one class named", "多个类的名称为: ''{0}''"},
        {"native method", "本机方法"},
        {"nested:", "嵌套: {0}"},
        {"No attach address specified.", "未指定附加地址。"},
        {"No breakpoints set.", "未设置断点。"},
        {"No class named", "没有名为 ''{0}'' 的类"},
        {"No class specified.", "未指定类。"},
        {"No classpath specified.", "未指定类路径。"},
        {"No code at line", "{1}中的行 {0,number,integer} 处没有代码"},
        {"No connect specification.", "没有连接规范。"},
        {"No connector named:", "没有名为{0}的连接器"},
        {"No current thread", "没有当前线程"},
        {"No default thread specified:", "未指定默认线程: 请先使用 \"thread\" 命令。"},
        {"No exception object specified.", "未指定异常错误对象。"},
        {"No exceptions caught.", "未捕获到异常错误。"},
        {"No expression specified.", "未指定表达式。"},
        {"No field in", "{1}中没有字段{0}"},
        {"No frames on the current call stack", "当前调用堆栈上没有帧"},
        {"No linenumber information for", "{0}没有行号信息。请尝试在启用调试的情况下编译。"},
        {"No local variables", "没有本地变量"},
        {"No method in", "{1}中没有方法{0}"},
        {"No method specified.", "未指定方法。"},
        {"No monitor numbered:", "没有编号为 {0} 的监视器"},
        {"No monitors owned", "  不拥有监视器"},
        {"No object specified.", "未指定对象。"},
        {"No objects specified.", "未指定对象。"},
        {"No save index specified.", "未指定保存索引。"},
        {"No saved values", "没有保存的值"},
        {"No source information available for:", "没有可用于{0}的源信息"},
        {"No sourcedebugextension specified", "未指定 SourceDebugExtension"},
        {"No sourcepath specified.", "未指定源路径。"},
        {"No thread specified.", "未指定线程。"},
        {"No VM connected", "未连接 VM"},
        {"No waiters", "  没有等待进程"},
        {"not a class", "{0}不是类"},
        {"Not a monitor number:", "不是监视器编号: ''{0}''"},
        {"not found (try the full name)", "找不到{0} (请尝试使用全名)"},
        {"Not found:", "找不到: {0}"},
        {"not found", "找不到{0}"},
        {"Not owned", "  不拥有"},
        {"Not waiting for a monitor", "  未等待监视器"},
        {"Nothing suspended.", "未挂起任何对象。"},
        {"object description and id", "({0}){1}"},
        {"Operation is not supported on the current frame", "当前框架不支持该操作"},
        {"operation not yet supported", "尚不支持该操作"},
        {"Owned by:", "  拥有者: {0}, 条目计数: {1,number,integer}"},
        {"Owned monitor:", "  拥有的监视器: {0}"},
        {"Parse exception:", "语法分析异常错误: {0}"},
        {"printclearcommandusage", "用法：clear <class>:<line_number> 或\n      clear <class>.<method_name>[(argument_type,...)]"},
        {"printstopcommandusage",
         "用法：stop [go|thread] [<thread_id>] <at|in> <location>\n  如果指定 \"go\"，则在停止后立即恢复\n  如果指定 \"thread\"，则仅挂起在其中停止的线程\n  如果既未指定 \"go\" 也未指定 \"thread\"，则挂起所有线程\n  如果指定以整数表示的 <thread_id>，则仅在指定的线程中停止\n  \"at\" 和 \"in\" 的含义相同\n  <location> 可以是行号或方法：\n    <class_id>:<line_number>\n    <class_id>.<method>[(argument_type,...)]"
        },
        {"Removed:", "已删除: {0}"},
        {"repeat is on", "重复处于启用状态"},
        {"repeat is off", "重复处于禁用状态"},
        {"repeat usage", "用法：repeat <on|off>"},
        {"Requested stack frame is no longer active:", "请求的堆栈帧不再有效: {0,number,integer}"},
        {"run <args> command is valid only with launched VMs", "'run <args>' 命令仅对启动的 VM 有效"},
        {"run", "运行{0}"},
        {"saved", "{0}已保存"},
        {"Set deferred", "设置延迟的{0}"},
        {"Set", "设置{0}"},
        {"Source file not found:", "找不到源文件: {0}"},
        {"source line number and line", "{0,number,integer}    {1}"},
        {"source line number current line and line", "{0,number,integer} => {1}"},
        {"sourcedebugextension", "SourceDebugExtension -- {0}"},
        {"Specify class and method", "指定类和方法"},
        {"Specify classes to redefine", "指定要重新定义的类"},
        {"Specify file name for class", "指定类{0}的文件名"},
        {"stack frame dump with pc", "  [{0,number,integer}] {1}.{2} ({3}), pc = {4}"},
        {"stack frame dump", "  [{0,number,integer}] {1}.{2} ({3})"},
        {"Step completed:", "已完成的步骤: "},
        {"Stopping due to deferred breakpoint errors.", "由于延迟断点错误而停止。\n"},
        {"subclass:", "子类: {0}"},
        {"subinterface:", "子接口: {0}"},
        {"tab", "\t{0}"},
        {"Target VM failed to initialize.", "无法初始化目标 VM。"},
        {"The application exited", "应用程序已退出"},
        {"The application has been disconnected", "应用程序已断开连接"},
        {"The gc command is no longer necessary.", "不再需要 'gc' 命令。\n所有对象已照常进行垃圾收集。请使用 'enablegc' 和 'disablegc'\n命令来控制各个对象的垃圾收集。"},
        {"The load command is no longer supported.", "不再支持 'load' 命令。"},
        {"The memory command is no longer supported.", "不再支持 'memory' 命令。"},
        {"The VM does not use paths", "VM 不使用路径"},
        {"Thread is not running (no stack).", "线程未运行 (没有堆栈)。"},
        {"Thread number not specified.", "未指定线程编号。"},
        {"Thread:", "{0}:"},
        {"Thread Group:", "组{0}:"},
        {"Thread description name unknownStatus BP",  "  {0} {1}未知 (在断点处)"},
        {"Thread description name unknownStatus",     "  {0} {1}未知"},
        {"Thread description name zombieStatus BP",   "  {0} {1}处于僵死状态 (在断点处)"},
        {"Thread description name zombieStatus",      "  {0} {1}处于僵死状态"},
        {"Thread description name runningStatus BP",  "  {0} {1}正在运行 (在断点处)"},
        {"Thread description name runningStatus",     "  {0} {1}正在运行"},
        {"Thread description name sleepingStatus BP", "  {0} {1}正在休眠 (在断点处)"},
        {"Thread description name sleepingStatus",    "  {0} {1}正在休眠"},
        {"Thread description name waitingStatus BP",  "  {0} {1}正在等待监视器 (在断点处)"},
        {"Thread description name waitingStatus",     "  {0} {1}正在等待监视器"},
        {"Thread description name condWaitstatus BP", "  {0} {1}正在执行条件等待 (在断点处)"},
        {"Thread description name condWaitstatus",    "  {0} {1}正在执行条件等待"},
        {"Thread has been resumed", "已恢复线程"},
        {"Thread not suspended", "未挂起线程"},
        {"thread group number description name", "{0,number,integer}。{1} {2}"},
        {"<thread_id> option not valid until the VM is started with the run command",
         "在使用 run 命令启动 VM 前，<thread_id> 选项无效"},
        {"Threads must be suspended", "必须挂起线程"},
        {"trace method exit in effect for", "正在对{0}实行 trace method exit"},
        {"trace method exits in effect", "正在实行 trace method exits"},
        {"trace methods in effect", "正在实行 trace methods"},
        {"trace go method exit in effect for", "正在对{0}实行 trace go method exit"},
        {"trace go method exits in effect", "正在实行 trace go method exits"},
        {"trace go methods in effect", "正在实行 trace go methods"},
        {"trace not in effect", "未实行 trace"},
        {"Unable to attach to target VM.", "无法附加到目标 VM。"},
        {"Unable to display process output:", "无法显示进程输出: {0}"},
        {"Unable to launch target VM.", "无法启动目标 VM。"},
        {"Unable to set deferred", "无法设置延迟的{0}: {1}"},
        {"Unable to set main class and arguments", "无法设置主类和参数"},
        {"Unable to set", "无法设置{0}: {1}"},
        {"Unexpected event type", "意外的事件类型: {0}"},
        {"unknown", "未知"},
        {"Unmonitoring", "取消监视{0} "},
        {"Unrecognized command.  Try help...", "无法识别的命令: ''{0}''。请尝试获得帮助..."},
        {"Usage: catch exception", "用法: catch [uncaught|caught|all] <class id>|<class pattern>"},
        {"Usage: ignore exception", "用法: ignore [uncaught|caught|all] <class id>|<class pattern>"},
        {"Usage: down [n frames]", "用法: down [n frames]"},
        {"Usage: kill <thread id> <throwable>", "用法: kill <thread id> <throwable>"},
        {"Usage: read <command-filename>", "用法: read <command-filename>"},
        {"Usage: unmonitor <monitor#>", "用法: unmonitor <monitor#>"},
        {"Usage: up [n frames]", "用法: up [n frames]"},
        {"Use java minus X to see", "使用 'java -X' 可以查看可用的非标准选项"},
        {"VM already running. use cont to continue after events.", "VM 已在运行。请使用 'cont' 以在事件结束后继续。"},
        {"VM Started:", "VM 已启动: "},
        {"vmstartexception", "VM 启动异常错误: {0}"},
        {"Waiting for monitor:", "   正在等待监视器: {0}"},
        {"Waiting thread:", " 正在等待线程: {0}"},
        {"watch accesses of", "监视{0}.{1}的访问"},
        {"watch modification of", "监视{0}.{1}的修改"},
        {"zz help text",
             "** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程组中的线程。如果未指定，则使用当前线程组。\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 将当前线程组设置为 <name>\nthreadgroup               -- 将当前线程组设置回顶级线程组\n\nstop [go|thread] [<thread_id>] <at|in> <location>\n                          -- 设置断点\n                          -- 如果未提供任何选项，则将打印当前断点列表\n                          -- 如果指定 \"go\"，则在停止后立即恢复\n                          -- 如果指定 \"thread\"，则仅挂起在其中停止的线程\n                          -- 如果既未指定 \"go\" 也未指定 \"thread\"，则挂起所有线程\n                          -- 如果指定以整数表示的 <thread_id>，则仅在指定的线程中停止\n                          -- \"at\" 和 \"in\" 的含义相同\n                          -- <location> 可以是行号或方法：\n                          --   <class_id>:<line_number>\n                          --   <class_id>.<method>[(argument_type,...)]\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\n下一步                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\nrepeat                    -- 显示是否启用了 GDB 样式的空命令重复\nrepeat <on|off>           -- 启用/禁用 GDB 样式的重复\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\ndbgtrace [flag]           -- 与 dbgtrace 命令行选项相同\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中"},
        {"zz usage text",
             "用法：{0} <options> <class> <arguments>\n\n其中，选项包括：\n    -? -h --help -help 输出此帮助消息并退出\n    -sourcepath <由 \"{1}\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到在指定地址运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 ''run'' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出用于调试 {0} 的信息\n    -trackallthreads  跟踪所有线程，包括虚拟线程。\n    -tclient          在 HotSpot(TM) 客户端编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n    -R<option>        如果由 jdb 启动，则将 <option> 转发到被调试进程，否则忽略\n\n由 jdb 启动时转发到被调试进程的选项（使用速记符，而不使用 -R）：\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \"{1}\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助，请在 {0} 提示下键入 ''help''"},
        // END OF MATERIAL TO LOCALIZE
        };

        return temp;
    }
}
