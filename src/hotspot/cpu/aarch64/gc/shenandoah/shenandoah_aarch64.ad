//
// Copyright (c) 2018, Red Hat, Inc. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

source_hpp %{
#include "gc/shenandoah/shenandoahBarrierSet.hpp"
#include "gc/shenandoah/shenandoahBarrierSetAssembler.hpp"
%}

source %{

#include "gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.hpp"
#include "gc/shenandoah/c2/shenandoahBarrierSetC2.hpp"

static void satb_barrier(MacroAssembler* masm,
                         const MachNode* node,
                         Register addr,
                         Register pre_val,
                         RegSet preserve = RegSet(),
                         RegSet no_preserve = RegSet()) {
  if (!ShenandoahSATBBarrierStubC2::needs_barrier(node)) {
    return;
  }
  Assembler::InlineSkippedInstructionsCounter skip_counter(masm);
  ShenandoahBarrierSetAssembler* bsasm = ShenandoahBarrierSet::barrier_set()->assembler();
  ShenandoahSATBBarrierStubC2* const stub = ShenandoahSATBBarrierStubC2::create(node, addr, pre_val);
  for (RegSetIterator<Register> reg = preserve.begin(); *reg != noreg; ++reg) {
    stub->preserve(*reg);
  }
  for (RegSetIterator<Register> reg = no_preserve.begin(); *reg != noreg; ++reg) {
    stub->dont_preserve(*reg);
  }
  bsasm->satb_barrier_c2(masm, addr, pre_val, stub);
}

%}

instruct storeP_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreP mem src));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "str  $src, $mem\t# ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    __ str($src$$Register, $mem$$Register);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct storePVolatile_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreP mem src));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "stlr  $src, $mem\t# ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    __ stlr($src$$Register, $mem$$Register);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct storeN_shenandoah(indirect mem, iRegN src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem src));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "strw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    __ strw($src$$Register, $mem$$Register);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct storeNVolatile_shenandoah(indirect mem, iRegN src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem src));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "stlrw  $src, $mem\t# compressed ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    __ stlrw($src$$Register, $mem$$Register);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct encodePAndStoreN_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(UseShenandoahGC && !needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(INSN_COST);
  format %{ "encode_heap_oop $tmp, $src\n\t"
            "strw  $tmp, $mem\t# compressed ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    if ((barrier_data() & ShenandoahBarrierCardMarkNotNull) == 0) {
      __ encode_heap_oop($tmp$$Register, $src$$Register);
    } else {
      __ encode_heap_oop_not_null($tmp$$Register, $src$$Register);
    }
    __ strw($tmp$$Register, $mem$$Register);
  %}
  ins_pipe(istore_reg_mem);
%}

instruct encodePAndStoreNVolatile_shenandoah(indirect mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set mem (StoreN mem (EncodeP src)));
  predicate(UseShenandoahGC && needs_releasing_store(n) && n->as_Store()->barrier_data() != 0);
  effect(TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "encode_heap_oop $tmp, $src\n\t"
            "stlrw  $tmp, $mem\t# compressed ptr" %}
  ins_encode %{
    satb_barrier(masm, this,
                 $mem$$Register /* obj */,
                 $tmp$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $src$$Register) /* preserve */);
    if ((barrier_data() & ShenandoahBarrierCardMarkNotNull) == 0) {
      __ encode_heap_oop($tmp$$Register, $src$$Register);
    } else {
      __ encode_heap_oop_not_null($tmp$$Register, $src$$Register);
    }
    __ stlrw($tmp$$Register, $mem$$Register);
  %}
  ins_pipe(pipe_class_memory);
%}

instruct compareAndSwapP_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{

  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);

  effect(TEMP_DEF res, KILL cr);

  format %{
    "cmpxchg_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}

  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ false, /*release*/ true, /*weak*/ false, /*is_cae*/ false);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapN_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{

  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);

  effect(TEMP_DEF res, TEMP tmp, KILL cr);

  format %{
    "cmpxchgw_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}

  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ false, /*release*/ true, /*weak*/ false, /*is_cae*/ false);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapPAcq_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{

  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);

  effect(TEMP_DEF res, KILL cr);

  format %{
    "cmpxchg_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}

  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ true, /*release*/ true, /*weak*/ false, /*is_cae*/ false);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndSwapNAcq_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{

  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);

  effect(TEMP_DEF res, TEMP tmp, KILL cr);

 format %{
    "cmpxchgw_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
 %}

  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ true, /*release*/ true, /*weak*/ false, /*is_cae*/ false);
  %}

  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeN_shenandoah(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp, KILL cr);
  format %{
    "cmpxchgw_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                     /*acquire*/ false, /*release*/ true, /*weak*/ false, /*is_cae*/ true);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeP_shenandoah(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ false, /*release*/ true, /*weak*/ false, /*is_cae*/ true);
   %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeNAcq_shenandoah(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp, KILL cr);
  format %{
    "cmpxchgw_acq_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ true, /*release*/ true, /*weak*/ false, /*is_cae*/ true);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangePAcq_shenandoah(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_acq_shenandoah $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                   /*acquire*/ true, /*release*/ true, /*weak*/ false, /*is_cae*/ true);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapN_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp, KILL cr);
  format %{
    "cmpxchgw_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ false, /*release*/ true, /*weak*/ true, /*is_cae*/ false);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapP_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(2 * VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_shenandoah $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                      /*acquire*/ false, /*release*/ true, /*weak*/ true, /*is_cae*/ false);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapNAcq_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegPNoSp tmp, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, TEMP tmp, KILL cr);
  format %{
    "cmpxchgw_acq_shenandoah $res = $mem, $oldval, $newval\t# (narrow oop, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    guarantee(UseCompressedOops, "must be compressed oops");
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $oldval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                   RegSet::of($res$$Register) /* no_preserve */);
    }
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                   /*acquire*/ true, /*release*/ true, /*weak*/ true, /*is_cae*/ false);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapPAcq_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  predicate(needs_acquiring_load_exclusive(n));
  predicate(UseShenandoahGC && n->as_LoadStore()->barrier_data() != 0);
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_acq_shenandoah $res = $mem, $oldval, $newval\t# (ptr, weak) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    guarantee($mem$$index == -1 && $mem$$disp == 0, "impossible encoding");
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $oldval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $oldval$$Register, $newval$$Register) /* preserve */,
                 RegSet::of($res$$Register) /* no_preserve */);
    ShenandoahBarrierSet::assembler()->cmpxchg_oop_c2(this, masm, $mem$$base$$Register, $oldval$$Register, $newval$$Register, $res$$Register,
                                                   /*acquire*/ true, /*release*/ true, /*weak*/ true, /*is_cae*/ false);
  %}
  ins_pipe(pipe_slow);
%}

instruct getAndSetP_shenandoah(indirect mem, iRegP newval, iRegPNoSp preval, rFlagsReg cr)
%{
  match(Set preval (GetAndSetP mem newval));
  predicate(UseShenandoahGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP preval, KILL cr);
  ins_cost(2 * VOLATILE_REF_COST);
  format %{ "atomic_xchg  $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    __ atomic_xchg($preval$$Register, $newval$$Register, $mem$$Register);
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $preval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) /* preserve */);
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetPAcq_shenandoah(indirect mem, iRegP newval, iRegPNoSp preval, rFlagsReg cr)
%{
  match(Set preval (GetAndSetP mem newval));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP preval, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchg_acq  $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    __ atomic_xchgal($preval$$Register, $newval$$Register, $mem$$Register);
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $preval$$Register /* pre_val */,
                 RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) /* preserve */);
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetN_shenandoah(indirect mem, iRegN newval, iRegNNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetN mem newval));
  predicate(UseShenandoahGC && !needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP preval, TEMP tmp, KILL cr);
  ins_cost(2 * VOLATILE_REF_COST);
  format %{ "atomic_xchgw $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    __ atomic_xchgw($preval$$Register, $newval$$Register, $mem$$Register);
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $preval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) /* preserve */);
    }
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetNAcq_shenandoah(indirect mem, iRegN newval, iRegNNoSp preval, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set preval (GetAndSetN mem newval));
  predicate(UseShenandoahGC && needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() != 0);
  effect(TEMP preval, TEMP tmp, KILL cr);
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchgw_acq $preval, $newval, [$mem]" %}
  ins_encode %{
    assert_different_registers($mem$$Register, $newval$$Register);
    __ atomic_xchgalw($preval$$Register, $newval$$Register, $mem$$Register);
    if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $preval$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */,
                   RegSet::of($mem$$Register, $preval$$Register, $newval$$Register) /* preserve */);
    }
  %}
  ins_pipe(pipe_serial);
%}

instruct loadP_shenandoah(iRegPNoSp dst, indirect mem, rFlagsReg cr)
%{
  // This instruction does not need an acquiring counterpart because it is only
  // used for reference loading (Reference::get()). The same holds for g1LoadN.
  match(Set dst (LoadP mem));
  predicate(UseShenandoahGC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP dst, KILL cr);
  ins_cost(4 * INSN_COST);
  format %{ "ldr  $dst, $mem\t# ptr" %}
  ins_encode %{
    __ ldr($dst$$Register, $mem$$Register);
    satb_barrier(masm, this,
                 noreg /* obj */,
                 $dst$$Register /* pre_val */);
  %}
  ins_pipe(iload_reg_mem);
%}

instruct loadN_shenandoah(iRegNNoSp dst, indirect mem, iRegPNoSp tmp, rFlagsReg cr)
%{
  match(Set dst (LoadN mem));
  predicate(UseShenandoahGC && !needs_acquiring_load(n) && n->as_Load()->barrier_data() != 0);
  effect(TEMP dst, TEMP tmp, KILL cr);
  ins_cost(4 * INSN_COST);
  format %{ "ldrw  $dst, $mem\t# compressed ptr" %}
  ins_encode %{
    __ ldrw($dst$$Register, $mem$$Register);
  if (ShenandoahSATBBarrierStubC2::needs_barrier(this)) {
      __ decode_heap_oop($tmp$$Register, $dst$$Register);
      satb_barrier(masm, this,
                   noreg /* obj */,
                   $tmp$$Register /* pre_val */);
    }
  %}
  ins_pipe(iload_reg_mem);
%}
