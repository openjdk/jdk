// Copyright (c) 2020, 2025, Oracle and/or its affiliates. All rights reserved.
// Copyright (c) 2016, 2021, Red Hat Inc. All rights reserved.
// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// This code is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License version 2 only, as
// published by the Free Software Foundation.
//
// This code is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// version 2 for more details (a copy is included in the LICENSE file that
// accompanied this code).
//
// You should have received a copy of the GNU General Public License version
// 2 along with this work; if not, write to the Free Software Foundation,
// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
//
// Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
// or visit www.oracle.com if you need additional information or have any
// questions.
//
//

// BEGIN This file is automatically generated. Do not edit --------------

// Sundry CAS operations.  Note that release is always true,
// regardless of the memory ordering of the CAS.  This is because we
// need the volatile case to be sequentially consistent but there is
// no trailing StoreLoad barrier emitted by C2.  Unfortunately we
// can't check the type of memory ordering here, so we always emit a
// STLXR.

// This section is generated from aarch64_atomic_ad.m4


instruct compareAndExchangeB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgb $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
    __ sxtbw($res$$Register, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgs $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
    __ sxthw($res$$Register, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgw $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeL(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeN(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndExchangeB mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgb_acq $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
    __ sxtbw($res$$Register, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndExchangeS mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgs_acq $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
    __ sxthw($res$$Register, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndExchangeI mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgw_acq $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeLAcq(iRegLNoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndExchangeL mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_acq $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangeNAcq(iRegNNoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndExchangeN mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));
  match(Set res (CompareAndExchangeP mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(TEMP_DEF res, KILL cr);
  format %{
    "cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, $res$$Register);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapB mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgb $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapS mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgs $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapI mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  match(Set res (CompareAndSwapL mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndSwapB mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgb_acq $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndSwapS mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgs_acq $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndSwapI mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_acq $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (CompareAndSwapL mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_acq $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);
  match(Set res (CompareAndSwapN mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_acq $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct compareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));
  match(Set res (CompareAndSwapP mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_acq $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ false, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgb_weak $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgs_weak $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_weak $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_weak $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_weak $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  ins_cost(2*VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_weak $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ false, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (WeakCompareAndSwapB mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgb_acq_weak $res = $mem, $oldval, $newval\t# (byte) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::byte, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (WeakCompareAndSwapS mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgs_acq_weak $res = $mem, $oldval, $newval\t# (short) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::halfword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (WeakCompareAndSwapI mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_acq_weak $res = $mem, $oldval, $newval\t# (int) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set res (WeakCompareAndSwapL mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_acq_weak $res = $mem, $oldval, $newval\t# (long) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);
  match(Set res (WeakCompareAndSwapN mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchgw_acq_weak $res = $mem, $oldval, $newval\t# (narrow oop) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::word, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct weakCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{
  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));
  match(Set res (WeakCompareAndSwapP mem (Binary oldval newval)));
  ins_cost(VOLATILE_REF_COST);
  effect(KILL cr);
  format %{
    "cmpxchg_acq_weak $res = $mem, $oldval, $newval\t# (ptr) if $mem == $oldval then $mem <-- $newval"
    "csetw $res, EQ\t# $res <-- (EQ ? 1 : 0)"
  %}
  ins_encode %{
    __ cmpxchg($mem$$Register, $oldval$$Register, $newval$$Register,
               Assembler::xword, /*acquire*/ true, /*release*/ true,
               /*weak*/ true, noreg);
    __ csetw($res$$Register, Assembler::EQ);
  %}
  ins_pipe(pipe_slow);
%}

instruct getAndSetI(indirect mem, iRegI newval, iRegINoSp oldval) %{
  match(Set oldval (GetAndSetI mem newval));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "atomic_xchgw  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgw($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetL(indirect mem, iRegL newval, iRegLNoSp oldval) %{
  match(Set oldval (GetAndSetL mem newval));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "atomic_xchg  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchg($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetN(indirect mem, iRegN newval, iRegNNoSp oldval) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set oldval (GetAndSetN mem newval));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "atomic_xchgw  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgw($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetP(indirect mem, iRegP newval, iRegPNoSp oldval) %{
  predicate(n->as_LoadStore()->barrier_data() == 0);
  match(Set oldval (GetAndSetP mem newval));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "atomic_xchg  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchg($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetIAcq(indirect mem, iRegI newval, iRegINoSp oldval) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set oldval (GetAndSetI mem newval));
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchgw_acq  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgalw($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetLAcq(indirect mem, iRegL newval, iRegLNoSp oldval) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set oldval (GetAndSetL mem newval));
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchg_acq  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgal($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetNAcq(indirect mem, iRegN newval, iRegNNoSp oldval) %{
  predicate(needs_acquiring_load_exclusive(n) && n->as_LoadStore()->barrier_data() == 0);
  match(Set oldval (GetAndSetN mem newval));
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchgw_acq  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgalw($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndSetPAcq(indirect mem, iRegP newval, iRegPNoSp oldval) %{
  predicate(needs_acquiring_load_exclusive(n) && (n->as_LoadStore()->barrier_data() == 0));
  match(Set oldval (GetAndSetP mem newval));
  ins_cost(VOLATILE_REF_COST);
  format %{ "atomic_xchg_acq  $oldval, $newval, [$mem]" %}
  ins_encode %{
    __ atomic_xchgal($oldval$$Register, $newval$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddI(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{
  match(Set newval (GetAndAddI mem incr));
  ins_cost(2*VOLATILE_REF_COST+1);
  format %{ "get_and_addI $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addw($newval$$Register, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddIAcq(indirect mem, iRegINoSp newval, iRegIorL2I incr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set newval (GetAndAddI mem incr));
  ins_cost(VOLATILE_REF_COST+1);
  format %{ "get_and_addI_acq $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addalw($newval$$Register, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddINoRes(indirect mem, Universe dummy, iRegIorL2I incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddI mem incr));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "get_and_addI noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addw(noreg, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddIAcqNoRes(indirect mem, Universe dummy, iRegIorL2I incr) %{
  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));
  match(Set dummy (GetAndAddI mem incr));
  ins_cost(VOLATILE_REF_COST);
  format %{ "get_and_addI_acq noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addalw(noreg, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddIConst(indirect mem, iRegINoSp newval, immIAddSub incr) %{
  match(Set newval (GetAndAddI mem incr));
  ins_cost(2*VOLATILE_REF_COST+1);
  format %{ "get_and_addI $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addw($newval$$Register, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddIAcqConst(indirect mem, iRegINoSp newval, immIAddSub incr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set newval (GetAndAddI mem incr));
  ins_cost(VOLATILE_REF_COST+1);
  format %{ "get_and_addI_acq $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addalw($newval$$Register, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddINoResConst(indirect mem, Universe dummy, immIAddSub incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddI mem incr));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "get_and_addI noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addw(noreg, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddIAcqNoResConst(indirect mem, Universe dummy, immIAddSub incr) %{
  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));
  match(Set dummy (GetAndAddI mem incr));
  ins_cost(VOLATILE_REF_COST);
  format %{ "get_and_addI_acq noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addalw(noreg, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddL(indirect mem, iRegLNoSp newval, iRegL incr) %{
  match(Set newval (GetAndAddL mem incr));
  ins_cost(2*VOLATILE_REF_COST+1);
  format %{ "get_and_addL $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_add($newval$$Register, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLAcq(indirect mem, iRegLNoSp newval, iRegL incr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set newval (GetAndAddL mem incr));
  ins_cost(VOLATILE_REF_COST+1);
  format %{ "get_and_addL_acq $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addal($newval$$Register, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLNoRes(indirect mem, Universe dummy, iRegL incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddL mem incr));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "get_and_addL noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_add(noreg, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLAcqNoRes(indirect mem, Universe dummy, iRegL incr) %{
  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));
  match(Set dummy (GetAndAddL mem incr));
  ins_cost(VOLATILE_REF_COST);
  format %{ "get_and_addL_acq noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addal(noreg, $incr$$Register, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLConst(indirect mem, iRegLNoSp newval, immLAddSub incr) %{
  match(Set newval (GetAndAddL mem incr));
  ins_cost(2*VOLATILE_REF_COST+1);
  format %{ "get_and_addL $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_add($newval$$Register, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLAcqConst(indirect mem, iRegLNoSp newval, immLAddSub incr) %{
  predicate(needs_acquiring_load_exclusive(n));
  match(Set newval (GetAndAddL mem incr));
  ins_cost(VOLATILE_REF_COST+1);
  format %{ "get_and_addL_acq $newval, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addal($newval$$Register, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLNoResConst(indirect mem, Universe dummy, immLAddSub incr) %{
  predicate(n->as_LoadStore()->result_not_used());
  match(Set dummy (GetAndAddL mem incr));
  ins_cost(2*VOLATILE_REF_COST);
  format %{ "get_and_addL noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_add(noreg, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}

instruct getAndAddLAcqNoResConst(indirect mem, Universe dummy, immLAddSub incr) %{
  predicate(n->as_LoadStore()->result_not_used() && needs_acquiring_load_exclusive(n));
  match(Set dummy (GetAndAddL mem incr));
  ins_cost(VOLATILE_REF_COST);
  format %{ "get_and_addL_acq noreg, [$mem], $incr" %}
  ins_encode %{
    __ atomic_addal(noreg, $incr$$constant, as_Register($mem$$base));
  %}
  ins_pipe(pipe_serial);
%}
