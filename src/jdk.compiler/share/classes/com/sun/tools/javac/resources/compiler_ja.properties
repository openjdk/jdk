#
# Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The simple types currently in use are:
#
# annotation        annotation compound
# boolean           true or false
# diagnostic        a sub-message; see compiler.misc.*
# fragment          similar to 'message segment', but with more specific type
# modifier          a Java modifier; e.g. public, private, protected
# file              a file URL
# file object       a file URL - similar to 'file' but typically used for source/class files, hence more specific
# flag              a Flags.Flag instance
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# path              a path
# profile           a profile name
# source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
# source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
# string            a general string
# symbol            the name of a declared type
# symbol kind       the kind of a symbol (i.e. method, variable)
# kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
# target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# url               a URL
# object            a Java object (unspecified)
# unused            the value is not used in this message
#
# The following compound types are also used:
#
# collection of X   a comma-separated collection of items; e.g. collection of type
# list of X         a comma-separated list of items; e.g. list of type
# set of X          a comma-separated set of items; e.g. set of modifier
#
# These may be composed:
#
# list of type or message segment
#
# The following type aliases are supported:
#
# message segment --> diagnostic or fragment
# file name --> file, path or file object
#
# Custom comments are supported in parenthesis i.e.
#
# number (classfile major version)
#
# These comments are used internally in order to generate an enum-like class declaration containing
# a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
# by javac code to build diagnostics in a type-safe fashion.
#
# In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated={0}はabstractです。インスタンスを生成することはできません

compiler.err.abstract.meth.cant.have.body=abstractメソッドが本体を持つことはできません

# 0: kind name, 1: symbol
compiler.err.already.annotated={0} {1}は注釈が付いています

# 0: kind name, 1: symbol, 2: kind name, 3: symbol
compiler.err.already.defined={0} {1}はすでに{2} {3}で定義されています

# 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
compiler.err.already.defined.in.clinit={0} {1}はすでに{3} {4}の{2}で定義されています

# 0: symbol
compiler.err.already.defined.single.import=同じ単純名の型が{0}の単一型インポートによってすでに定義されています

# 0: symbol
compiler.err.already.defined.static.single.import=同じ単純名の型が{0}のstatic単一型インポートによってすでに定義されています

# 0: symbol
compiler.err.already.defined.this.unit={0}はコンパイル単位で定義されています

compiler.err.annotation.missing.element.value=注釈に要素値がありません

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=注釈@{0}には要素''{1}''のデフォルト値がありません

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=注釈@{0}には要素{1}のデフォルト値がありません

# 0: type
compiler.err.annotation.not.valid.for.type=注釈は型{0}の要素に対して有効ではありません

compiler.err.annotation.type.not.applicable=注釈インタフェースはこの種類の宣言に使用できません

# 0: type
compiler.err.annotation.type.not.applicable.to.type=注釈@{0}はこの型のコンテキストに使用できません

compiler.err.annotation.value.must.be.annotation=注釈の値は注釈である必要があります

compiler.err.annotation.value.must.be.class.literal=注釈の値はクラス・リテラルである必要があります

compiler.err.annotation.value.must.be.name.value=注釈の値は''name=value''という形式である必要があります

compiler.err.annotation.value.not.allowable.type=使用できない型の注釈の値です

compiler.err.expression.not.allowable.as.annotation.value=式が注釈の値として許可されません

# 0: type, 1: name
compiler.err.annotation.unrecognized.attribute.name=注釈@{0}に''{1}''という名前の不明な属性があります

compiler.err.anon.class.impl.intf.no.args=名前のないクラスがインタフェースを実装しています。引数を持つことはできません

compiler.err.anon.class.impl.intf.no.typeargs=名前のないクラスがインタフェースを実装しています。型引数を持つことはできません

compiler.err.anon.class.impl.intf.no.qual.for.new=名前のないクラスがインタフェースを実装しています。newに修飾子を持つことはできません。

compiler.err.cant.inherit.from.anon=匿名クラスから継承できません

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs={2}で{0}と{1}の両方を宣言することはできません

compiler.err.array.dimension.missing=配列の大きさが指定されていません

compiler.err.illegal.array.creation.both.dimension.and.initialization=次元式と初期化の両方を使用した配列の作成は無効です

# 0: type
compiler.err.array.req.but.found=配列が要求されましたが、{0}が見つかりました

compiler.err.attribute.value.must.be.constant=要素値は定数式である必要があります

# 0: string (statement type)
compiler.err.bad.initializer={0}の不正な初期化子

compiler.err.break.outside.switch.loop=breakがswitch文またはループの外にあります

compiler.err.break.outside.switch.expression=switch式の外側でbreakを実行しようとしています

compiler.err.continue.outside.switch.expression=switch式の外側でcontinueを実行しようとしています

compiler.err.return.outside.switch.expression=switch式の外側でreturnを実行しようとしています

compiler.err.rule.completes.normally=switchルールが値を提供せずに完了しました\n(switch式のswitchルールは値またはスローを提供する必要があります)

compiler.err.switch.expression.completes.normally=switch式が値を提供せずに完了しました\n(switch式はすべての可能な入力値について値またはスローを提供する必要があります)

compiler.err.no.switch.expression =switch式の外側のyield

compiler.err.no.switch.expression.qualify=switch式の外側のyield\n(yieldというメソッドを呼び出すには、yieldを受取り側またはタイプ名で修飾します)

compiler.err.invalid.yield=制限された識別子''yield''の使用は無効です\n(yieldというメソッドを呼び出すには、yieldを受取り側またはタイプ名で修飾します)

compiler.warn.invalid.yield=''yield''は将来のリリースで制限された識別子になる可能性があります\n(yieldというメソッドを呼び出すには、yieldを受取り側またはタイプ名で修飾します)

compiler.err.switch.expression.empty=switch式にcase句がありません

compiler.err.switch.expression.no.result.expressions=switch式に結果式がありません

compiler.err.call.must.only.appear.in.ctor=明示的なコンストラクタ呼出しは、コンストラクタ本体にのみ表示されます

compiler.err.redundant.superclass.init=冗長な明示的なコンストラクタ呼出し

compiler.err.ctor.calls.not.allowed.here=明示的なコンストラクタ呼出しはここでは許可されません

compiler.err.return.before.superclass.initialized=明示的なコンストラクタ呼出しの前に''return''は許可されません

# 0: symbol kind, 1: name, 2: symbol kind, 3: type, 4: message segment
compiler.err.cant.apply.symbol.noargs={2} {3}の{0} {1}は指定された型に適用できません。\n理由: {4}

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol={4} {5}の{0} {1}は指定された型に適用できません。\n期待値: {2}\n検出値:    {3}\n理由: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols={1}に適切な{0}が見つかりません({2})

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol={4} {5}の{0} {1}は指定された型に適用できません\n期待値: {2}\n検出値:    {3}\n理由: {6}

# 0: list of type or message segment, 1: list of type or message segment, 2: message segment
compiler.misc.cant.apply.array.ctor=指定された型から配列を作成できません\n期待値: {0}\n検出値:    {1}\n理由:   {2}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols={1}に適切な{0}が見つかりません({2})

# 0: kind name, 1: symbol
compiler.misc.no.abstracts={0} {1}で抽象メソッドが見つかりません

# 0: kind name, 1: symbol
compiler.misc.incompatible.abstracts={0} {1}で複数のオーバーライドしない抽象メソッドが見つかりました

compiler.err.bad.functional.intf.anno=予期しない@FunctionalInterface注釈

# 0: message segment
compiler.err.bad.functional.intf.anno.1=予期しない@FunctionalInterface注釈\n{0}

# 0: message segment
compiler.err.anonymous.diamond.method.does.not.override.superclass=メソッドはスーパータイプのメソッドをオーバーライドまたは実装しません\n{0}

# 0: symbol
compiler.misc.not.a.functional.intf={0}は機能インタフェースではありません

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1={0}は機能インタフェースではありません\n{1}

# 0: type, 1: kind name, 2: symbol
compiler.misc.invalid.generic.lambda.target=ラムダ式の機能ディスクリプタが無効です\n{1} {2}のメソッド{0}は汎用です

# 0: kind name, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf={0} {1}で不適合な機能ディスクリプタが見つかりました

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=ディスクリプタ: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=ディスクリプタ: {2} {0}({1})で{3}がスローされます

# 0: type
compiler.misc.no.suitable.functional.intf.inst={0}の機能インタフェース・ディスクリプタを推論できません

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=ラムダまたはメソッド参照の交差タイプ・ターゲットが不正です\n{0}

# 0: symbol or type
compiler.misc.not.an.intf.component=コンポーネント・タイプ{0}はインタフェースではありません

# 0: kind name, 1: message segment
compiler.err.invalid.mref={0}参照が無効です\n{1}

# 0: kind name, 1: message segment
compiler.misc.invalid.mref={0}参照が無効です\n{1}

compiler.misc.static.mref.with.targs=staticメソッド参照のパラメータ化された修飾子

# 0: set of flag or string, 1: symbol
compiler.err.cant.assign.val.to.var={0}変数{1}に値を割り当てることはできません

compiler.err.cant.assign.val.to.this=''これ''に割り当てることはできません

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var={1}から参照されるローカル変数は、finalまたは事実上のfinalである必要があります

compiler.err.try.with.resources.expr.needs.var=try-with-resourcesリソースは、final変数または事実上のfinal変数への参照を示す変数宣言または式である必要があります

# 0: symbol
compiler.err.try.with.resources.expr.effectively.final.var=try-with-resourcesリソースとして使用される変数{0}が、finalでも事実上のfinalでもありません


compiler.misc.lambda=ラムダ式

compiler.misc.inner.cls=内部クラス

compiler.misc.guard=ガード

# 0: type
compiler.err.cant.deref={0}は間接参照できません

compiler.err.cant.extend.intf.annotation=@interfacesでは''extends''は許可されません

compiler.err.annotation.decl.not.allowed.here=ここでは注釈インタフェースの宣言は許可されません

# 0: symbol
compiler.err.cant.inherit.from.final=final {0}からは継承できません

# 0: symbol or name
compiler.err.cant.ref.before.ctor.called=スーパータイプのコンストラクタの呼出し前は{0}を参照できません

# 0: symbol or name
compiler.err.cant.assign.initialized.before.ctor.called=スーパータイプのコンストラクタの呼出し前は、初期化されたフィールド''{0}''を割り当てられません

compiler.err.cant.select.static.class.from.param.type=パラメータにされた型からstaticクラスを選択することはできません

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg={0}を異なる引数<{1}>と<{2}>で継承することはできません

compiler.err.catch.without.try=''catch''への''try''がありません

# 0: kind name, 1: symbol
compiler.err.clash.with.pkg.of.same.name={0} {1}は同名のパッケージと競合します

compiler.err.class.not.allowed=クラス、インタフェースまたは列挙型の宣言をここで使用することはできません

compiler.err.const.expr.req=定数式が必要です

compiler.err.pattern.or.enum.req=パターンまたは列挙型の定数が必要です

compiler.err.cont.outside.loop=continueがループの外にあります

# 0: symbol or type
compiler.err.cyclic.inheritance={0}を含む継承がループしています

# 0: symbol
compiler.err.cyclic.annotation.element=要素{0}の型がループしています

# 0: symbol
compiler.err.call.to.super.not.allowed.in.enum.ctor=列挙型コンストラクタでは、スーパークラスの呼出しはできません

# 0: type
compiler.err.no.superclass={0}にはスーパークラスがありません。

# 0: symbol, 1: type, 2: symbol, 3: type, 4: type
compiler.err.concrete.inheritance.conflict={1}のメソッド{0}と{3}の{2}は同じシグニチャから継承されています

compiler.err.default.allowed.in.intf.annotation.member=デフォルト値は注釈インタフェースの宣言でのみ使用できます

# 0: symbol
compiler.err.doesnt.exist=パッケージ{0}は存在しません

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=注釈{0}は有効な繰返し可能な注釈ではありません

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=注釈@{1}に重複した要素''{0}''があります。

# 0: type
compiler.err.duplicate.annotation.missing.container={0}は繰返し可能な注釈インタフェースではありません

# 0: symbol
compiler.err.invalid.repeatable.annotation=注釈が重複しています: {0}は無効な@Repeatable注釈で注釈付けされています

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value={0}は有効な@Repeatableではありません。値要素メソッドが宣言されていません

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values={0}は有効な@Repeatableではありません。{1}要素メソッド''value''が宣言されています

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value={0}は有効な@Repeatableではありません: 値要素が無効です

# 0: symbol or type, 1: type, 2: type
compiler.err.invalid.repeatable.annotation.value.return=包含する注釈インタフェース({0})は型{2}の要素''value''を宣言する必要があります

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=包含する注釈インタフェース{0}には要素{1}のデフォルト値が指定されていません

# 0: symbol, 1: string, 2: symbol, 3: string
compiler.err.invalid.repeatable.annotation.retention=包含する注釈インタフェース({0})の保有が、繰返し可能な注釈インタフェース({2})の保有より短くなっています

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=繰返し可能な注釈インタフェース({1})は@Documentedですが、包含する注釈インタフェース({0})は違います

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=繰返し可能な注釈インタフェース({1})は@Inheritedですが、包含する注釈インタフェース({0})は違います

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=包含する注釈インタフェース({0})は、繰返し可能な注釈インタフェース({1})より多くのターゲットに適用されます

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=コンテナ{0}は含まれている要素と同時に指定できません

# 0: type, 1: symbol
compiler.err.invalid.repeatable.annotation.not.applicable=コンテナ{0}は要素{1}に使用できません

# 0: type
compiler.err.invalid.repeatable.annotation.not.applicable.in.context=コンテナ{0}はこの型のコンテキストに使用できません

# 0: name
compiler.err.duplicate.class=クラス{0}が重複しています

# 0: string
compiler.err.bad.file.name=不正なファイル名: {0}

compiler.err.implicit.class.should.not.have.package.declaration=暗黙的に宣言されたクラスにパッケージ宣言を含めることはできません

compiler.err.implicit.class.does.not.have.main.method=暗黙的に宣言されたクラスにvoid main()またはvoid main(String[] args)という形式のmainメソッドがありません

# 0: name, 1: name
compiler.err.same.binary.name=クラス: {0}と{1}のバイナリ名が同じです

compiler.err.duplicate.case.label=caseラベルが重複しています

compiler.err.pattern.dominated=先行するcaseラベルが、このcaseラベルよりも優位です

compiler.err.duplicate.default.label=defaultラベルが重複しています

compiler.err.duplicate.unconditional.pattern=無条件パターンが重複しています

compiler.err.unconditional.pattern.and.default=switchに無条件パターンとdefaultラベルの両方があります

compiler.err.unconditional.pattern.and.both.boolean.values=switchに、ブール値と無条件パターンの両方があります

compiler.err.default.and.both.boolean.values=switchに、ブール値とdefaultラベルの両方があります

compiler.err.guard.not.allowed=ガードはパターンのあるcaseでのみ許可されます

compiler.err.guard.has.constant.expression.false=このcaseラベルには、値が''false''の定数式であるガードがあります

# 0: symbol
compiler.err.cannot.assign.not.declared.guard=ガード内で宣言されていないため、{0}に割り当てることはできません

# 0: type, 1: type
compiler.err.constant.label.not.compatible=タイプ{0}の定数ラベルがswitchセレクタ・タイプ{1}と互換性がありません

compiler.err.flows.through.to.pattern=パターンに対して不正なfall-through\n(前のcaseラベルにbreakがありません)

compiler.err.flows.through.from.pattern=パターンに対して不正なfall-through\n(現在のcaseラベルにbreakがありません)

compiler.err.invalid.case.label.combination=caseラベルの組合せが無効です

compiler.err.default.label.not.allowed=ここではデフォルトのラベルは使用できません

compiler.err.pattern.type.cannot.infer=パターン・タイプを推測できません

compiler.err.else.without.if=''else''への''if''がありません

compiler.err.empty.char.lit=空の文字リテラルです

# 0: symbol
compiler.err.encl.class.required={0}を含む囲うインスタンスが必要です

compiler.err.enum.annotation.must.be.enum.constant=列挙型注釈値は、列挙型定数である必要があります

compiler.err.enum.cant.be.instantiated=列挙クラスはインスタンス化できません

compiler.err.enum.label.must.be.unqualified.enum=列挙型のswitch caseラベルは列挙型定数の非修飾名である必要があります

compiler.err.enum.label.must.be.enum.constant=列挙型のswitch constant caseラベルは列挙型定数である必要があります

compiler.err.enum.no.subclassing=クラスは直接java.lang.Enumを拡張できません

compiler.err.enum.types.not.extensible=列挙クラスは拡張可能ではありません

compiler.err.enum.no.finalize=列挙型はfinalizeメソッドを持つことはできません

compiler.err.enum.cant.be.generic=列挙型は汎用にできません

# 0: file name, 1: string
compiler.err.error.reading.file={0}の読込みエラーです。{1}

# 0: type
compiler.err.except.already.caught=例外{0}はすでに捕捉されています

# 0: type
compiler.err.except.never.thrown.in.try=例外{0}は対応するtry文の本体ではスローされません

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=finalパラメータ{0}に値を代入することはできません

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=自動クローズ可能なリソース{0}に値を代入することはできません

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=複数catchパラメータ{0}に値を代入することはできません

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=複数catch文の代替をサブクラス化によって関連付けることはできません\n代替{0}は代替{1}のサブクラスです

compiler.err.finally.without.try=''finally''への''try''がありません

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=for-eachは式のタイプに使用できません\n期待値: {1}\n検出値: {0}

compiler.err.fp.number.too.large=浮動小数点数が大きすぎます

compiler.err.fp.number.too.small=浮動小数点数が小さすぎます

compiler.err.generic.array.creation=汎用配列を作成します

compiler.err.generic.throwable=汎用クラスはjava.lang.Throwableを拡張できません

# 0: symbol
compiler.err.icls.cant.have.static.decl=内部クラス{0}の静的宣言が不正です\n修飾子''static''は定数および変数の宣言でのみ使用できます

# 0: string
compiler.err.illegal.char=''{0}''は不正な文字です

# 0: string, 1: string
compiler.err.illegal.char.for.encoding=この文字(0x{0})は、エンコーディング{1}にマップできません

# 0: set of flag, 1: set of flag
compiler.err.illegal.combination.of.modifiers=修飾子{0}と{1}の組合せは不正です

compiler.err.illegal.enum.static.ref=初期化子からstaticフィールドへの参照が不正です

compiler.err.illegal.esc.char=エスケープ文字が不正です

compiler.err.illegal.forward.ref=前方参照が不正です

# 0: symbol, 1: object
compiler.err.not.in.profile={0}はプロファイル''{1}''で使用できません

# 0: symbol
compiler.warn.forward.ref=初期化される前の変数''{0}''を参照しようとしました

compiler.warn.possible.this.escape=サブクラスが初期化される前の''this''エスケープの可能性があります

compiler.warn.possible.this.escape.location=事前の''this''エスケープはこの呼び出しで出現する可能性があります

compiler.err.illegal.self.ref=初期化子内の自己参照

# 0: symbol
compiler.warn.self.ref=初期化子内の変数''{0}''の自己参照

# 0: type
compiler.err.illegal.initializer.for.type={0}の初期化子が不正です

compiler.err.illegal.line.end.in.char.lit=文字リテラルの行末が不正です

compiler.err.illegal.text.block.open=テキスト・ブロックの開始区切り文字のシーケンスが無効です。行の終了文字がありません

compiler.warn.inconsistent.white.space.indentation=空白のインデントに一貫性がありません

compiler.warn.trailing.white.space.will.be.removed=末尾の空白は除去されます

compiler.err.illegal.nonascii.digit=不正な非ASCII数字です

compiler.err.illegal.underscore=不正なアンダースコアです

compiler.err.illegal.dot=不正な''.''です

compiler.err.illegal.digit.in.binary.literal=2進数リテラルの数字が正しくありません

compiler.err.illegal.digit.in.octal.literal=8進数リテラルの数字が正しくありません

# 0: symbol
compiler.err.illegal.qual.not.icls=修飾子が不正です。{0}は内部クラスではありません

compiler.err.illegal.start.of.expr=式の開始が不正です

compiler.err.illegal.start.of.stmt=文の開始が不正です

compiler.err.illegal.start.of.type=型の開始が不正です

compiler.err.illegal.parenthesized.expression=カッコ内の式が不正です

compiler.err.illegal.unicode.esc=Unicodeエスケープが不正です

# 0: symbol
compiler.err.import.requires.canonical=インポートには{0}の標準名が必要です

compiler.err.improperly.formed.type.param.missing=型の形式が不適切です。パラメータが不足しています

compiler.err.improperly.formed.type.inner.raw.param=型の形式が不適切です。raw型に指定された型引数です

# 0: type, 1: type
compiler.err.incomparable.types=型{0}と{1}は比較できません

# 0: string
compiler.err.int.number.too.large=整数が大きすぎます。

compiler.err.intf.annotation.members.cant.have.params=注釈インタフェース宣言内の要素が仮パラメータを宣言できません

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=注釈インタフェース{0}は汎用にできません

compiler.err.intf.annotation.members.cant.have.type.params=注釈インタフェース宣言内の要素は汎用メソッドにできません

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=注釈インタフェース{1}でメソッド{0}と同じ名前の要素が宣言されています

compiler.err.intf.expected.here=ここにインタフェースが必要です

compiler.err.intf.meth.cant.have.body=インタフェース抽象メソッドが本体を持つことはできません

compiler.err.invalid.annotation.member.type=注釈インタフェース要素の型が無効です

compiler.err.invalid.binary.number=2進数字は少なくとも1桁の2進数を含む必要があります

compiler.err.invalid.hex.number=16進数字は少なくとも1桁の16進数を含む必要があります

compiler.err.invalid.meth.decl.ret.type.req=無効なメソッド宣言です。戻り値の型が必要です。

compiler.err.varargs.and.old.array.syntax=旧式の配列表記法は可変引数パラメータでは使用できません

compiler.err.varargs.and.receiver =varargs表記は受取り側パラメータで使用できません

compiler.err.varargs.must.be.last =可変引数パラメータは最後のパラメータにする必要があります

compiler.err.array.and.receiver =旧式の配列表記法は受取り側パラメータでは使用できません

compiler.err.wrong.receiver =受取り側パラメータの名前が間違っています

compiler.err.variable.not.allowed=変数の宣言をここで使用することはできません

# 0: name
compiler.err.label.already.in.use=ラベル{0}はすでに使用されています

compiler.err.local.enum=列挙クラスはローカルにできません

compiler.err.cannot.create.array.with.type.arguments=型引数を持つ配列を作成できません

compiler.err.cannot.create.array.with.diamond=''<>''を持つ配列は作成できません

compiler.err.invalid.module.directive=モジュール・ディレクティブ・キーワードまたは''}''が必要です

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=コードが大きすぎます

compiler.err.limit.code.too.large.for.try.stmt=try文のコードが大きすぎます

compiler.err.limit.dimensions=配列型の次元が多すぎます

compiler.err.limit.locals=ローカル変数が多すぎます

compiler.err.limit.parameters=パラメータが多すぎます

compiler.err.limit.pool=定数が多すぎます

compiler.err.limit.pool.in.class=クラス{0}内の定数が多すぎます

compiler.err.limit.stack=コードが要求するスタックが多すぎます

compiler.err.limit.string=定数文字列が長すぎます

# 0: string
compiler.err.limit.string.overflow=文字列"{0}..."のUTF8表現が、定数プールに対して長すぎます

compiler.err.malformed.fp.lit=浮動小数点リテラルが不正です

compiler.err.method.does.not.override.superclass=メソッドはスーパータイプのメソッドをオーバーライドまたは実装しません

compiler.err.static.methods.cannot.be.annotated.with.override=staticメソッドは@Overrideで注釈付けすることはできません

compiler.err.missing.meth.body.or.decl.abstract=メソッド本体がないか、abstractとして宣言されています

compiler.err.missing.ret.stmt=return文が指定されていません

# 0: type
compiler.misc.missing.ret.val=戻り値がありません

compiler.misc.unexpected.ret.val=予期しない戻り値

# 0: set of flag
compiler.err.mod.not.allowed.here=修飾子{0}をここで使用することはできません

# 0: name
compiler.err.modifier.not.allowed.here=修飾子{0}をここで使用することはできません

compiler.err.intf.not.allowed.here=ここではインタフェースは許可されません

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=名前が競合しています。{0}と{1}は削除後の名前が同じです

# 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
compiler.err.name.clash.same.erasure.no.override=名前が競合しています。{2}の{0}({1})と{5}の{3}({4})はまだ他方をオーバーライドしていませんが、削除後の名前が同じです

# 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
compiler.err.name.clash.same.erasure.no.override.1=名前が競合しています。{0} {1}はまだ他方をオーバーライドしていませんが、削除後の名前が同じ2つのメソッドがあります\n最初のメソッド:  {4}の{2}({3})\n2番目のメソッド: {7}の{5}({6})

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=名前が競合しています。{1}の{0}と{3}の{2}はまだ他方を非表示にしていませんが、削除後の名前が同じです

compiler.err.name.reserved.for.internal.use={0}は内部での使用のため予約されています

compiler.err.native.meth.cant.have.body=nativeメソッドが本体を持つことはできません


# 0: message segment
compiler.misc.incompatible.type.in.conditional=条件式の型が不正です\n{0}

compiler.misc.conditional.target.cant.be.void=条件式のターゲット型はvoidにできません

compiler.misc.switch.expression.target.cant.be.void=switch式のターゲット型はvoidにできません

# 0: message segment
compiler.misc.incompatible.type.in.switch.expression=switch式の型が不正です\n{0}

# 0: message segment
compiler.misc.incompatible.ret.type.in.lambda=ラムダ式の戻り型が不正です\n{0}

compiler.misc.stat.expr.expected=ラムダ・ボディがvoid機能インタフェースと互換性がありません\n(ブロックのラムダ・ボディの使用を検討するか、かわりに文の式を使用してください)

# 0: message segment
compiler.misc.incompatible.ret.type.in.mref=メソッド参照の戻り型が不正です\n{0}

compiler.err.lambda.body.neither.value.nor.void.compatible=ラムダ・ボディは値互換でもvoid互換でもありません

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=機能式でスローされたタイプ{0}は不適合です

compiler.misc.incompatible.arg.types.in.lambda=ラムダ式のパラメータ型は不適合です

compiler.misc.incompatible.arg.types.in.mref=メソッド参照のパラメータ型は不適合です

compiler.err.new.not.allowed.in.annotation=''new''は注釈に使用できません

# 0: name, 1: type
compiler.err.no.annotation.member={1}の注釈メンバー{0}がありません

# 0: symbol
compiler.err.no.encl.instance.of.type.in.scope=型{0}の内部クラスを囲むインスタンスがスコープ内にありません

compiler.err.no.intf.expected.here=ここにインタフェースは必要ありません

compiler.err.no.match.entry={0}は{1}のエントリに適合しません。{2}が必要です

# 0: type
compiler.err.not.annotation.type={0}は注釈インタフェースではありません

# 0: symbol, 1: symbol, 2: message segment
compiler.err.not.def.access.package.cant.access={0} は表示不可です\n({2})

# 0: symbol, 1: symbol, 2: message segment
compiler.misc.not.def.access.package.cant.access={0} は表示不可です\n({2})

# 0: symbol, 1: message segment
compiler.err.package.not.visible=パッケージ{0}は表示不可です\n({1})

# 0: symbol, 1: message segment
compiler.misc.package.not.visible=パッケージ{0}は表示不可です\n({1})

# {0} - current module
# {1} - package in which the invisible class is declared
# {2} - module in which {1} is declared
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.does.not.read=パッケージ{1}はモジュール{2}で宣言されていますが、モジュール{0}に読み込まれていません

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.from.unnamed=パッケージ{0}はモジュール{1}で宣言されていますが、モジュール・グラフにありません

# {0} - package in which the invisible class is declared
# {1} - current module
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.unnamed=パッケージ{0}は名前のないモジュールで宣言されていますが、モジュール{1}に読み込まれていません

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported=パッケージ{0}はモジュール{1}で宣言されていますが、エクスポートされていません

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.from.unnamed=パッケージ{0}はモジュール{1}で宣言されていますが、エクスポートされていません

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# {2} - current module
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.not.exported.to.module=パッケージ{0}はモジュール{1}で宣言されていますが、モジュール{2}にエクスポートされていません

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.to.module.from.unnamed=パッケージ{0}はモジュール{1}で宣言されていますが、名前のないモジュールにエクスポートされていません

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access={1}.{0}はアクセスできないクラスまたはインタフェースに定義されています

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access={1}.{0}はアクセスできないクラスまたはインタフェースに定義されています

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.err.not.def.access.class.intf.cant.access.reason=パッケージ{2}の{1}.{0}にはアクセスできません\n({3})

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.misc.not.def.access.class.intf.cant.access.reason=パッケージ{2}の{1}.{0}にはアクセスできません\n({3})

# 0: symbol, 1: list of type, 2: type
compiler.misc.cant.access.inner.cls.constr=コンストラクタ{0}({1})にアクセスできません\n内部クラスを囲む型{2}のインスタンスがスコープ内にありません

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access={1}の{0}はpublicではありません。パッケージ外からはアクセスできません

# 0: symbol, 1: symbol
compiler.err.not.def.public={1}の{0}はpublicではありません

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access={1}の{0}はpublicではありません。パッケージ外からはアクセスできません

# 0: name
compiler.err.not.loop.label={0}はループ・ラベルではありません

compiler.err.not.stmt=文ではありません

# 0: symbol
compiler.err.not.encl.class={0}は内部クラスを囲みません

# 0: name, 1: type
compiler.err.operator.cant.be.applied=単項演算子''{0}''のオペランド型{1}が不正です

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=二項演算子''{0}''のオペランド型が不正です\n最初の型: {1}\n2番目の型: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=パッケージの注釈はファイルpackage-info.java内にある必要があります

compiler.err.no.pkg.in.module-info.java=パッケージ宣言はファイルmodule-info.java内では許可されません

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=パッケージ{0}は同名のクラスと競合しています

compiler.err.warnings.and.werror=警告が見つかり-Werrorが指定されました

# Errors related to annotation processing

# 0: symbol, 1: message segment, 2: string (stack-trace)
compiler.err.proc.cant.access={0}にアクセスできません\n{1}\n詳細は次のスタックトレースで調査してください。\n{2}

# 0: symbol, 1: message segment
compiler.err.proc.cant.access.1={0}にアクセスできません\n{1}

# 0: string
compiler.err.proc.cant.find.class=''{0}''のクラス・ファイルが見つかりませんでした。

# 0: string
compiler.err.proc.cant.load.class=''{0}''が原因で、プロセッサ・クラス・ファイルをロードできませんでした。

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager={0}

# 0: string
compiler.misc.exception.message={0}

compiler.misc.user.selected.completion.failure=クラス名によるユーザー選択の完了に失敗しました

# 0: collection of string
compiler.err.proc.no.explicit.annotation.processing.requested=クラス名''{0}''が受け入れられるのは、注釈処理が明示的にリクエストされた場合のみです

compiler.err.proc.no.service=サービス・ローダーが使用できませんでしたが、注釈処理に必要です。

# 0: string, 1: string
compiler.err.proc.processor.bad.option.name=プロセッサ''{1}''によって指定されたオプション名''{0}''が不正です

# 0: string
compiler.err.proc.processor.cant.instantiate=プロセッサ''{0}''のインスタンスをインスタンス化できませんでした

# 0: string
compiler.err.proc.processor.not.found=注釈プロセッサ''{0}''が見つかりません

# 0: string
compiler.err.proc.processor.wrong.type=注釈プロセッサ''{0}''がjavax.annotation.processing.Processorを実装していません

compiler.err.proc.service.problem=プロセッサをロードするためのサービス・ローダーを作成中にエラーが発生しました。

# 0: string
compiler.err.proc.bad.config.file=サービス構成ファイルが不正であるか、プロセッサ・オブジェクトの構築中に例外がスローされました: {0}

compiler.err.proc.cant.create.loader=注釈プロセッサのクラス・ローダーを作成できませんでした: {0}

# 0: symbol
compiler.err.qualified.new.of.static.class=staticクラスのnewが修飾されています

compiler.err.recursive.ctor.invocation=コンストラクタの呼出しが再帰的です

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous={0}の参照はあいまいです\n{3}の{1} {2}と{6}の{4} {5}の両方が一致します

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous={0}の参照はあいまいです\n{3}の{1} {2}と{6}の{4} {5}の両方が一致します

compiler.err.repeated.annotation.target=注釈ターゲットが繰り返されています

compiler.err.repeated.interface=インタフェースが繰り返されています

compiler.err.repeated.modifier=修飾子が繰り返されています

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access={0}は{2}で{1}アクセスされます

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access={0}は{2}で{1}アクセスされます

compiler.err.ret.outside.meth=メソッドの外のreturn文です

compiler.err.signature.doesnt.match.supertype=シグニチャが{0}に適合しません。互換性のないスーパータイプです

compiler.err.signature.doesnt.match.intf=シグニチャが{0}に適合しません。互換性のないインタフェースです

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract={0}はabstractでなく、{2}内のabstractメソッド{1}をオーバーライドしません

# 0: file object
compiler.err.source.cant.overwrite.input.file=ソースの書込みエラーです。入力ファイル{0}を上書きできません

# 0: symbol
compiler.err.stack.sim.error=内部エラー: {0}でのスタック・シミュレーション・エラー

compiler.err.static.imp.only.classes.and.interfaces=static importはクラスとインタフェースからのみとなります

compiler.err.string.const.req=定数の文字列式が必要です

compiler.err.pattern.expected=タイプのパターンが必要です

# 0: symbol, 1: fragment
compiler.err.cannot.generate.class=クラス{0}の生成中にエラーが発生しました\n({1})

# 0: symbol, 1: symbol
compiler.misc.synthetic.name.conflict=シンボル{0}が、{1}でコンパイラが合成したシンボルと競合します

# 0: symbol, 1: type
compiler.misc.illegal.signature=型{1}の署名属性が不正です

compiler.err.throws.not.allowed.in.intf.annotation=throws節を@interfaceメンバーで使用することはできません

compiler.err.try.without.catch.finally.or.resource.decls=''try''への''catch''、''finally''またはリソース宣言がありません

# 0: symbol
compiler.err.type.doesnt.take.params=型{0}はパラメータをとりません

compiler.err.type.var.cant.be.deref=型変数から選択できません

compiler.err.type.var.may.not.be.followed.by.other.bounds=この型変数の後ろに他の境界を配置することはできません

compiler.err.type.var.more.than.once=型変数{0}は{1}の戻り値の型で2回以上出現します。インスタンス生成されないままにはできません

compiler.err.type.var.more.than.once.in.result=型変数{0}は{1}の型で2回以上出現します。インスタンス生成されないままにはできません

# 0: type, 1: type, 2: fragment
compiler.err.types.incompatible=タイプ{0}と{1}は互換性がありません。\n{2}

# 0: name, 1: list of type
compiler.misc.incompatible.diff.ret=両方とも{0}({1})を定義していますが、戻り値の型が無関係です

# 0: type, 1: name, 2: list of type
compiler.err.incompatible.diff.ret.same.type=タイプ{0}では、無関係な戻り型で{1}({2})が複数回定義されています

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.unrelated.defaults={0} {1}は型{4}と{5}から{2}({3})の関連しないデフォルトを継承します

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.abstract.default={0} {1}は型{4}と{5}から{2}({3})の抽象とデフォルトを継承します

# 0: name, 1: kind name, 2: symbol
compiler.err.default.overrides.object.member={1} {2}のデフォルト・メソッド{0}はjava.lang.Objectのメンバーをオーバーライドします

# 0: type
compiler.err.illegal.static.intf.meth.call=staticインタフェース・メソッド・コールが不正です\n受信式は型修飾子''{0}''で置換される必要があります

# 0: symbol or type, 1: message segment
compiler.err.illegal.default.super.call=デフォルトのスーパー・コールの型修飾子{0}が不正です\n{1}

# 0: symbol, 1: type
compiler.misc.overridden.default={1}のメソッド{0}はオーバーライドされます

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=冗長なインタフェース{0}は{1}によって拡張されました

compiler.err.unclosed.char.lit=文字リテラルが閉じられていません

compiler.err.unclosed.comment=コメントが閉じられていません

compiler.err.unclosed.str.lit=文字列リテラルが閉じられていません

compiler.err.unclosed.text.block=閉じられていないテキスト・ブロック

# 0: string
compiler.err.unsupported.encoding=サポートされていないエンコーディングです: {0}

compiler.err.io.exception=ソース・ファイルの読取りエラーです: {0}

# 0: name
compiler.err.undef.label=ラベル{0}は未定義です

# 0: name
compiler.err.illegal.ref.to.restricted.type=制限された型''{0}''への無効な参照です

# 0: name
compiler.warn.illegal.ref.to.restricted.type=制限された型''{0}''への無効な参照です

# 0: name, 1: source
compiler.err.restricted.type.not.allowed=ここでは''{0}''は許可されません\nリリース{1}から''{0}''は制限された型名であり、型の宣言に使用できません

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed=リリース{1}から、''{0}''は制限された型名であり、型の宣言での使用、または配列の要素タイプとしての使用はできません

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed.preview=''{0}''は将来のリリースで制限された型名になる可能性があり、型の宣言での使用、または配列の要素タイプとしての使用はできなくなる可能性があります

# 0: name (variable), 1: message segment
compiler.err.cant.infer.local.var.type=ローカル変数{0}の型を推論できません\n({1})

# 0: name
compiler.err.restricted.type.not.allowed.here=''{0}''はここでは許可されません

# 0: name
compiler.err.restricted.type.not.allowed.array=''{0}''は配列の要素タイプとして許可されません

# 0: name
compiler.err.restricted.type.not.allowed.compound=''{0}''は複合宣言で許可されません

# 0: fragment
compiler.err.invalid.lambda.parameter.declaration=無効なラムダ・パラメータ宣言\n({0})

compiler.misc.implicit.and.explicit.not.allowed=暗黙的に型指定されたパラメータと明示的に型指定されたパラメータを組み合せることはできません

compiler.misc.var.and.explicit.not.allowed=''var''と明示的に型指定されたパラメータを組み合せることはできません

compiler.misc.var.and.implicit.not.allowed=''var''と暗黙的に型指定されたパラメータを組み合せることはできません

compiler.misc.local.cant.infer.null=変数初期化子は''null''です

compiler.misc.local.cant.infer.void=変数初期化子は''void''です

compiler.misc.local.missing.init=初期化子なしで変数に''var''を使用することはできません

compiler.misc.local.lambda.missing.target=ラムダ式には明示的なターゲット型が必要です

compiler.misc.local.mref.missing.target=メソッド参照には明示的なターゲット型が必要です

compiler.misc.local.array.missing.target=配列初期化子には明示的なターゲット型が必要です

compiler.misc.local.self.ref=自己参照変数に''var''を使用することはできません

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond={0}の型引数を推定できません

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1={0}の型引数を推論できません\n理由: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1={0}の型引数を推論できません\n理由: {1}

compiler.err.unreachable.stmt=この文に制御が移ることはありません

compiler.err.not.exhaustive=switch式がすべての可能な入力値をカバーしていません

compiler.err.not.exhaustive.statement=switch文がすべての可能な入力値をカバーしていません

compiler.err.initializer.must.be.able.to.complete.normally=初期化子は正常に完了できる必要があります

compiler.err.initializer.not.allowed=イニシャライザはinterfacesでは許可されません

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=例外{0}は報告されません。スローするには、捕捉または宣言する必要があります

# 0: type
compiler.err.unreported.exception.default.constructor=デフォルトのコンストラクタ内に報告されない例外{0}が存在します

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=報告されない例外{0}は、スローするには捕捉または宣言する必要があります\nリソース変数''{1}''でのclose()の暗黙的なコールから例外がスローされました

compiler.err.void.not.allowed.here=ここで''void''型を使用することはできません

# 0: string
compiler.err.wrong.number.type.args=型引数の数が不正です。{0}個必要です

# 0: symbol
compiler.err.var.might.already.be.assigned=変数{0}はすでに代入されている可能性があります

# 0: symbol
compiler.err.var.might.not.have.been.initialized=変数{0}は初期化されていない可能性があります

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=変数{0}は、デフォルト・コンストラクタで初期化されていません

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=変数{0}はループ内で代入されている可能性があります

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno={0}注釈が無効です。{1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=可変引数要素型{0}はreifiable型です。

# 0: type, 1: type
compiler.err.instanceof.reifiable.not.safe={0}を{1}に安全にキャストできません

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=メソッド{0}は可変引数メソッドではありません。

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.accessor=アクセサ{0}は可変引数メソッドではありません。

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=インスタンス・メソッド{0}はfinalでもprivateでもありません。

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs.final.only=インスタンス・メソッド{0}はfinalではありません。

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=仮可変引数要素型{0}は{1} {2}からアクセスできません

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write={0}の書込み中にエラーが発生しました: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: kind name, 1: name
compiler.err.class.public.should.be.in.file={0} {1}はpublicであり、ファイル{1}.javaで宣言する必要があります

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=エラー:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file={0}を読み込めません

# 0: string
compiler.err.plugin.not.found=プラグインが見つかりません: {0}

# 0: path
compiler.warn.locn.unknown.file.on.module.path=モジュール・パスのファイルが不明です: {0}


# 0: path
compiler.err.locn.bad.module-info={0}のmodule-info.classを読取り中に問題が発生しました

# 0: path
compiler.err.locn.cant.read.directory=ディレクトリ{0}を読み取れません

# 0: path
compiler.err.locn.cant.read.file=ファイル{0}を読み取れません

# 0: path
compiler.err.locn.cant.get.module.name.for.jar={0}のモジュール名を判別できません

# 0: path
compiler.err.multi-module.outdir.cannot.be.exploded.module=複数モジュール・モードで、出力ディレクトリは展開したモジュールにすることはできません: {0}

# 0: path
compiler.warn.outdir.is.in.exploded.module=出力ディレクトリは展開したモジュール内です: {0}

# 0: file object
compiler.err.locn.module-info.not.allowed.on.patch.path=module-info.classはパッチ・パスでは許可されません: {0}

# 0: string
compiler.err.locn.invalid.arg.for.xpatch=--patch-moduleオプションの引数が無効です: {0}

compiler.err.file.sb.on.source.or.patch.path.for.module=ファイルは、ソース・パス、またはモジュールのパッチ・パスに存在している必要があります

compiler.err.no.java.lang=プラットフォーム・クラスでパッケージjava.langを検出できません

#####

# Fatal Errors

# 0: name
compiler.misc.fatal.err.cant.locate.meth=致命的エラー: メソッド{0}を検出できません

# 0: name
compiler.misc.fatal.err.cant.locate.field=致命的エラー: フィールド{0}を検出できません

# 0: type
compiler.misc.fatal.err.cant.locate.ctor=致命的エラー: {0}のコンストラクタを検出できません

compiler.misc.fatal.err.cant.close=致命的エラー: コンパイラ・リソースを閉じることができません

#####

##
## miscellaneous strings
##

compiler.misc.diamond.anonymous.methods.implicitly.override=(<>のため、この匿名クラスに宣言されたすべての非privateメソッドはスーパータイプのメソッドをオーバーライドまたは実装しません)

compiler.misc.source.unavailable=(ソースが利用不可)

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=プロセッサ{0}は{1}に一致し、{2}を返します。

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=往復{0}:\n\t入力ファイル: {1}\n\t注釈: {2}\n\t最後の往復: {3}

# 0: file name
compiler.warn.file.from.future=ファイル{0}の変更日が将来の日付です

# 0: path
compiler.warn.output.file.clash=出力ファイルへの書込みが複数回ありました: {0}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=一部のメッセージは簡略化されています。-Xdiags:verboseで再コンパイルして完全な出力を取得してください

# 0: boolean, 1: symbol
compiler.note.lambda.stat=ラムダ式を変換しています\n代替metafactory = {0}\n合成メソッド = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=メソッド参照を変換しています\n代替metafactory = {0}\n
# 0: boolean, 1: symbol
compiler.note.mref.stat.1=メソッド参照を変換しています\n代替metafactory = {0}\nブリッジ・メソッド = {1}

compiler.note.note=ノート:\u0020

# 0: file name
compiler.note.deprecated.filename={0}は推奨されないAPIを使用またはオーバーライドしています。

compiler.note.deprecated.plural=一部の入力ファイルは推奨されないAPIを使用またはオーバーライドしています。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=詳細は、-Xlint:deprecationオプションを指定して再コンパイルしてください。

# 0: file name
compiler.note.deprecated.filename.additional={0}に推奨されないAPIの追加使用またはオーバーライドがあります。

compiler.note.deprecated.plural.additional=一部の入力ファイルは推奨されないAPIを追加使用またはオーバーライドしています。

# 0: file name
compiler.note.removal.filename={0}は、削除用にマークされた推奨されないAPIを使用またはオーバーライドしています。

compiler.note.removal.plural=一部の入力ファイルは、削除用にマークされた推奨されないAPIを使用またはオーバーライドしています。

# The following string may appear after one of the above removal messages.
compiler.note.removal.recompile=詳細は、-Xlint:removalオプションを指定して再コンパイルしてください。

# 0: file name
compiler.note.removal.filename.additional={0}に、削除用にマークされた推奨されないAPIの追加使用またはオーバーライドがあります。

compiler.note.removal.plural.additional=一部の入力ファイルは、削除用にマークされた推奨されないAPIを追加使用またはオーバーライドしています。

# 0: file name
compiler.note.unchecked.filename={0}の操作は、未チェックまたは安全ではありません。

compiler.note.unchecked.plural=入力ファイルの操作のうち、未チェックまたは安全ではないものがあります。

# The following string may appear after one of the above unchecked messages.
compiler.note.unchecked.recompile=詳細は、-Xlint:uncheckedオプションを指定して再コンパイルしてください。

# 0: file name
compiler.note.unchecked.filename.additional={0}に未チェックまたは安全ではない操作がさらにあります。

compiler.note.unchecked.plural.additional=入力ファイルの操作のうち、未チェックまたは安全ではないものがさらにあります。

# 0: file name, 1: source
compiler.note.preview.filename={0}はJava SE {1}のプレビュー機能を使用します。

# 0: source
compiler.note.preview.plural=一部の入力ファイルはJava SE {0}のプレビュー機能を使用します。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.preview.recompile=詳細は、-Xlint:previewオプションを指定して再コンパイルしてください。

# 0: file name, 1: source
compiler.note.preview.filename.additional={0}にJava SE {1}のプレビュー機能の追加使用があります。

# 0: source
compiler.note.preview.plural.additional=一部の入力ファイルはJava SE {0}のプレビュー機能を追加使用します。

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager={0}

# 0: string, 1: string, 2: string
compiler.note.multiple.elements=モジュール''{2}''に''{1}という名前の複数の要素がjavax.lang.model.util.Elements.{0}によって見つかりました。

compiler.note.implicit.annotation.processing=クラス・パスに1つ以上のプロセッサが見つかったため、注釈処理が有効化されて\nいます。少なくとも1つのプロセッサが名前(-processor)で指定されるか、検索パス\n(--processor-path、--processor-module-path)が指定されるか、注釈処理が明示的に\n有効化(-proc:only、-proc:full)されている場合を除き、将来のリリースのjavacでは\n注釈処理が無効化される可能性があります。\n-Xlint:オプションを使用すると、このメッセージを非表示にできます。\n-proc:noneを使用すると、注釈処理を無効化できます。

#####

# 0: number
compiler.misc.count.error=エラー{0}個

# 0: number
compiler.misc.count.error.plural=エラー{0}個

# 0: number, 1: number
compiler.misc.count.error.recompile=合計{1}個のうち、最初の{0}個のエラーのみ表示しています。さらに表示する場合は、-Xmaxerrsを使用してください

# 0: number, 1: number
compiler.misc.count.warn.recompile=合計{1}個のうち、最初の{0}個の警告のみ表示しています。さらに表示する場合は、-Xmaxwarnsを使用してください

# 0: number
compiler.misc.count.warn=警告{0}個

# 0: number
compiler.misc.count.warn.plural=警告{0}個

compiler.misc.version.not.available=(バージョン情報がありません)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=[{0}を確認中]

# 0: string
compiler.misc.verbose.parsing.done=[{0}ミリ秒で構文解析完了]

# 0: file name
compiler.misc.verbose.parsing.started=[{0}を構文解析開始]

# 0: string
compiler.misc.verbose.total=[合計{0}ミリ秒]

# 0: file name
compiler.misc.verbose.wrote.file=[{0}を書込み完了]

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=[{0}を読込み中]

# 0: string
compiler.misc.verbose.sourcepath=[ソース・ファイルの検索パス: {0}]

# 0: string
compiler.misc.verbose.classpath=[クラス・ファイルの検索パス: {0}]

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=R)再開,A)中止>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=警告:\u0020

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=[{0}]\u0020

# 0: symbol
compiler.warn.constant.SVUID=serialVersionUIDはクラス{0}の定数である必要があります

compiler.warn.dangling.doc.comment=どの宣言にもドキュメンテーション・コメントが添付されていません

# 0: path
compiler.warn.dir.path.element.not.found=不正なパス要素"{0}": そのディレクトリは存在しません

# 0: file name
compiler.warn.dir.path.element.not.directory=不正なパス要素"{0}": ディレクトリは存在しません

# 0: symbol, 1: symbol, 2: symbol
compiler.warn.missing-explicit-ctor=エクスポートされたパッケージ{1}のクラス{0}は明示的なコンストラクタを宣言しないため、デフォルト・コンストラクタをモジュール{2}のクライアントに公開します

compiler.warn.strictfp=リリース17以降、すべての浮動小数点式は厳密に評価され、''strictfp''は必要ありません

compiler.warn.finally.cannot.complete=finally節が正常に完了できません

# 0: name
compiler.warn.poor.choice.for.module.name=モジュール名コンポーネント{0}の末尾は数字にしないでください

# 0: string
compiler.warn.incubating.modules=実験的なモジュールを使用しています: {0}

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated={1}の{0}は推奨されません

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated.for.removal={1}の{0}は推奨されておらず、削除用にマークされています

# 0: symbol
compiler.warn.is.preview={0}はプレビューAPIであり、今後のリリースで削除される可能性があります。

# 0: symbol
compiler.err.is.preview={0}はプレビューAPIであり、デフォルトで無効になっています。\n(プレビューAPIを有効にするには--enable-previewを使用します)

# 0: symbol
compiler.warn.is.preview.reflective={0}はリフレクティブ・プレビューAPIであり、今後のリリースで削除される可能性があります。

# 0: symbol, 1: symbol
compiler.warn.restricted.method={0}.{1}は制限されたメソッドです。\n(制限されたメソッドは安全ではありません。不適切に使用した場合、Javaランタイムがクラッシュまたはメモリーが破損する場合があります)

# 0: symbol
compiler.warn.has.been.deprecated.module=モジュール{0}は推奨されません

# 0: symbol
compiler.warn.has.been.deprecated.for.removal.module=モジュール{0}は推奨されておらず、削除用にマークされています

# 0: symbol
compiler.warn.sun.proprietary={0}は内部所有のAPIであり、今後のリリースで削除される可能性があります

compiler.warn.illegal.char.for.encoding=この文字は、エンコーディング{0}にマップできません

# 0: symbol
compiler.warn.improper.SVUID=serialVersionUIDは、クラス{0}にstatic finalを宣言する必要があります

compiler.warn.improper.SPF=serialPersistentFieldsを有効にするには、private static finalとして宣言する必要があります

compiler.warn.SPF.null.init=nullに初期化するとserialPersistentFieldsは無効になります。\nフィールドがないことを示すには、空の配列に初期化します


# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=最終パラメータの不正確な引数型を持った可変引数メソッドの非可変引数呼出し。\n可変引数呼出しに関しては{0}にキャストします。\n非可変引数呼出しに関しては{1}にキャストしてこの警告を出さないようにします

# 0: list of type
compiler.warn.unreachable.catch=catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています

# 0: list of type
compiler.warn.unreachable.catch.1=catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています

# 0: symbol
compiler.warn.long.SVUID=serialVersionUIDは、クラス{0}のlong型である必要があります

compiler.warn.OSF.array.SPF=serialPersistentFieldsを有効にするには、タイプをjava.io.ObjectStreamField[]にする必要があります

# 0: symbol
compiler.warn.missing.SVUID=直列化可能なクラス{0}には、serialVersionUIDが定義されていません

# 0: name
compiler.warn.serializable.missing.access.no.arg.ctor=シリアライズ不可のスーパークラス{0}で引数なしのコンストラクタにアクセスできません

# 0: name
compiler.warn.serial.method.not.private=シリアライズ関連メソッド{0}はprivateとして宣言されていません

# 0: name
compiler.warn.serial.concrete.instance.method=シリアライズ関連メソッド{0}を有効にするには、concreteインスタンス・メソッドである必要があります。abstractでもstaticでもありません

# 0: name
compiler.warn.serial.method.static=シリアライズ関連メソッド{0}がstaticとして宣言されています。有効にするには、かわりにインスタンス・メソッドにする必要があります

# 0: name
compiler.warn.serial.method.no.args=有効にするには、シリアライズ関連メソッド{0}にパラメータを指定しないでください

# 0: name, 1: number
compiler.warn.serial.method.one.arg=有効にするには、シリアライズ関連メソッド{0}に、{1}のパラメータではなく、パラメータを1つのみ指定する必要があります

# 0: name, 1: type, 2: type
compiler.warn.serial.method.parameter.type=有効にするには、シリアライズ関連メソッド{0}の1つのパラメータに、型{2}ではなく、型{1}を指定する必要があります

# 0: name, 1: type, 2: type
compiler.warn.serial.method.unexpected.return.type=シリアライズ関連メソッド{0}は、必要な型{2}ではなく、{1}の戻り型で宣言されています。\n宣言されているように、メソッドはシリアライズが無効になります

# 0: name, 1: type
compiler.warn.serial.method.unexpected.exception=シリアライズ関連メソッド{0}は予期しない型{1}をスローするように宣言されています

compiler.warn.ineffectual.serial.field.interface=serialPersistentFieldsはインタフェースで有効ではありません

# 0: string
compiler.warn.ineffectual.serial.field.enum=シリアライズ関連フィールド{0}は列挙クラスで有効ではありません

# 0: string
compiler.warn.ineffectual.serial.method.enum=シリアライズ関連メソッド{0}は列挙クラスで有効ではありません

# 0: string
compiler.warn.ineffectual.extern.method.enum=外部化関連メソッド{0}は列挙クラスで有効ではありません

compiler.warn.ineffectual.serial.field.record=serialPersistentFieldsはレコード・クラスで有効ではありません

# 0: string
compiler.warn.ineffectual.serial.method.record=シリアライズ関連メソッド{0}はレコード・ラスで有効ではありません

# 0: string
compiler.warn.ineffectual.externalizable.method.record=外部化関連メソッド{0}はレコード・クラスで有効ではありません

# 0: name
compiler.warn.ineffectual.serial.method.externalizable=シリアライズ関連メソッド{0}は外部化可能なクラスで有効ではありません

compiler.warn.ineffectual.serial.field.externalizable=serialPersistentFieldsは外部化可能なクラスで有効ではありません

compiler.warn.externalizable.missing.public.no.arg.ctor=外部化可能なクラスには引数なしでパブリックのコンストラクタが必要です

compiler.warn.non.serializable.instance.field=直列化可能なクラスの常駐インスタンス・フィールドは直列不可タイプで宣言されています

# 0: type
compiler.warn.non.serializable.instance.field.array=直列化可能なクラスの常駐インスタンス・フィールドは、直列不可のベース・コンポーネント・タイプ{0}を持つ配列で宣言されています

compiler.warn.non.private.method.weaker.access=インタフェースでprivateとして宣言されたシリアライズ関連メソッドによって、\nそのインタフェースを実装するクラスがメソッドをprivateとして宣言できなくなります

compiler.warn.default.ineffective=インタフェースのシリアライズ関連のデフォルト・メソッドは、クラスを実装するためのシリアライズで実行されません

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.warn.potentially.ambiguous.overload={1}内の{0}は{3}内の{2}と矛盾する可能性があります

# 0: message segment
compiler.warn.override.varargs.missing={0}。オーバーライドされたメソッドには''...''がありません

# 0: message segment
compiler.warn.override.varargs.extra={0}。オーバーライドしているメソッドには''...''がありません

# 0: message segment
compiler.warn.override.bridge={0}。オーバーライドされたメソッドはブリッジ・メソッドです

# 0: symbol
compiler.warn.pkg-info.already.seen=package-info.javaファイルがすでにパッケージ{0}用に表示されています

# 0: path
compiler.warn.path.element.not.found=不正なパス要素"{0}": そのファイルまたはディレクトリはありません

compiler.warn.possible.fall-through.into.case=caseにfall-throughする可能性があります

# 0: type
compiler.warn.redundant.cast={0}への冗長なキャストです

# 0: number
compiler.warn.position.overflow=位置エンコーディングが行{0}でオーバーフローします

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version={0}: メジャー・バージョン{1}は、このコンパイラでサポートされている最新のメジャー・バージョン{2}より新しいです。\nコンパイラのアップグレードをお薦めします。

# 0: file name, 1: fragment
compiler.warn.invalid.utf8.in.classfile={0}: クラス・ファイルに無効なUTF-8が含まれています: {1}

# 0: kind name, 1: symbol
compiler.warn.static.not.qualified.by.type=static {0}は式ではなく型名{1}で修飾する必要があります

# 0: kind name
compiler.warn.static.not.qualified.by.type2=static {0}を匿名クラスのメンバーとして使用しないでください

# 0: string, 1: fragment
compiler.warn.source.no.bootclasspath=ブートストラップ・クラス・パスが-source {0}と一緒に設定されていません\n{1}

# 0: string, 1: fragment
compiler.warn.source.no.system.modules.path=システム・モジュールの場所が-source {0}と一緒に設定されていません\n{1}

# 0: string
compiler.misc.source.no.bootclasspath=ブートストラップ・クラス・パスを設定しないと、クラス・ファイルがJDK {0}で実行できない場合があります\nブートストラップ・クラス・パスを自動的に設定するため、-source {0}のかわりに--release {0}をお薦めします

# 0: string
compiler.misc.source.no.system.modules.path=システム・モジュールの場所を設定しないと、クラス・ファイルがJDK {0}で実行できない場合があります\nシステム・モジュールの場所を自動的に設定するため、-source {0}のかわりに--release {0}をお薦めします

# 0: string, 1: string
compiler.misc.source.no.bootclasspath.with.target=ブートストラップ・クラス・パスを設定しないと、クラス・ファイルがJDK 8で実行できない場合があります\nブートストラップ・クラス・パスを自動的に設定するため、-source {0} -target {1}のかわりに--release {0}をお薦めします

# 0: string, 1: string
compiler.misc.source.no.system.modules.path.with.target=システム・モジュールの場所を設定しないと、クラス・ファイルがJDK {0}で実行できない場合があります\nシステム・モジュールの場所を自動的に設定するため、-source {0} -target {1}のかわりに--release {0}をお薦めします

# 0: string
compiler.warn.option.obsolete.source=ソース値{0}は廃止されていて、今後のリリースで削除される予定です

# 0: target
compiler.warn.option.obsolete.target=ターゲット値{0}は廃止されていて、今後のリリースで削除される予定です

# 0: string, 1: string
compiler.err.option.removed.source=ソース・オプション{0}は現在サポートされていません。{1}以降を使用してください。

# 0: target, 1: target
compiler.err.option.removed.target=ターゲット・オプション{0}は現在サポートされていません。{1}以降を使用してください。

compiler.warn.option.obsolete.suppression=廃止されたオプションについての警告を表示しないようにするには、-Xlint:オプションを使用します。

# 0: name, 1: number, 2: number, 3: number, 4: number
compiler.warn.future.attr=バージョン{1}.{2}のクラス・ファイルで導入された{0}属性は、バージョン{3}.{4}のクラス・ファイルでは無視されます

compiler.warn.requires.automatic=自動モジュールにはディレクティブが必要です

compiler.warn.requires.transitive.automatic=自動モジュールには推移的ディレクティブが必要です

# Warnings related to annotation processing
# 0: string
compiler.warn.proc.package.does.not.exist=パッケージ{0}は存在しません

# 0: string
compiler.warn.proc.file.reopening=''{0}''用のファイルを複数回作成しようとしています

# 0: string
compiler.warn.proc.type.already.exists=タイプ''{0}''のファイルはすでにソース・パスまたはクラスパスに存在します

# 0: string
compiler.warn.proc.type.recreate=タイプ''{0}''のファイルを複数回作成しようとしています

# 0: string
compiler.warn.proc.illegal.file.name=無効な名前''{0}''のファイルは作成できません。

# 0: string, 1: string
compiler.warn.proc.suspicious.class.name=名前が{1}で終わる型のファイルを作成しています: ''{0}''

# 0: string
compiler.warn.proc.file.create.last.round=最後に作成されたタイプ''{0}''のファイルは注釈処理に渡されません。

# 0: string, 1: string
compiler.warn.proc.malformed.supported.string=プロセッサ''{1}''が返したサポートされる注釈インタフェースの文字列''{0}''が不正です

# 0: set of string
compiler.warn.proc.annotations.without.processors=これらの注釈を要求するプロセッサはありませんでした: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=注釈プロセッサ''{1}''から-source ''{2}''より小さいソース・バージョン''{0}''がサポートされています

# 0: string, 1: string
compiler.warn.proc.duplicate.option.name=重複するサポート対象オプション''{0}''が注釈プロセッサ''{1}''によって返されました

# 0: string, 1: string
compiler.warn.proc.duplicate.supported.annotation=重複するサポート対象注釈インタフェース''{0}''が注釈プロセッサ''{1}''によって返されました

# 0: string
compiler.warn.proc.redundant.types.with.wildcard=注釈プロセッサ''{0}''は''*''と他の注釈インタフェースを重複してサポートします

compiler.warn.proc.proc-only.requested.no.procs=コンパイルなしの注釈処理がリクエストされましたが、プロセッサが見つかりませんでした。

compiler.warn.proc.use.implicit=暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-implicitを使用し暗黙的コンパイルのポリシーを指定してください。

compiler.warn.proc.use.proc.or.implicit=暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-proc:noneを使用し注釈処理を無効にするか -implicitを使用し暗黙的コンパイルのポリシーを指定してください。

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager={0}

# 0: set of string
compiler.warn.proc.unclosed.type.files=タイプ''{0}''のファイルが閉じられていません。これらのタイプは注釈処理されません

# 0: string
compiler.warn.proc.unmatched.processor.options=次のオプションはどのプロセッサでも認識されませんでした: ''{0}''

compiler.warn.try.explicit.close.call=自動クローズ可能なリソースにおけるclose()の明示的呼出し

# 0: symbol
compiler.warn.try.resource.not.referenced=自動クローズ可能なリソース{0}は対応するtry文の本体では参照されません

# 0: type
compiler.warn.try.resource.throws.interrupted.exc=自動クローズ可能なリソース{0}に、InterruptedExceptionをスローする可能性があるメンバー・メソッドclose()があります

compiler.warn.unchecked.assign={0}から{1}への無検査代入です

# 0: symbol, 1: type
compiler.warn.unchecked.assign.to.var=raw型{1}のメンバーとして変数{0}への無検査代入です

# 0: symbol, 1: type
compiler.warn.unchecked.call.mbr.of.raw.type=raw型{1}のメンバーとしての{0}への無検査呼出しです

compiler.warn.unchecked.cast.to.type=型{0}への無検査キャストです

# 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
compiler.warn.unchecked.meth.invocation.applied=無検査メソッド呼出し: {4} {5}の{0} {1}は指定された型に適用されます\n期待値: {2}\n検出値:    {3}

# 0: type
compiler.warn.unchecked.generic.array.creation=型{0}の可変引数パラメータに対する総称型配列の無検査作成です

# 0: type
compiler.warn.unchecked.varargs.non.reifiable.type=パラメータ化された可変引数型{0}からのヒープ汚染の可能性があります

# 0: symbol
compiler.warn.varargs.unsafe.use.varargs.param=可変引数メソッドは、型情報保持可能でない可変引数パラメータ{0}からのヒープ汚染の原因となる可能性があります

compiler.warn.missing.deprecated.annotation=推奨されない項目は@Deprecatedで注釈が付けられていません

# 0: kind name
compiler.warn.deprecated.annotation.has.no.effect=@Deprecated注釈は、この{0}宣言には影響しません

# 0: string
compiler.warn.invalid.path=ファイル名が無効です: {0}

compiler.warn.doclint.not.available=使用可能なdoclintのサービス・プロバイダはありません

# 0: string
compiler.err.invalid.path=ファイル名が無効です: {0}


# 0: path
compiler.warn.invalid.archive.file=パス上の予期しないファイル: {0}

# 0: path
compiler.warn.unexpected.archive.file=アーカイブ・ファイルの予期しない拡張子: {0}

# 0: path
compiler.err.no.zipfs.for.archive=このファイルの処理に使用できるファイル・システム・プロバイダがありません: {0}

compiler.warn.div.zero=ゼロで除算

compiler.warn.empty.if=if以降が空の文です

# 0: type, 1: name
compiler.warn.annotation.method.not.found=タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません

# 0: type, 1: name, 2: message segment
compiler.warn.annotation.method.not.found.reason=タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません: {2}

# 0: file object, 1: symbol, 2: name
compiler.warn.unknown.enum.constant=不明な列挙型定数です{1}.{2}

# 0: file object, 1: symbol, 2: name, 3: message segment
compiler.warn.unknown.enum.constant.reason=不明な列挙型定数です{1}.{2}\n理由: {3}

# 0: type, 1: type
compiler.warn.raw.class.use=raw型が見つかりました: {0}\n汎用クラス{1}の型引数がありません

compiler.warn.diamond.redundant.args=新しい式の型引数が重複しています(かわりにダイヤモンド演算子を使用します)。

compiler.warn.local.redundant.type=ローカル変数の型が重複しています(明示的な型を''var''に置き換えます)。

compiler.warn.potential.lambda.found=この匿名内部クラスをラムダ式に変換できます。

compiler.warn.method.redundant.typeargs=メソッド呼出しの型引数が重複しています。

# 0: symbol, 1: message segment
compiler.warn.varargs.redundant.trustme.anno={0}注釈が冗長です。{1}

# 0: symbol
compiler.warn.access.to.member.from.serializable.element=直列化可能要素からメンバー{0}へのアクセスは、信頼できないコードからパブリックにアクセス可能である可能性があります

# 0: symbol
compiler.warn.access.to.member.from.serializable.lambda=直列化可能ラムダからメンバー{0}へのアクセスは、信頼できないコードからパブリックにアクセス可能である可能性があります

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=<identifier>

compiler.misc.token.character=<character>

compiler.misc.token.string=<string>

compiler.misc.token.integer=<integer>

compiler.misc.token.long-integer=<long integer>

compiler.misc.token.float=<float>

compiler.misc.token.double=<double>

compiler.misc.token.bad-symbol=<bad symbol>

compiler.misc.token.end-of-input=<end of input>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected={0}がありません

# 0: string
compiler.err.expected.str={0}がありません

# 0: token, 1: token
compiler.err.expected2={0}または{1}がありません

# 0: token, 1: token, 2: token
compiler.err.expected3={0}、{1}または{2}がありません

# 0: token, 1: token, 2: token, 3: string
compiler.err.expected4={0}, {1}, {2}または{3}がありません

compiler.err.premature.eof=構文解析中にファイルの終わりに移りました

compiler.err.enum.constant.expected=ここに列挙型定数が必要です

compiler.err.enum.constant.not.expected=ここに列挙型定数は必要ありません

compiler.err.extraneous.semicolon=余分なセミコロン

compiler.warn.extraneous.semicolon=余分なセミコロン

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.expected.module.or.open=''モジュール''または''オープン''が必要です

compiler.err.dot.class.expected=''.class''がありません

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned={0}には親がありません

# 0: name
compiler.misc.anonymous.class=<anonymous {0}>

# 0: name, 1: type
compiler.misc.type.captureof={1}のキャプチャ#{0}

compiler.misc.type.captureof.1=キャプチャ#{0}

compiler.misc.type.none=<none>

compiler.misc.unnamed.package=名前のないパッケージ

compiler.misc.unnamed.module=名前のないモジュール

#####

# 0: symbol, 1: message segment
compiler.err.cant.access={0}にアクセスできません\n{1}

# 0: name
compiler.misc.bad.class.file=クラス{0}のクラス・ファイルが無効です

# 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
compiler.misc.bad.const.pool.entry={0}の定数プール・エントリが不正です\n索引{2}では{1}が必要です

# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
compiler.misc.bad.const.pool.index={0}の定数プール索引が不正です\n索引{1}が{2}のプール・サイズ内にありません。

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=クラス・ファイル{0}は不正です\n{1}\n削除するか、クラスパスの正しいサブディレクトリにあるかを確認してください。

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=ソース・ファイル{0}は不正です\n{1}\n削除するか、ソース・パスの正しいサブディレクトリにあるかを確認してください。

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=クラス{0}のシグニチャが不正です

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class={0}の内部クラスが不正です: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=クラス{0}の囲んでいるメソッド属性が不正です

compiler.misc.bad.runtime.invisible.param.annotations=RuntimeInvisibleParameterAnnotations属性が不正です: {0}

compiler.misc.bad.const.pool.tag=定数プール・タグ{0}が不正です

compiler.misc.bad.const.pool.tag.at=定数プール・タグ{1}での{0}が不正です

# 0: number
compiler.misc.bad.utf8.byte.sequence.at={0}でのUTF-8バイト・シーケンスが不正です

compiler.misc.unexpected.const.pool.tag.at=予期しない定数プール・タグ: {0}が{1}にあります

# 0: number
compiler.misc.bad.class.truncated.at.offset=クラス・ファイルがオフセット{0}で切り捨てられました

compiler.misc.bad.signature=シグニチャ{0}が不正です

compiler.misc.bad.type.annotation.value=注釈ターゲット型の値の型が不正です: {0}

compiler.misc.bad.module-info.name=クラス名が不正です

compiler.misc.class.file.wrong.class=クラス・ファイル{0}に不正なクラスがあります

compiler.misc.module.info.invalid.super.class=無効なスーパー・クラスを含むmodule-info

# 0: name
compiler.misc.class.file.not.found={0}のクラス・ファイルが見つかりません

# 0: string (constant value), 1: symbol (constant field), 2: type (field type)
compiler.misc.bad.constant.range={1}の定数値''{0}''は{2}の想定範囲外です

# 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
compiler.misc.bad.constant.value={1}の定数値''{0}''は不正です。{2}が必要です

# 0: type (field type)
compiler.misc.bad.constant.value.type=タイプ''{0}''の変数に定数値は指定できませんが、定数値が指定されています

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.default.interface=バージョン{0}.{1}のクラス・ファイルにデフォルト・メソッドが見つかりました

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.static.interface=バージョン{0}.{1}のクラス・ファイルにstaticメソッドが見つかりました

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.anachronistic.module.info=バージョン{0}.{1}のクラス・ファイルにモジュール宣言が見つかりました

compiler.misc.module.info.definition.expected=module-info定義が必要です

# 0: name
compiler.misc.file.doesnt.contain.class=ファイルにクラス{0}が含まれていません

# 0: symbol
compiler.misc.file.does.not.contain.package=ファイルにパッケージ{0}が含まれていません

compiler.misc.file.does.not.contain.module=ファイルにモジュール宣言が含まれていません

compiler.misc.illegal.start.of.class.file=クラス・ファイルの開始が不正です

# 0: name
compiler.misc.method.descriptor.invalid=メソッド・ディスクリプタが{0}に対して無効です

compiler.misc.unable.to.access.file=ファイル{0}にアクセスできません

compiler.misc.unicode.str.not.supported=クラス・ファイル内のUnicode文字列はサポートされていません

compiler.misc.undecl.type.var=型変数{0}は宣言されていません

compiler.misc.malformed.vararg.method=クラス・ファイルに不正な可変引数メソッドが含まれています: {0}

compiler.misc.wrong.version=クラス・ファイルのバージョン{0}.{1}は不正です。{2}.{3}である必要があります

compiler.misc.illegal.flag.combo=クラス・ファイルに{1} {2}の不正なフラグの組合せ{0}が含まれています

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=型引数{0}は型変数{1}の境界内にありません

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=不適合な型: {0}

# 0: message segment
compiler.misc.prob.found.req=不適合な型: {0}

# 0: message segment, 1: type, 2: type
compiler.warn.prob.found.req={0}\n期待値: {2}\n検出値:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types={0}を{1}に変換できません:

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=精度が失われる可能性がある{0}から{1}への変換

# 0: type, 1: type
compiler.warn.possible.loss.of.precision=複合代入における{0}から{1}への暗黙的キャストは、精度が失われる可能性があります

compiler.misc.unchecked.assign=無検査変換

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=無検査キャスト

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: message segment
compiler.misc.try.not.applicable.to.type=try-with-resourceは変数型に使用できません\n({0})

#####

# 0: object, 1: message segment
compiler.err.type.found.req=予期しない型\n期待値: {1}\n検出値:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=クラス

compiler.misc.type.req.class.array=クラスまたは配列

compiler.misc.type.req.array.or.iterable=配列またはjava.lang.Iterable

compiler.misc.type.req.ref=参照

compiler.misc.type.req.exact=境界のないクラスまたはインタフェース

# 0: type
compiler.misc.type.parameter=型パラメータ{0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=型変数{0}(上限{1})の固有の最大インスタンスが存在しません

# 0: type, 1: list of type
compiler.misc.no.unique.minimal.instance.exists=型変数{0}(下限{1})の固有の最小インスタンスが存在しません

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=推測の変数{0}には、適合しない上限{1}があります

# 0: type, 1: list of type
compiler.misc.incompatible.eq.bounds=推論変数{0}には、不適合な等価制約{1}があります

# 0: type, 1: fragment, 2: fragment
compiler.misc.incompatible.bounds=推論変数{0}には、不適合な境界があります\n{1}\n{2}

# 0: list of type
compiler.misc.lower.bounds=下限: {0}

# 0: list of type
compiler.misc.eq.bounds=等価制約: {0}

# 0: list of type
compiler.misc.upper.bounds=上限: {0}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=型変数{0}のインスタンスが存在しないので、{1}は{2}に適合しません

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=型変数{0}を推論できません\n(引数の不一致: {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=型変数{0}を推論できません\n(実引数リストと仮引数リストの長さが異なります)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=型変数{0}を推論できません\n(可変引数の不一致: {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=推論型が上限に適合しません\n推論: {0}\n上限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=推論型が下限に適合しません\n推論: {0}\n下限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=推論型が等価制約に適合しません\n推論: {0}\n等価制約: {1}

# 0: symbol
compiler.misc.diamond={0}<>

# 0: type
compiler.misc.diamond.non.generic=非汎用クラス{0}で''<>''を使用することはできません

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.arg={1}について推定された型引数{0}はこのコンテキストでは許可されません\n推論引数は署名属性に表現できません

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.args={1}について推定された型引数{0}はこのコンテキストでは許可されません\n推論引数は署名属性に表現できません

# 0: type
compiler.misc.diamond.and.explicit.params=コンストラクタの明示的な型パラメータでは''<>''を使用できません

compiler.misc.mref.infer.and.explicit.params=コンストラクタの明示的な型パラメータではrawコンストラクタ参照を使用できません

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=明示的な型引数{0}は、宣言された境界{1}に適合しません

compiler.misc.arg.length.mismatch=実引数リストと仮引数リストの長さが異なります

# 0: string
compiler.misc.wrong.number.type.args=型引数の数が不正です。{0}個必要です

# 0: message segment
compiler.misc.no.conforming.assignment.exists=引数の不一致: {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=可変引数の不一致: {0}

#####

# 0: symbol or type, 1: file name
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file={1}の補助クラス{0}にソース・ファイル外からアクセスできません

## The first argument ({0}) is a "kindname".
# 0: kind name, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly=抽象{0}である{1}({2}内)に直接アクセスすることはできません

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref=staticでない{0} {1}をstaticコンテキストから参照することはできません

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.unbound.lookup=非バインド検索で予期しない静的な{0} {1}が見つかりました

# 0: symbol kind, 1: symbol
compiler.misc.bad.instance.method.in.unbound.lookup=非バインド検索で予期しないインスタンス{0} {1}が見つかりました

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.bound.lookup=バインド検索で予期しない静的な{0} {1}が見つかりました

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
# 0: set of kind name, 1: set of kind name
compiler.err.unexpected.type=予期しない型\n期待値: {0}\n検出値:    {1}

compiler.err.unexpected.lambda=ここではラムダ式は予期されていません

compiler.err.unexpected.mref=ここではメソッド参照は予期されていません

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: kind name, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=シンボルを見つけられません\nシンボル: {0} {1}

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=シンボルを見つけられません\nシンボル: {0} {1}({3})

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.misc.cant.resolve.args=シンボルを見つけられません\nシンボル: {0} {1}({3})

# 0: kind name, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=シンボルを見つけられません\nシンボル: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=シンボルを見つけられません\nシンボル:   {0} {1}\n場所: {4}

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=シンボルを見つけられません\nシンボル:   {0} {1}({3})\n場所: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=シンボルを見つけられません\nシンボル:   {0} <{2}>{1}({3})\n場所: {4}

### Following are replicated/used for method reference diagnostics

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=シンボルを見つけられません\nシンボル:   {0} {1}({3})\n場所: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=シンボルを見つけられません\nシンボル:   {0} <{2}>{1}({3})\n場所: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: kind name, 1: type or symbol, 2: unused
compiler.misc.location={0} {1}

# 0: kind name, 1: symbol, 2: type
compiler.misc.location.1=タイプ{2}の{0} {1}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=@interface

compiler.misc.kindname.constructor=コンストラクタ

compiler.misc.kindname.enum=列挙

compiler.misc.kindname.interface=インタフェース

compiler.misc.kindname.static=static

compiler.misc.kindname.type.variable=型変数

compiler.misc.kindname.type.variable.bound=型変数の境界

compiler.misc.kindname.variable=変数

compiler.misc.kindname.value=値

compiler.misc.kindname.method=メソッド

compiler.misc.kindname.class=クラス

compiler.misc.kindname.package=パッケージ

compiler.misc.kindname.module=モジュール

compiler.misc.kindname.static.init=static初期化子

compiler.misc.kindname.instance.init=インスタンス初期化子

compiler.misc.kindname.record.component=レコード・コンポーネント

compiler.misc.kindname.record=レコード

#####

compiler.misc.no.args=引数がありません

# 0: message segment
compiler.err.override.static={0}\nオーバーライドするメソッドがstaticです

# 0: message segment, 1: set of flag
compiler.err.override.meth={0}\nオーバーライドされたメソッドは{1}です

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw={0}\nオーバーライドされたメソッドは{1}をスローしません

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of flag or string
compiler.err.override.weaker.access={0}\n({1})より弱いアクセス権限を割り当てようとしました

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret={0}\n戻り値の型{1}は{2}と互換性がありません

# 0: message segment, 1: type, 2: type
compiler.warn.override.unchecked.ret={0}\n戻り値の型は{1}から{2}への無検査変換が必要です

# 0: message segment, 1: type
compiler.warn.override.unchecked.thrown={0}\nオーバーライドされたメソッドは{1}をスローしません

# 0: symbol
compiler.warn.override.equals.but.not.hashcode=クラス{0}はequalsをオーバーライドしますが、このクラスも、また、いかなるスーパークラスも、hashCodeメソッドをオーバーライドしません

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override={1}の{0}は{3}の{2}をオーバーライドできません

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.hide={1}の{0}は{3}の{2}を隠すことはできません

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement={1}の{0}は{3}の{2}を実装できません

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with={1}の{0}は{3}の{2}と競合します

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override={1}の{0}は{3}の{2}をオーバーライドします

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement={1}の{0}は{3}の{2}を実装します

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with={1}の{0}は{3}の{2}をオーバーライドします

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override={1}の{0}は{3}の{2}をオーバーライドします

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement={1}の{0}は{3}の{2}を実装します

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with={1}の{0}は{3}の{2}をオーバーライドします

# 0: kind name, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method={0} {1}.{2}は使用できません\n({3})

########################################
# Diagnostics for language feature changes.
# Such diagnostics have a common template which can be customized by using a feature
# diagnostic fragment (one of those given below).
########################################

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source={0}は-source {1}でサポートされていません\n({0}を有効にするには-source {2}以上を使用してください)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source.plural={0}は-source {1}でサポートされていません\n({0}を有効にするには-source {2}以上を使用してください)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source={0}は-source {1}でサポートされていません\n({0}を有効にするには-source {2}以上を使用してください)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source.plural={0}は-source {1}でサポートされていません\n({0}を有効にするには-source {2}以上を使用してください)

# 0: message segment (feature)
compiler.err.preview.feature.disabled={0}はプレビュー機能であり、デフォルトで無効になっています。\n({0}を有効にするには--enable-previewを使用します)

# 0: message segment (feature)
compiler.err.preview.feature.disabled.plural={0}はプレビュー機能であり、デフォルトで無効になっています。\n({0}を有効にするには--enable-previewを使用します)

# 0: file object (classfile), 1: string (expected version)
compiler.err.preview.feature.disabled.classfile={0}のクラス・ファイルはJava SE {1}のプレビュー機能を使用します。\n(プレビュー機能を含むクラス・ファイルをロードできるようにするには、--enable-previewを使用します)

# 0: message segment (feature)
compiler.warn.preview.feature.use={0}はプレビュー機能であり、今後のリリースで削除される可能性があります。

# 0: message segment (feature)
compiler.warn.preview.feature.use.plural={0}はプレビュー機能であり、今後のリリースで削除される可能性があります。

# 0: file object (classfile), 1: string (expected version)
compiler.warn.preview.feature.use.classfile={0}のクラス・ファイルはJava SE {1}のプレビュー機能を使用します。

compiler.misc.feature.modules=モジュール

compiler.misc.feature.diamond.and.anon.class=匿名内部クラスでの''<>''

compiler.misc.feature.var.in.try.with.resources=try-with-resources内の変数

compiler.misc.feature.private.intf.methods=privateインタフェース・メソッド

compiler.misc.feature.text.blocks=テキスト・ブロック

compiler.misc.feature.multiple.case.labels=複数のcaseラベル

compiler.misc.feature.switch.rules=switchルール

compiler.misc.feature.switch.expressions=switch式

compiler.misc.feature.var.syntax.in.implicit.lambda=暗黙ラムダのvar構文

compiler.misc.feature.pattern.matching.instanceof=instanceofでのパターンの一致

compiler.misc.feature.reifiable.types.instanceof=instanceofでのreifiable型

compiler.misc.feature.deconstruction.patterns=デコンストラクション・パターン

compiler.misc.feature.unnamed.variables=無名変数

compiler.misc.feature.primitive.patterns=プリミティブ・パターン

compiler.misc.feature.records=レコード

compiler.misc.feature.sealed.classes=シール・クラス

compiler.misc.feature.case.null=switch caseのnull

compiler.misc.feature.pattern.switch=switch文のパターン

compiler.misc.feature.unconditional.patterns.in.instanceof=instanceofでの無条件パターン

compiler.misc.feature.implicit.classes=暗黙的に宣言されたクラス

compiler.misc.feature.flexible.constructors=柔軟なコンストラクタ

compiler.misc.feature.module.imports=モジュール・インポート

compiler.warn.underscore.as.identifier=リリース9から''_''はキーワードなので識別子として使用することはできません

compiler.err.underscore.as.identifier=リリース9から''_''はキーワードなので識別子として使用することはできません

compiler.err.use.of.underscore.not.allowed=アンダースコアはここでは許可されません\nリリース9から、''_''はキーワードなので識別子として使用することはできません\nリリース22から、無名パターン、ローカル変数、例外パラメータまたはラムダ・パラメータの宣言には''_''を名前として使用できます

compiler.err.use.of.underscore.not.allowed.non.variable=アンダースコアはここでは許可されません

compiler.err.use.of.underscore.not.allowed.with.brackets=アンダースコア・キーワード''_''に大カッコを続けることはできません

compiler.err.enum.as.identifier=リリース5から''enum'はキーワードなので識別子として使用することはできません

compiler.err.assert.as.identifier=リリース1.4から''assert''はキーワードなので識別子として使用することはできません

# TODO 308: make a better error message
compiler.err.this.as.identifier=リリース8から''this''は受信タイプのパラメータ名としてのみ許可されます\nこれは最初のパラメータにする必要があり、ラムダ・パラメータにはできません

compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=受取り側パラメータは最上位レベル・クラスのコンストラクタに適用できません

# 0: fragment, 1: symbol, 2: annotated-type
compiler.err.type.annotation.inadmissible=ここでは{0}は予期されていません\n(修飾されたタイプに注釈を付けるには、{1}.{2}と記述します)

# 0: annotation
compiler.misc.type.annotation.1=タイプ注釈{0}は

# 0: list of annotation
compiler.misc.type.annotation=タイプ注釈{0}は

# 0: type, 1: type
compiler.err.incorrect.receiver.name=受取り側の名前が、包含するクラス・タイプと一致しません\n必須: {0}\n検出:    {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=受取り側のタイプが、包含するクラス・タイプと一致しません\n必須: {0}\n検出:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=受取り側のタイプが、包含する外部クラス・タイプと一致しません\n必須: {0}\n検出:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=受取り側の名前が、包含する外部クラス・タイプと一致しません\n必須: {0}\n検出:    {1}

compiler.err.no.annotations.on.dot.class=注釈はクラス・リテラルのタイプで許可されません

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=#{0}個の使用可能メソッドが見つかりました: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=#{0}個の使用可能メソッドが見つかりました: {1}\n({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=#{0}個の使用できないメソッドが見つかりました: {1}\n({2})

# 0: type
compiler.misc.partial.inst.sig=部分的にインスタンス化されました: {0}

# 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=型{1}のメソッド{0}を候補{2}に解決しています\nフェーズ: {3}\n実際の型: {4}\n型引数: {5}\n候補:

# 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=型{1}のメソッド{0}の解決にエラーがあります\nフェーズ: {3}\n実際の型: {4}\n型引数: {5}\n候補:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=メソッド{0}の遅延インスタンス化\nインスタンス化されたシグネチャ: {1}\nターゲット型: {2}

########################################
# Diagnostics for lambda deduplication
# used by LambdaToMethod (debug only)
########################################

# 0: symbol
compiler.note.verbose.l2m.deduplicate=重複除外ラムダ実装メソッド{0}

########################################
# Diagnostics for method reference search
# results used by Resolve (debug only)
########################################

# 0: fragment, 1: string, 2: number
compiler.note.method.ref.search.results.multi={1}の{0}の検索結果(最も厳密なもの{2}個)\n使用可能な候補:

# 0: number, 1: fragment, 2: symbol
compiler.misc.applicable.method.found.2=使用可能メソッドが#{0}個見つかりました: {1} {2}

# 0: number, 1: fragment, 2: symbol, 3: message segment
compiler.misc.applicable.method.found.3=使用可能メソッドが#{0}個見つかりました: {1} {2}\n({3})

compiler.misc.static=static

compiler.misc.non.static=staticでない

compiler.misc.bound=バインド

compiler.misc.unbound=バインドなし

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=<null>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var={0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured={3}のキャプチャからの{0} extends {1} super: {2}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1={3}のキャプチャからの{0} extends {1}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar={2} {3}で宣言されている{0} extends {1}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1={2} {3}で宣言された{0}

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar={0}は{1}を拡張します

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection={0} extends {1}

### Where clause headers ###
compiler.misc.where.description.captured={0}が新しい型変数の場合:

# 0: set of type
compiler.misc.where.description.typevar={0}が型変数の場合:

# 0: set of type
compiler.misc.where.description.intersection={0}がintersection型の場合:

# 0: set of type
compiler.misc.where.description.captured.1={0}が新しい型変数の場合:

# 0: set of type
compiler.misc.where.description.typevar.1={0}が型変数の場合:

# 0: set of type
compiler.misc.where.description.intersection.1={0}がintersection型の場合:

###
# errors related to doc comments

compiler.err.dc.bad.entity=HTMLエンティティが不正です

compiler.err.dc.bad.inline.tag=インライン・タグの使用が正しくありません

compiler.err.dc.identifier.expected=識別子が必要です

compiler.err.dc.invalid.html=HTMLが無効です

compiler.err.dc.malformed.html=HTMLが不正です

compiler.err.dc.missing.semicolon=セミコロンがありません

compiler.err.dc.no.content=コンテンツなし

compiler.err.dc.no.tag.name=''@''の後にタグ名がありません

compiler.err.dc.no.url=URLがありません

compiler.err.dc.no.title=タイトルがありません

compiler.err.dc.gt.expected=''>''が必要です

compiler.err.dc.ref.bad.parens=カッコの後の予期しないテキストです

compiler.err.dc.ref.syntax.error=参照に構文エラーがあります

compiler.err.dc.ref.unexpected.input=予期しないテキストです

compiler.err.dc.unexpected.content=予期しないコンテンツです

compiler.err.dc.unterminated.inline.tag=インライン・タグが終了していません

compiler.err.dc.unterminated.signature=シグネチャが終了していません

compiler.err.dc.unterminated.string=文字列が終了していません

compiler.err.dc.ref.annotations.not.allowed=注釈は許可されません

###
# errors related to modules

compiler.err.expected.module=''モジュール''が必要です

# 0: symbol
compiler.err.module.not.found=モジュールが見つかりません: {0}

# 0: symbol
compiler.warn.module.not.found=モジュールが見つかりません: {0}

# 0: name
compiler.err.import.module.not.found=インポートされたモジュールが見つかりません: {0}

# 0: symbol
compiler.err.import.module.does.not.read.unnamed=名前のないモジュールでは読取りは行われません: {0}

# 0: symbol, 1: symbol
compiler.err.import.module.does.not.read=モジュール{0}では読取りは行われません: {1}

compiler.err.too.many.modules=検出されたモジュール宣言が多すぎます

compiler.err.module.not.found.on.module.source.path=モジュール・ソース・パスにモジュールが見つかりません

compiler.err.not.in.module.on.module.source.path=モジュール・ソース・パスのモジュールにありません

# 0: symbol
compiler.err.duplicate.module=モジュールが重複しています: {0}

# 0: symbol
compiler.err.duplicate.requires=必須が重複しています: {0}

# 0: symbol
compiler.err.conflicting.exports=エクスポートが重複または競合しています: {0}

# 0: symbol
compiler.err.conflicting.opens=オープンが重複または競合しています: {0}

# 0: symbol
compiler.err.conflicting.exports.to.module=モジュールへのエクスポートが重複または競合しています: {0}

# 0: symbol
compiler.err.conflicting.opens.to.module=モジュールへのオープンが重複または競合しています: {0}

compiler.err.no.opens.unless.strong=''opens''は強固なモジュールでのみ許可されます

# 0: symbol
compiler.err.repeated.provides.for.service=サービス{0}に複数の''provides''があります

# 0: symbol, 1: symbol
compiler.err.duplicate.provides=指定が重複しています: サービス{0}、実装{1}

# 0: symbol
compiler.err.duplicate.uses=使用が重複しています: {0}

# 0: symbol
compiler.err.service.implementation.is.abstract=サービス実装が抽象クラスです: {0}

compiler.err.service.implementation.must.be.subtype.of.service.interface=サービス実装タイプは、サービス・インタフェース・タイプのサブタイプであるか、サービス実装を戻し、引数を持たない、"provider"という名前のpublic staticメソッドを持つ必要があります

compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface="provider"メソッドの戻りタイプは、サービス・インタフェース・タイプのサブタイプである必要があります

# 0: symbol
compiler.err.service.implementation.is.inner=サービス実装が内部クラスです: {0}

# 0: symbol
compiler.err.service.definition.is.enum=サービス定義が列挙型です: {0}

# 0: symbol
compiler.err.service.implementation.doesnt.have.a.no.args.constructor=サービス実装のデフォルト・コンストラクタがありません: {0}

# 0: symbol
compiler.err.service.implementation.no.args.constructor.not.public=サービス実装の引数なしのコンストラクタがパブリックではありません: {0}

# 0: symbol
compiler.err.package.empty.or.not.found=パッケージは空であるか、または存在しません {0}

# 0: symbol
compiler.warn.package.empty.or.not.found=パッケージは空であるか、または存在しません {0}

compiler.err.no.output.dir=クラス出力ディレクトリが指定されていません

compiler.err.unnamed.pkg.not.allowed.named.modules=名前のないパッケージは名前付きモジュールでは許可されません

# 0: name, 1: name
compiler.err.module.name.mismatch=モジュール名{0}は必要な名前{1}と一致しません

# 0: name, 1: name
compiler.misc.module.name.mismatch=モジュール名{0}は必要な名前{1}と一致しません

# 0: name
compiler.err.module.non.zero.opens=オープン・モジュール{0}はゼロでないopens_countを持ちます

# 0: name
compiler.misc.module.non.zero.opens=オープン・モジュール{0}はゼロでないopens_countを持ちます

compiler.err.module.decl.sb.in.module-info.java=モジュール宣言はmodule-info.javaという名前のファイルにある必要があります

# 0: set of string
compiler.err.too.many.patched.modules=パッチ適用モジュールが多すぎます({0})。--module-source-pathを使用してください

# 0: name, 1: name
compiler.err.file.patched.and.msp=ファイルは、--patch-moduleと--module-source-pathの両方からアクセス可能ですが、各パス上の異なるモジュールに属しています: {0}, {1}

compiler.err.processorpath.no.processormodulepath=-processorpathと--processor-module-pathの組合せが不正です

# 0: symbol
compiler.err.package.in.other.module=パッケージが別のモジュールに存在します: {0}

# 0: symbol, 1: name, 2: symbol, 3: symbol
compiler.err.package.clash.from.requires=モジュール{0}は{2}と{3}の両方からパッケージ{1}を読み取ります

# 0: name, 1: symbol, 2: symbol
compiler.err.package.clash.from.requires.in.unnamed=名前のないモジュ－ルは{1}と{2}の両方からパッケージ{0}を読み取ります

# 0: string
compiler.err.module.not.found.in.module.source.path=モジュール・ソース・パスにモジュール{0}が見つかりません

compiler.err.output.dir.must.be.specified.with.dash.m.option=-mオプションを使用する場合、クラス出力ディレクトリを指定する必要があります

compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=-mオプションを使用する場合、モジュール・ソース・パスを指定する必要があります

# 0: symbol
compiler.err.service.implementation.not.in.right.module=サービス実装をprovidesディレクティブとして同じモジュールに定義する必要があります

# 0: symbol
compiler.err.cyclic.requires={0}を含む依存性がループしています

# 0: fragment, 1: name
compiler.err.duplicate.module.on.path={0}でモジュールが重複しています\n{1}のモジュール

# 0: option name, 1: string
compiler.warn.bad.name.for.option={0}オプションの値に含まれる名前が不正です: ''{1}''

# 0: option name, 1: string
compiler.err.bad.name.for.option={0}オプションの値に含まれる名前が不正です: ''{1}''

# 0: option name, 1: symbol
compiler.warn.module.for.option.not.found={0}オプション内にモジュール名が見つかりません: {1}

compiler.err.addmods.all.module.path.invalid=--add-modules ALL-MODULE-PATHは、名前のないモジュールのコンパイル時または自動モジュールのコンテキストでのコンパイル時のみ使用できます

# 0: symbol
compiler.err.add.exports.with.release=システム・モジュール{0}からのパッケージのエクスポートは--releaseを指定して実行できません

# 0: symbol
compiler.err.add.reads.with.release=システム・モジュール{0}の読取りエッジの追加は--releaseを指定して実行できません

compiler.warn.addopens.ignored=--add-opensは、コンパイル時には無効です

compiler.misc.locn.module_source_path=モジュール・ソース・パス

compiler.misc.locn.upgrade_module_path=アップグレード・モジュール・パス

compiler.misc.locn.system_modules=システム・モジュール

compiler.misc.locn.module_path=アプリケーション・モジュール・パス

compiler.misc.cant.resolve.modules=モジュールを解決できません

compiler.misc.bad.requires.flag=不正な必須フラグ: {0}

# 0: string
compiler.err.invalid.module.specifier=モジュール指定子は許可されません: {0}

# 0: symbol
compiler.warn.service.provided.but.not.exported.or.used=サービス・インタフェースが指定されましたが、エクスポートまたは使用されていません

# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible=モジュール{2}の{0} {1}は、このモジュールを必要とするクライアントからアクセスできません
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported=モジュール{2}の{0} {1}はエクスポートされません
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.not.required.transitive=モジュール{2}の{0} {1}は、''requires transitive''を使用して間接的にエクスポートされません
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported.qualified=モジュール{2}の{0} {1}は、このモジュールを必要とするすべてのクライアントに表示されない可能性があります

###
# errors related to options

# 0: string, 1: string
compiler.err.illegal.argument.for.option={0}の引数が不正です: {1}

compiler.err.match.binding.exists=既存の一致バインディングを再定義することはできません

compiler.err.switch.case.unexpected.statement=caseの予期しない文です。予期されるのは、式、ブロックまたはthrow文です

compiler.err.switch.mixing.case.types=switchでcaseの異なる種類が使用されています

###
# errors related to sealed classes

# permits clause
# 0: fragment
compiler.err.invalid.permits.clause=無効なpermits句\n({0})

# 0: string
compiler.misc.class.is.not.sealed={0}はシールする必要があります

# 0: type
compiler.misc.is.a.type.variable=型変数を含めることはできません: {0}

# 0: type
compiler.misc.is.duplicated=重複を含めることはできません: {0}

# 0: type
compiler.misc.doesnt.extend.sealed=サブクラス{0}はシール・クラスを拡張する必要があります

compiler.misc.must.not.be.same.class=permits句の自己参照が不正です

# 0: type
compiler.misc.must.not.be.supertype=スーパータイプ{0}への参照が不正です

# other sealed types related errors

compiler.err.sealed.class.must.have.subclasses=シール・クラスにはサブクラスを含める必要があります

# errors in subclasses of sealed classes
# 0: symbol
compiler.err.cant.inherit.from.sealed=クラスはシール・クラス{0}を拡張できません(''permits''句に指定されていないためです)

# 0: symbol
compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=名前のないモジュールのクラス{0}は別のパッケージのシール・クラスを拡張できません

# 0: symbol, 1: symbol
compiler.err.class.in.module.cant.extend.sealed.in.diff.module=モジュール{1}のクラス{0}は別のモジュールのシール・クラスを拡張できません

# 0: symbol
compiler.err.non.sealed.with.no.sealed.supertype=non-sealed修飾子はここでは許可されません\n(クラス{0}にシール・スーパータイプが含まれていません)

compiler.err.non.sealed.sealed.or.final.expected=sealed、non-sealedまたはfinal修飾子が必要です

compiler.err.non.sealed.or.sealed.expected=sealedまたはnon-sealed修飾子が必要です

compiler.err.sealed.or.non.sealed.local.classes.not.allowed=sealedまたはnon-sealedのローカル・クラスは許可されません

# 0: fragment
compiler.err.local.classes.cant.extend.sealed={0}クラスはシール・クラスを拡張できません
compiler.misc.anonymous=匿名

compiler.misc.local=ローカル

###
# errors related to records

# record components
compiler.err.record.cant.declare.field.modifiers=レコード・コンポーネントに修飾子を使用することはできません

# 0: symbol
compiler.err.illegal.record.component.name=レコード・コンポーネント名{0}が無効です

compiler.err.record.component.and.old.array.syntax=旧式の配列表記法はレコード・コンポーネントでは使用できません

# accessor methods
# 0: symbol, 1: fragment
compiler.err.invalid.accessor.method.in.record=レコード{0}に無効なアクセサ・メソッドがあります\n({1})

compiler.misc.method.must.be.public=アクセサ・メソッドはpublicである必要があります

# 0: symbol, 1: symbol
compiler.misc.accessor.return.type.doesnt.match=アクセサ・メソッド{0}の戻り型はレコード・コンポーネント{1}のタイプと一致する必要があります

compiler.misc.accessor.method.cant.throw.exception=throws句をアクセサ・メソッドで使用することはできません

compiler.misc.accessor.method.must.not.be.generic=アクセサ・メソッドは汎用にできません

compiler.misc.accessor.method.must.not.be.static=アクセサ・メソッドは静的にできません

# canonical constructors
# 0: fragment, 1: name, 2: fragment
compiler.err.invalid.canonical.constructor.in.record=レコード{1}に無効な{0}コンストラクタがあります\n({2})

compiler.misc.canonical=標準

compiler.misc.compact=コンパクト

# 0: fragment
compiler.misc.throws.clause.not.allowed.for.canonical.constructor=throws句は{0}コンストラクタでは許可されません

compiler.misc.canonical.with.name.mismatch=標準コンストラクタのパラメータ名が無効です

compiler.misc.canonical.cant.have.return.statement=コンパクト・コンストラクタにRETURN文を含めることはできません

compiler.misc.canonical.must.not.declare.type.variables=標準コンストラクタは型変数を宣言できません

compiler.misc.type.must.be.identical.to.corresponding.record.component.type=型と引数の数は対応するレコード・コンポーネントのものと一致する必要があります
compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=標準コンストラクタに明示的なコンストラクタ呼出しを含めることはできません

# 0: set of flag or string
compiler.misc.canonical.must.not.have.stronger.access=({0})より強いアクセス権限を割り当てようとしました

# other
compiler.err.record.cannot.declare.instance.fields=フィールド宣言は静的である必要があります\n(フィールドをレコード・コンポーネントに置換することを検討)

# 0: symbol
compiler.err.invalid.supertype.record=クラスは直接{0}を拡張できません

# 0: symbol
compiler.err.non.canonical.constructor.invoke.another.constructor=コンストラクタが標準でないため、クラス{0}の他のコンストラクタを呼び出す必要があります

compiler.err.instance.initializer.not.allowed.in.records=インスタンス・イニシャライザはレコードでは使用できません

compiler.err.static.declaration.not.allowed.in.inner.classes=静的宣言は内部クラスでは許可されません

compiler.err.record.patterns.annotations.not.allowed=注釈はレコード・パターンでは許可されません

############################################
# messages previously at javac.properties

compiler.err.empty.A.argument=-Aには引数が必要です。''-Akey''または''-Akey=value''を使用してください

# 0: string
compiler.err.invalid.A.key=注釈プロセッサ・オプション''{0}''のキーに指定されている一連の識別子が、ドットで区切られていません

# 0: string
compiler.err.invalid.flag={0}は無効なフラグです

compiler.err.profile.bootclasspath.conflict=profileとbootclasspathオプションは同時に使用できません

# 0: string
compiler.err.invalid.profile=無効なプロファイル: {0}

# 0: string
compiler.err.invalid.target={0}は無効なターゲット・リリースです

# 0: option name, 1: target
compiler.err.option.not.allowed.with.target=オプション{0}はターゲット{1}とともに指定できません

# 0: string
compiler.err.option.too.many=オプション{0}を指定できるのは1回のみです

compiler.err.no.source.files=ソース・ファイルがありません

compiler.err.no.source.files.classes=ソース・ファイルまたはクラス名がありません

# 0: string
compiler.err.req.arg={0}には引数が必要です

# 0: string
compiler.err.invalid.source={0}は無効なソース・リリースです

# 0: string, 1: string
compiler.err.error.writing.file={0}の書込みエラーです。{1}

compiler.err.sourcepath.modulesourcepath.conflict=--source-pathと--module-source-pathの両方を指定できません

# 0: string, 1: string
compiler.err.source.target.conflict=指定のターゲット・リリース{1}は、指定したソース・リリース{0}に対して古すぎます\nJDK {1}で実行するコードをコンパイルするときは、--release {1}をお薦めします

# 0: string, 1: string
compiler.err.target.default.source.conflict=指定のターゲット・リリース{1}は、デフォルトのソース・リリース{0}に対して古すぎます\nJDK {1}で実行するコードをコンパイルするときは、--release {1}をお薦めします

# 0: profile, 1: target
compiler.warn.profile.target.conflict=プロファイル{0}はターゲット・リリース{1}に対して有効ではありません

# 0: string
compiler.err.file.not.directory=ディレクトリではありません: {0}

# 0: object
compiler.err.file.not.file=ファイルではありません: {0}

compiler.err.two.class.loaders.1=javacが複数のクラス・ローダー間で分割されています: 構成を確認してください

# 0: url, 1: url
compiler.err.two.class.loaders.2=javacが複数のクラス・ローダー間で分割されています:\nクラスの取得元ファイル: {0}\njavacの取得元: {1}

# 0: string, 1: string
compiler.err.bad.value.for.option={0}オプションの値が不正です: ''{1}''

# 0: string
compiler.err.no.value.for.option={0}オプションの値がありません

# 0: string
compiler.err.repeated.value.for.patch.module=モジュール{0}に対して--patch-moduleが複数回指定されています

# 0: string
compiler.err.repeated.value.for.module.source.path=モジュール{0}に対して--module-source-pathが複数回指定されています

compiler.err.multiple.values.for.module.source.path=パターン引数で--module-source-pathが複数回指定されています

# 0: string
compiler.err.unmatched.quote=環境変数{0}の引用符が一致しません

# 0: option name
compiler.err.release.bootclasspath.conflict=オプション{0}は--releaseと一緒に使用できません

# 0: string
compiler.err.unsupported.release.version=リリース・バージョン{0}はサポートされていません

# 0: string
compiler.err.file.not.found=ファイルが見つかりません: {0}

# 0: string, 1: source
compiler.err.preview.not.latest=--enable-previewが指定されたソース・リリース{0}は無効です\n(プレビュー言語機能はリリース{1}でのみサポートされています)

compiler.err.preview.without.source.or.release=--enable-previewは-sourceまたは--releaseとともに使用する必要があります

# 0: symbol
compiler.err.deconstruction.pattern.only.records=デコンストラクション・パターンはレコードにのみ適用できます。{0}はレコードではありません

compiler.err.deconstruction.pattern.var.not.allowed=デコンストラクション・パターンはレコードにのみ適用できます。varは許可されません

# 0: list of type, 1: list of type
compiler.err.incorrect.number.of.nested.patterns=ネスト・パターンの数が正しくありません\n期待値: {0}\n検出値: {1}

# 0: kind name, 1: symbol
compiler.warn.declared.using.preview={0} {1}はプレビュー機能を使用して宣言されており、今後のリリースで削除される可能性があります。

compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class=値ベース・クラスのインスタンスで同期しようとしました

# 0: type
compiler.err.enclosing.class.type.non.denotable=包含するクラス型: {0}\nは非型指定です。型指定型にキャストしてみてください
