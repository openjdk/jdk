#
# Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The simple types currently in use are:
#
# annotation        annotation compound
# boolean           true or false
# diagnostic        a sub-message; see compiler.misc.*
# fragment          similar to 'message segment', but with more specific type
# modifier          a Java modifier; e.g. public, private, protected
# file              a file URL
# file object       a file URL - similar to 'file' but typically used for source/class files, hence more specific
# flag              a Flags.Flag instance
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# path              a path
# profile           a profile name
# source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
# source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
# string            a general string
# symbol            the name of a declared type
# symbol kind       the kind of a symbol (i.e. method, variable)
# kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
# target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# url               a URL
# object            a Java object (unspecified)
# unused            the value is not used in this message
#
# The following compound types are also used:
#
# collection of X   a comma-separated collection of items; e.g. collection of type
# list of X         a comma-separated list of items; e.g. list of type
# set of X          a comma-separated set of items; e.g. set of modifier
#
# These may be composed:
#
# list of type or message segment
#
# The following type aliases are supported:
#
# message segment --> diagnostic or fragment
# file name --> file, path or file object
#
# Custom comments are supported in parenthesis i.e.
#
# number (classfile major version)
#
# These comments are used internally in order to generate an enum-like class declaration containing
# a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
# by javac code to build diagnostics in a type-safe fashion.
#
# In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated={0} ist abstrakt, kann nicht instanziiert werden

compiler.err.abstract.meth.cant.have.body=Abstrakte Methoden können keinen Body enthalten

# 0: kind name, 1: symbol
compiler.err.already.annotated={0} {1} wurde bereits mit Annotation versehen

# 0: kind name, 1: symbol, 2: kind name, 3: symbol
compiler.err.already.defined={0} {1} ist bereits in {2} {3} definiert

# 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
compiler.err.already.defined.in.clinit={0} {1} ist bereits in {2} von {3} {4} definiert

# 0: symbol
compiler.err.already.defined.single.import=Es wurde bereits ein Typ mit demselben einfachen Namen durch den Einzeltypimport von {0} definiert

# 0: symbol
compiler.err.already.defined.static.single.import=Es wurde bereits ein Typ mit demselben einfachen Namen durch den statischen Einzeltypimport von {0} definiert

# 0: symbol
compiler.err.already.defined.this.unit={0} ist in dieser Kompilierungseinheit bereits definiert

compiler.err.annotation.missing.element.value=In Annotation fehlt ein Elementwert

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=In Annotation @{0} fehlt ein Standardwert für das Element "{1}"

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=In Annotation @{0} fehlen Standardwerte für Elemente {1}

# 0: type
compiler.err.annotation.not.valid.for.type=Annotation ist für Element des Typs {0} nicht gültig

compiler.err.annotation.type.not.applicable=Annotationsschnittstelle ist für diese Art Deklaration nicht anwendbar

# 0: type
compiler.err.annotation.type.not.applicable.to.type=Annotation @{0} ist in diesem Typkontext nicht anwendbar

compiler.err.annotation.value.must.be.annotation=Annotationswert muss eine Annotation sein

compiler.err.annotation.value.must.be.class.literal=Annotationswert muss ein Klassenliteral sein

compiler.err.annotation.value.must.be.name.value=Annotationswerte müssen das Format "Name=Wert" aufweisen

compiler.err.annotation.value.not.allowable.type=Annotationswert hat keinen zulässigen Typ

compiler.err.expression.not.allowable.as.annotation.value=Ausdruck ist als Annotationswert nicht zulässig

# 0: type, 1: name
compiler.err.annotation.unrecognized.attribute.name=Annotation @{0} weist das unbekannte Attribut "{1}" auf

compiler.err.anon.class.impl.intf.no.args=Anonyme Klasse implementiert Schnittstelle. Argumente sind nicht möglich

compiler.err.anon.class.impl.intf.no.typeargs=Anonyme Klasse implementiert Schnittstelle. Typargumente sind nicht möglich

compiler.err.anon.class.impl.intf.no.qual.for.new=Anonyme Klasse implementiert Schnittstelle. Qualifier für "Neu" ist nicht möglich

compiler.err.cant.inherit.from.anon=Erben aus anonymer Klasse nicht möglich

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs={0} und {1} können nicht beide in {2} deklariert werden

compiler.err.array.dimension.missing=Arraydimension fehlt

compiler.err.illegal.array.creation.both.dimension.and.initialization=Arrayerstellung mit Dimensionsausdruck und Initialisierung ist unzulässig

# 0: type
compiler.err.array.req.but.found=Array erforderlich, aber {0} gefunden

compiler.err.attribute.value.must.be.constant=Elementwert muss ein Konstantenausdruck sein

# 0: string (statement type)
compiler.err.bad.initializer=Ungültiger Initializer für {0}

compiler.err.break.outside.switch.loop=Unterbrechung außerhalb Switch oder Schleife

compiler.err.break.outside.switch.expression=Versuch, Vorgang aus einem Switch-Ausdruck zu unterbrechen

compiler.err.continue.outside.switch.expression=Versuch, Vorgang aus einem Switch-Ausdruck fortzusetzen

compiler.err.return.outside.switch.expression=Versuch, aus einem Switch-Ausdruck zurückzukehren

compiler.err.rule.completes.normally=Switch-Regel wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Regeln in Switch-Ausdrücken müssen einen Wert oder Throw angeben)

compiler.err.switch.expression.completes.normally=Switch-Ausdruck wird ohne Angabe eines Wertes abgeschlossen\n(Switch-Ausdrücke müssen einen Wert angeben oder einen Throw für alle möglichen Eingabewerte ausgeben)

compiler.err.no.switch.expression ="yield" außerhalb von Switch-Ausdruck

compiler.err.no.switch.expression.qualify="yield" außerhalb von Switch-Ausdruck\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empfänger oder Typnamen)

compiler.err.invalid.yield=Ungültige Verwendung der eingeschränkten ID "yield"\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empfänger oder Typnamen)

compiler.warn.invalid.yield="yield" kann in einem zukünftigen Release zu einer eingeschränkten ID werden\n(um eine Methode namens "yield" aufzurufen, qualifizieren Sie den yield-Aufruf mit einem Empfänger oder Typnamen)

compiler.err.switch.expression.empty=Switch-Ausdruck enthält keine CASE-Klauseln

compiler.err.switch.expression.no.result.expressions=Switch-Ausdruck enthält keine Ergebnisausdrücke

compiler.err.call.must.only.appear.in.ctor=Expliziter Konstruktoraufruf ist nur in einem Konstruktorbody zulässig

compiler.err.redundant.superclass.init=Redundanter expliziter Konstruktoraufruf

compiler.err.ctor.calls.not.allowed.here=Expliziter Konstruktoraufruf ist hier nicht zulässig

compiler.err.return.before.superclass.initialized=''return'' ist vor einem expliziten Konstruktoraufruf nicht zulässig

# 0: symbol kind, 1: name, 2: symbol kind, 3: type, 4: message segment
compiler.err.cant.apply.symbol.noargs={0} {1} in {2} {3} kann nicht auf die angegebenen Typen angewendet werden.\nGrund: {4}

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol={0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden.\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols={0} für {1}({2}) nicht geeignet

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol={0} {1} in {4} {5} kann nicht auf die angegebenen Typen angewendet werden\nErforderlich: {2}\nErmittelt:    {3}\nGrund: {6}

# 0: list of type or message segment, 1: list of type or message segment, 2: message segment
compiler.misc.cant.apply.array.ctor=Array kann nicht aus angegebenen Typen erstellt werden\nErforderlich: {0}\nErmittelt: {1}\nGrund: {2}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols={0} für {1}({2}) nicht geeignet

# 0: kind name, 1: symbol
compiler.misc.no.abstracts=Keine abstrakte Methode in {0} {1} gefunden

# 0: kind name, 1: symbol
compiler.misc.incompatible.abstracts=Mehrere nicht überschreibende abstrakte Methoden in {0} {1} gefunden

compiler.err.bad.functional.intf.anno=Unerwartete @FunctionalInterface-Annotation

# 0: message segment
compiler.err.bad.functional.intf.anno.1=Unerwartete @FunctionalInterface-Annotation\n{0}

# 0: message segment
compiler.err.anonymous.diamond.method.does.not.override.superclass=Methode überschreibt oder implementiert keine Methode aus einem Supertyp\n{0}

# 0: symbol
compiler.misc.not.a.functional.intf={0} ist keine Funktionsschnittstelle

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1={0} ist keine Funktionsschnittstelle\n{1}

# 0: type, 1: kind name, 2: symbol
compiler.misc.invalid.generic.lambda.target=Ungültiger Funktionsdeskriptor für Lambda-Ausdruck\nMethode {0} in {1} {2} ist generisch

# 0: kind name, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf=Inkompatible Funktionsdeskriptoren in {0} {1} gefunden

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=Deskriptor: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=Deskriptor: {2} {0}({1}) löst {3} aus

# 0: type
compiler.misc.no.suitable.functional.intf.inst=Funktionsschnittstellendeskriptor für {0} kann nicht abgeleitet werden

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=Ungültiges Schnittmengentypziel für Lambda oder Methodenreferenz\n{0}

# 0: symbol or type
compiler.misc.not.an.intf.component=Komponententyp {0} ist keine Schnittstelle

# 0: kind name, 1: message segment
compiler.err.invalid.mref=Ungültige {0}-Referenz\n{1}

# 0: kind name, 1: message segment
compiler.misc.invalid.mref=Ungültige {0}-Referenz\n{1}

compiler.misc.static.mref.with.targs=Parametrisierter Qualifier für statische Methodenreferenz

# 0: set of flag or string, 1: symbol
compiler.err.cant.assign.val.to.var=Der {0}-Variablen {1} kann kein Wert zugewiesen werden

compiler.err.cant.assign.val.to.this=Zuweisen zu "this" nicht möglich

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var=Von {1} referenzierte lokale Variablen müssen final oder effektiv final sein

compiler.err.try.with.resources.expr.needs.var=Die try-with-resources-Ressource muss eine Variablendeklaration oder ein Ausdruck mit einer Referenz zu einer finalen oder effektiv finalen Variable sein

# 0: symbol
compiler.err.try.with.resources.expr.effectively.final.var=Variable {0}, die als try-with-resources-Ressource verwendet wurde, ist weder final noch effektiv final


compiler.misc.lambda=Lambda-Ausdruck

compiler.misc.inner.cls=Innere Klasse

compiler.misc.guard=Guard

# 0: type
compiler.err.cant.deref={0} kann nicht dereferenziert werden

compiler.err.cant.extend.intf.annotation="extends" für @interfaces nicht zulässig

compiler.err.annotation.decl.not.allowed.here=Annotationsschnittstellendeklaration hier nicht zulässig

# 0: symbol
compiler.err.cant.inherit.from.final=Erben aus finalem {0}-Element nicht möglich

# 0: symbol or name
compiler.err.cant.ref.before.ctor.called={0} kann nicht referenziert werden, bevor der Supertypkonstruktor aufgerufen wurde

# 0: symbol or name
compiler.err.cant.assign.initialized.before.ctor.called=Initialisiertes Feld "{0}" kann nicht zugewiesen werden, bevor der Supertypkonstruktor aufgerufen wurde

compiler.err.cant.select.static.class.from.param.type=Statische Klasse kann nicht aus einem parametrisierten Typ ausgewählt werden

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg={0} kann nicht mit verschiedenen Argumenten geerbt werden: <{1}> und <{2}>

compiler.err.catch.without.try="catch" ohne "try"

# 0: kind name, 1: symbol
compiler.err.clash.with.pkg.of.same.name={0} {1} steht in Konflikt mit Package desselben Namens

compiler.err.class.not.allowed=Klassen-, Schnittstellen- oder Enum-Deklaration hier nicht zulässig

compiler.err.const.expr.req=Konstantenausdruck erforderlich

compiler.err.pattern.or.enum.req=Muster oder Enum-Konstante erforderlich

compiler.err.cont.outside.loop=Fortsetzung außerhalb Schleife

# 0: symbol or type
compiler.err.cyclic.inheritance=Zyklische Vererbung mit {0}

# 0: symbol
compiler.err.cyclic.annotation.element=Typ von Element {0} ist zyklisch

# 0: symbol
compiler.err.call.to.super.not.allowed.in.enum.ctor=Aufruf von Super in Enum-Konstruktor nicht zulässig

# 0: type
compiler.err.no.superclass={0} weist keine Superklasse auf.

# 0: symbol, 1: type, 2: symbol, 3: type, 4: type
compiler.err.concrete.inheritance.conflict=Methoden {0} von {1} und {2} von {3} werden mit derselben Signatur geerbt

compiler.err.default.allowed.in.intf.annotation.member=Standardwert nur in einer Annotationsschnittstellendeklaration zulässig

# 0: symbol
compiler.err.doesnt.exist=Package {0} ist nicht vorhanden

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=Annotation {0} ist keine gültige wiederholbare Annotation

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=Doppeltes Element "{0}" in Annotation @{1}.

# 0: type
compiler.err.duplicate.annotation.missing.container={0} ist keine wiederholbare Annotationsschnittstelle

# 0: symbol
compiler.err.invalid.repeatable.annotation=Doppelte Annotation: {0} ist mit einer ungültigen @Repeatable-Annotation versehen

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value={0} ist keine gültige @Repeatable-Annotation. Keine Wertelementmethode deklariert

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values={0} ist keine gültige @Repeatable-Annotation. {1} Elementmethoden namens "value" deklariert

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value={0} ist keine gültige @Repeatable-Annotation. Ungültiges Wertelement

# 0: symbol or type, 1: type, 2: type
compiler.err.invalid.repeatable.annotation.value.return=Übergeordnete Annotationsschnittstelle ({0}) muss ein Element namens "value" mit dem Typ {2} deklarieren

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=Übergeordnete Annotationsschnittstelle ({0}) enthält keinen Standardwert für Element {1}

# 0: symbol, 1: string, 2: symbol, 3: string
compiler.err.invalid.repeatable.annotation.retention=Aufbewahrung der übergeordneten Annotationsschnittstelle ({0}) ist kürzer als die Aufbewahrung der wiederholbaren Annotationsschnittstelle ({2})

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=Wiederholbare Annotationsschnittstelle ({1}) ist @Documented, die übergeordnete Annotationsschnittstelle ({0}) aber nicht

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=Wiederholbare Annotationsschnittstelle ({1}) ist @Inherited, die übergeordnete Annotationsschnittstelle ({0}) aber nicht

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=Übergeordnete Annotationsschnittstelle ({0}) gilt für mehr Ziele als die wiederholbare Annotationsschnittstelle ({1})

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=Container {0} darf nicht gleichzeitig mit dem darin enthaltenen Element vorhanden sein

# 0: type, 1: symbol
compiler.err.invalid.repeatable.annotation.not.applicable=Container {0} ist nicht anwendbar für Element {1}

# 0: type
compiler.err.invalid.repeatable.annotation.not.applicable.in.context=Container {0} ist in diesem Typkontext nicht anwendbar

# 0: name
compiler.err.duplicate.class=Doppelte Klasse: {0}

# 0: string
compiler.err.bad.file.name=Ungültiger Dateiname: {0}

compiler.err.implicit.class.should.not.have.package.declaration=Implizit deklarierte Klasse darf keine Packagedeklaration aufweisen

compiler.err.implicit.class.does.not.have.main.method=Implizit deklarierte Klasse weist keine Hauptmethode im Format "void main()" oder "void main(String[] args)" auf

# 0: name, 1: name
compiler.err.same.binary.name=Klassen {0} und {1} haben denselben binären Namen

compiler.err.duplicate.case.label=Doppeltes CASE-Label

compiler.err.pattern.dominated=Dieses CASE-Label wird von einem vorherigen CASE-Label dominiert

compiler.err.duplicate.default.label=Doppeltes Standardlabel

compiler.err.duplicate.unconditional.pattern=Doppeltes nicht bedingtes Muster

compiler.err.unconditional.pattern.and.default=Switch umfasst sowohl ein nicht bedingtes Muster als auch ein Standardlabel

compiler.err.unconditional.pattern.and.both.boolean.values=Switch umfasst sowohl boolesche Werte als auch ein nicht bedingtes Muster

compiler.err.default.and.both.boolean.values=Switch umfasst sowohl boolesche Werte als auch ein Standardlabel

compiler.err.guard.not.allowed=Guards sind nur für CASE-Anweisungen mit einem Muster zulässig

compiler.err.guard.has.constant.expression.false=Dieses CASE-Label hat einen Guard, der ein konstanter Ausdruck mit dem Wert ''false'' ist

# 0: symbol
compiler.err.cannot.assign.not.declared.guard=Zuweisen zu {0} nicht möglich, da das Element nicht im Guard deklariert wurde

# 0: type, 1: type
compiler.err.constant.label.not.compatible=Konstantes Label des Typs {0} ist nicht mit Switch-Selektortyp {1} kompatibel

compiler.err.flows.through.to.pattern=Unzulässiger Fallthrough auf ein Muster\n(im vorherigen CASE-Label fehlt ein Break)

compiler.err.flows.through.from.pattern=Unzulässiger Fallthrough von einem Muster\n(im aktuellen CASE-Label fehlt ein Break)

compiler.err.invalid.case.label.combination=ungültige Case-Label-Kombination

compiler.err.default.label.not.allowed=Standardlabel hier nicht zulässig

compiler.err.pattern.type.cannot.infer=Mustertyp kann nicht abgeleitet werden

compiler.err.else.without.if="else" ohne "if"

compiler.err.empty.char.lit=Leeres Zeichenliteral

# 0: symbol
compiler.err.encl.class.required=Eine einschließende Instanz mit {0} ist erforderlich

compiler.err.enum.annotation.must.be.enum.constant=Ein Enum-Annotationswert muss eine Enum-Konstante sein

compiler.err.enum.cant.be.instantiated=Enum-Klassen dürfen nicht instanziiert werden

compiler.err.enum.label.must.be.unqualified.enum=Das CASE-Label eines Enum-Switches muss der unqualifizierte Name einer Enumerationskonstante sein

compiler.err.enum.label.must.be.enum.constant=Das CASE-Label einer Enum-Switch-Konstanten muss eine Enumerationskonstante sein

compiler.err.enum.no.subclassing=Klassen können java.lang.Enum nicht direkt erweitern

compiler.err.enum.types.not.extensible=Enum-Klassen sind nicht erweiterbar

compiler.err.enum.no.finalize=Enums können keine Finalisierungsmethoden aufweisen

compiler.err.enum.cant.be.generic=Enums können nicht generisch sein

# 0: file name, 1: string
compiler.err.error.reading.file=Fehler beim Lesen von {0}. {1}

# 0: type
compiler.err.except.already.caught=Ausnahme {0} wurde bereits abgefangen

# 0: type
compiler.err.except.never.thrown.in.try=Ausnahme {0} wird nie im Body der entsprechenden try-Anweisung ausgelöst

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=final-Parameter {0} darf nicht zugewiesen werden

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=auto-closeable-Ressource {0} darf nicht zugewiesen werden

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=multi-catch-Parameter {0} darf nicht zugewiesen werden

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=Alternativen in einer multi-catch-Anweisung dürfen nicht durch Unterklassen verknüpft sein\nAlternative {0} ist eine Unterklasse der Alternative {1}

compiler.err.finally.without.try="finally" ohne "try"

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=for-each nicht auf Ausdruckstyp anwendbar\nErforderlich: {1}\nErmittelt:    {0}

compiler.err.fp.number.too.large=Gleitkommazahl zu groß

compiler.err.fp.number.too.small=Gleitkommazahl zu klein

compiler.err.generic.array.creation=Erstellung von generischem Array

compiler.err.generic.throwable=Eine generische Klasse darf java.lang.Throwable nicht erweitern

# 0: symbol
compiler.err.icls.cant.have.static.decl=Unzulässige static-Deklaration in innerer Klasse {0}\nModifikator "static" ist nur in Konstantenvariablendeklarationen zulässig

# 0: string
compiler.err.illegal.char=Unzulässiges Zeichen: "{0}"

# 0: string, 1: string
compiler.err.illegal.char.for.encoding=Nicht zuordenbares Zeichen (0x{0}) für Codierung {1}

# 0: set of flag, 1: set of flag
compiler.err.illegal.combination.of.modifiers=Unzulässige Kombination aus Modifikatoren: {0} und {1}

compiler.err.illegal.enum.static.ref=Unzulässige Referenz zu statischem Feld aus Initializer

compiler.err.illegal.esc.char=Unzulässiges Escapezeichen

compiler.err.illegal.forward.ref=Unzulässige Vorwärtsreferenz

# 0: symbol, 1: object
compiler.err.not.in.profile={0} ist in Profil "{1}" nicht verfügbar

# 0: symbol
compiler.warn.forward.ref=Referenz zu Variable "{0}", bevor sie initialisiert wurde

compiler.warn.possible.this.escape=Mögliches "this"-Escape vor vollständiger Initialisierung der Unterklasse

compiler.warn.possible.this.escape.location=Vorheriges mögliches "This"-Escape erfolgt hier per Aufruf

compiler.err.illegal.self.ref=Selbstreferenz in Initializer

# 0: symbol
compiler.warn.self.ref=Selbstreferenz in Initializer von Variable "{0}"

# 0: type
compiler.err.illegal.initializer.for.type=Unzulässiger Initializer für {0}

compiler.err.illegal.line.end.in.char.lit=Unzulässiges Zeilenende in Zeichenliteral

compiler.err.illegal.text.block.open=Unzulässige Sequenz für Öffnungstrennzeichen von Textblock. Zeilenabschlusszeichen fehlt

compiler.warn.inconsistent.white.space.indentation=Inkonsistenter Leerzeicheneinzug

compiler.warn.trailing.white.space.will.be.removed=Nachgestelltes Leerzeichen wird entfernt

compiler.err.illegal.nonascii.digit=Unzulässige Nicht-ASCII-Ziffer

compiler.err.illegal.underscore=Unzulässiger Unterstrich

compiler.err.illegal.dot="." unzulässig

compiler.err.illegal.digit.in.binary.literal=Unzulässige Ziffer in einem binären Literal

compiler.err.illegal.digit.in.octal.literal=Unzulässige Ziffer in einem oktalen Literal

# 0: symbol
compiler.err.illegal.qual.not.icls=Unzulässiger Qualifier. {0} ist keine innere Klasse

compiler.err.illegal.start.of.expr=Unzulässiger Ausdrucksbeginn

compiler.err.illegal.start.of.stmt=Unzulässiger Anweisungsbeginn

compiler.err.illegal.start.of.type=Unzulässiger Typbeginn

compiler.err.illegal.parenthesized.expression=Unzulässiger Ausdruck in Klammern

compiler.err.illegal.unicode.esc=Unzulässiges Unicode-Escapezeichen

# 0: symbol
compiler.err.import.requires.canonical=Import erfordert kanonischen Namen für {0}

compiler.err.improperly.formed.type.param.missing=Falsch formatierter Typ. Einige Parameter fehlen

compiler.err.improperly.formed.type.inner.raw.param=Falsch formatierter Typ. Typargumente für Raw-Typ angegeben

# 0: type, 1: type
compiler.err.incomparable.types=Nicht vergleichbare Typen: {0} und {1}

# 0: string
compiler.err.int.number.too.large=Ganzzahl zu groß

compiler.err.intf.annotation.members.cant.have.params=Elemente in Annotationsschnittstellendeklarationen können keine formalen Parameter deklarieren

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=Annotationsschnittstelle {0} darf nicht generisch sein

compiler.err.intf.annotation.members.cant.have.type.params=Elemente in Annotationsschnittstellendeklarationen können keine generischen Methoden sein

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=Annotationsschnittstelle {1} deklariert ein Element mit demselben Namen wie Methode {0}

compiler.err.intf.expected.here=Hier wird eine Schnittstelle erwartet

compiler.err.intf.meth.cant.have.body=Abstrakte Schnittstellenmethoden können keinen Body enthalten

compiler.err.invalid.annotation.member.type=Ungültiger Typ für Annotationsschnittstellenelement

compiler.err.invalid.binary.number=Binärzahlen müssen mindestens eine Binärziffer enthalten

compiler.err.invalid.hex.number=Hexadezimalzahlen müssen mindestens eine Hexadezimalziffer enthalten

compiler.err.invalid.meth.decl.ret.type.req=Ungültige Methodendeklaration. Rückgabetyp erforderlich

compiler.err.varargs.and.old.array.syntax=Legacy-Arraynotation für Parameter mit variabler Argumentanzahl nicht zulässig

compiler.err.varargs.and.receiver =varargs-Notation für receiver-Parameter nicht zulässig

compiler.err.varargs.must.be.last =varargs-Parameter muss der letzte Parameter sein

compiler.err.array.and.receiver =Legacy-Arraynotation für receiver-Parameter nicht zulässig

compiler.err.wrong.receiver =Falscher receiver-Parametername

compiler.err.variable.not.allowed=Variablendeklaration hier nicht zulässig

# 0: name
compiler.err.label.already.in.use=Label {0} wird bereits verwendet

compiler.err.local.enum=Enum-Klassen dürfen nicht lokal sein

compiler.err.cannot.create.array.with.type.arguments=Array kann nicht mit Typargumenten erstellt werden

compiler.err.cannot.create.array.with.diamond=Array kann nicht mit "<>" erstellt werden

compiler.err.invalid.module.directive=Moduldirektiven-Schlüsselwort oder "}" erwartet

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=Code zu groß

compiler.err.limit.code.too.large.for.try.stmt=Code für try-Anweisung zu groß

compiler.err.limit.dimensions=Arraytyp hat zu viele Dimensionen

compiler.err.limit.locals=Zu viele lokale Variablen

compiler.err.limit.parameters=Zu viele Parameter

compiler.err.limit.pool=Zu viele Konstanten

compiler.err.limit.pool.in.class=Zu viele Konstanten in Klasse {0}

compiler.err.limit.stack=Code erfordert zu viel Stack

compiler.err.limit.string=Konstantenzeichenfolge zu lang

# 0: string
compiler.err.limit.string.overflow=UTF8-Darstellung für Zeichenfolge "{0}..." ist zu lang für den Konstantenpool

compiler.err.malformed.fp.lit=Nicht wohlgeformtes Gleitkommaliteral

compiler.err.method.does.not.override.superclass=Methode überschreibt oder implementiert keine Methode aus einem Supertyp

compiler.err.static.methods.cannot.be.annotated.with.override=Statische Methoden können nicht mit @Override-Annotation versehen werden

compiler.err.missing.meth.body.or.decl.abstract=Methodenbody fehlt oder als abstrakt deklarieren

compiler.err.missing.ret.stmt=Rückgabeanweisung fehlt

# 0: type
compiler.misc.missing.ret.val=Rückgabewert fehlt

compiler.misc.unexpected.ret.val=Unerwarteter Rückgabewert

# 0: set of flag
compiler.err.mod.not.allowed.here=Modifikator {0} hier nicht zulässig

# 0: name
compiler.err.modifier.not.allowed.here=Modifikator {0} hier nicht zulässig

compiler.err.intf.not.allowed.here=Schnittstelle hier nicht zulässig

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=Namenskonflikt: {0} und {1} haben dieselbe Erasure

# 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
compiler.err.name.clash.same.erasure.no.override=Namenskonflikt: {0}({1}) in {2} und {3}({4}) in {5} haben dieselbe Erasure, aber keine setzt die andere außer Kraft

# 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
compiler.err.name.clash.same.erasure.no.override.1=Namenskonflikt: {0} {1} hat zwei Methoden mit derselben Erasure, aber keine setzt die andere außer Kraft\nErste Methode: {2}({3}) in {4}\nZweite Methode: {5}({6}) in {7}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=Namenskonflikt: {0} in {1} und {2} in {3} haben dieselbe Erasure, aber keine blendet die andere aus

compiler.err.name.reserved.for.internal.use={0} ist für den internen Gebrauch reserviert

compiler.err.native.meth.cant.have.body=Native Methoden können keinen Body enthalten


# 0: message segment
compiler.misc.incompatible.type.in.conditional=Ungültiger Typ in Bedingungsausdruck\n{0}

compiler.misc.conditional.target.cant.be.void=target-type für Bedingungsausdruck darf nicht "void" sein

compiler.misc.switch.expression.target.cant.be.void=target-type für Switch-Ausdruck darf nicht "void" sein

# 0: message segment
compiler.misc.incompatible.type.in.switch.expression=Ungültiger Typ in Switch-Ausdruck\n{0}

# 0: message segment
compiler.misc.incompatible.ret.type.in.lambda=Ungültiger Rückgabetyp in Lambda-Ausdruck\n{0}

compiler.misc.stat.expr.expected=Lambda-Body ist nicht mit einer void-Funktionsschnittstelle kompatibel\n(verwenden Sie stattdessen einen Block-Lambda-Body oder einen Anweisungsausdruck)

# 0: message segment
compiler.misc.incompatible.ret.type.in.mref=Ungültiger Rückgabetyp in Methodenreferenz\n{0}

compiler.err.lambda.body.neither.value.nor.void.compatible=Lambda-Body ist weder mit Wert noch mit "void "kompatibel

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=Inkompatible ausgelöste Typen {0} in Funktionsausdruck

compiler.misc.incompatible.arg.types.in.lambda=Inkompatible Parametertypen in Lambda-Ausdruck

compiler.misc.incompatible.arg.types.in.mref=Inkompatible Parametertypen in Methodenreferenz

compiler.err.new.not.allowed.in.annotation="new" in einer Annotation nicht zulässig

# 0: name, 1: type
compiler.err.no.annotation.member=Kein Annotationsmitglied {0} in {1}

# 0: symbol
compiler.err.no.encl.instance.of.type.in.scope=Keine einschließende Instanz vom Typ {0} im Geltungsbereich

compiler.err.no.intf.expected.here=Hier wird keine Schnittstelle erwartet

compiler.err.no.match.entry={0} hat keine Übereinstimmung im Eintrag in {1}. {2} erforderlich

# 0: type
compiler.err.not.annotation.type={0} ist keine Annotationsschnittstelle

# 0: symbol, 1: symbol, 2: message segment
compiler.err.not.def.access.package.cant.access={0} ist nicht sichtbar\n({2})

# 0: symbol, 1: symbol, 2: message segment
compiler.misc.not.def.access.package.cant.access={0} ist nicht sichtbar\n({2})

# 0: symbol, 1: message segment
compiler.err.package.not.visible=Package {0} ist nicht sichtbar\n({1})

# 0: symbol, 1: message segment
compiler.misc.package.not.visible=Package {0} ist nicht sichtbar\n({1})

# {0} - current module
# {1} - package in which the invisible class is declared
# {2} - module in which {1} is declared
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.does.not.read=Package {1} wird in Modul {2} deklariert, aber nicht von Modul {0} gelesen

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.from.unnamed=Package {0} wird in Modul {1} deklariert, das nicht im Moduldiagramm enthalten ist

# {0} - package in which the invisible class is declared
# {1} - current module
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.unnamed=Package {0} wird im unbenannten Modul deklariert, aber nicht von Modul {1} gelesen

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported=Package {0} wird in Modul {1} deklariert, aber nicht exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.from.unnamed=Package {0} wird in Modul {1} deklariert, aber nicht exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# {2} - current module
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.not.exported.to.module=Package {0} wird in Modul {1} deklariert, aber nicht in Modul {2} exportiert

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.to.module.from.unnamed=Package {0} wird in Modul {1} deklariert, aber nicht in das unbenannte Modul exportiert

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access={1}.{0} ist in einer nicht zugänglichen Klasse oder Schnittstelle definiert

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access={1}.{0} ist in einer nicht zugänglichen Klasse oder Schnittstelle definiert

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.err.not.def.access.class.intf.cant.access.reason={1}.{0} in Package {2} ist nicht zugänglich\n({3})

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.misc.not.def.access.class.intf.cant.access.reason={1}.{0} in Package {2} ist nicht zugänglich\n({3})

# 0: symbol, 1: list of type, 2: type
compiler.misc.cant.access.inner.cls.constr=Zugriff auf Konstruktor {0}({1}) nicht möglich\nEinschließende Instanz vom Typ {2} ist nicht im Geltungsbereich

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access={0} ist nicht öffentlich in {1}. Zugriff von externem Package nicht möglich

# 0: symbol, 1: symbol
compiler.err.not.def.public={0} ist nicht öffentlich in {1}

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access={0} ist nicht öffentlich in {1}. Zugriff von externem Package nicht möglich

# 0: name
compiler.err.not.loop.label=Kein Schleifenlabel: {0}

compiler.err.not.stmt=Keine Anweisung

# 0: symbol
compiler.err.not.encl.class=Keine einschließende Klasse: {0}

# 0: name, 1: type
compiler.err.operator.cant.be.applied=Ungültiger Operandentyp {1} für unären Operator "{0}"

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=Ungültige Operandentypen für unären Operator "{0}"\nErster Typ: {1}\nZweiter Typ: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=Packageannotationen müssen in der Datei package-info.java vorhanden sein

compiler.err.no.pkg.in.module-info.java=Packagedeklarationen in Datei module-info.java nicht zulässig

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=Es besteht ein Konflikt zwischen dem Package {0} und einer gleichnamigen Klasse

compiler.err.warnings.and.werror=Warnungen gefunden und -Werror angegeben

# Errors related to annotation processing

# 0: symbol, 1: message segment, 2: string (stack-trace)
compiler.err.proc.cant.access=Kein Zugriff auf {0}\n{1}\nDetails finden Sie im folgenden Stacktrace.\n{2}

# 0: symbol, 1: message segment
compiler.err.proc.cant.access.1=Kein Zugriff auf {0}\n{1}

# 0: string
compiler.err.proc.cant.find.class=Klassendatei für "{0}" konnte nicht gefunden werden.

# 0: string
compiler.err.proc.cant.load.class=Prozessorklassendatei konnte nicht geladen werden. Grund: "{0}".

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager={0}

# 0: string
compiler.misc.exception.message={0}

compiler.misc.user.selected.completion.failure=Von Benutzer ausgewählter Abschlussfehler nach Klassenname

# 0: collection of string
compiler.err.proc.no.explicit.annotation.processing.requested=Klassennamen "{0}" werden nur akzeptiert, wenn die Annotationsverarbeitung explizit angefordert wird

compiler.err.proc.no.service=ServiceLoader konnte nicht verwendet werden und ist für Annotationsverarbeitung erforderlich.

# 0: string, 1: string
compiler.err.proc.processor.bad.option.name=Ungültiger Optionsname "{0}" von Prozessor "{1}" angegeben

# 0: string
compiler.err.proc.processor.cant.instantiate=Instanz von Prozessor "{0}" konnte nicht instanziiert werden

# 0: string
compiler.err.proc.processor.not.found=Annotationsprozessor "{0}" nicht gefunden

# 0: string
compiler.err.proc.processor.wrong.type=Annotationsprozessor "{0}" implementiert nicht javax.annotation.processing.Processor

compiler.err.proc.service.problem=Fehler beim Erstellen eines Service-Loaders zum Laden von Prozessoren.

# 0: string
compiler.err.proc.bad.config.file=Ungültige Servicekonfigurationsdatei, oder Ausnahme beim Erstellen des Prozessorobjekts ausgelöst: {0}

compiler.err.proc.cant.create.loader=Class Loader konnte nicht für Annotationsprozessoren erstellt werden: {0}

# 0: symbol
compiler.err.qualified.new.of.static.class="new" von statischer Klasse qualifiziert

compiler.err.recursive.ctor.invocation=Rekursiver Konstruktoraufruf

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous=Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen überein

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous=Referenz zu {0} ist mehrdeutig\nSowohl {1} {2} in {3} als auch {4} {5} in {6} stimmen überein

compiler.err.repeated.annotation.target=Wiederholtes Annotationsziel

compiler.err.repeated.interface=Wiederholte Schnittstelle

compiler.err.repeated.modifier=Wiederholter Modifikator

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access={0} hat {1}-Zugriff in {2}

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access={0} hat {1}-Zugriff in {2}

compiler.err.ret.outside.meth=Rückgabe außerhalb von Methode

compiler.err.signature.doesnt.match.supertype=Signatur stimmt nicht mit {0} überein. Inkompatibler Supertyp

compiler.err.signature.doesnt.match.intf=Signatur stimmt nicht mit {0} überein. Inkompatible Schnittstellen

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract={0} ist nicht abstrakt und setzt die abstrakte Methode {1} in {2} nicht außer Kraft

# 0: file object
compiler.err.source.cant.overwrite.input.file=Fehler beim Schreiben von Quelle. Eingabedatei {0} kann nicht überschrieben werden

# 0: symbol
compiler.err.stack.sim.error=Interner Fehler: Stacksimulationsfehler in {0}

compiler.err.static.imp.only.classes.and.interfaces=Statischer Import nur aus Klassen und Schnittstellen

compiler.err.string.const.req=Konstanten-Zeichenfolgenausdruck erforderlich

compiler.err.pattern.expected=Typmuster erwartet

# 0: symbol, 1: fragment
compiler.err.cannot.generate.class=Fehler beim Generieren der Klasse {0}\n({1})

# 0: symbol, 1: symbol
compiler.misc.synthetic.name.conflict=Das Symbol {0} steht mit einem vom Compiler synthetisierten Symbol in {1} in Konflikt

# 0: symbol, 1: type
compiler.misc.illegal.signature=Unzulässiges Signaturattribut für Typ {1}

compiler.err.throws.not.allowed.in.intf.annotation=Throws-Klausel in @interface-Mitgliedern nicht zulässig

compiler.err.try.without.catch.finally.or.resource.decls="try" ohne "catch", "finally" oder Ressourcendeklarationen

# 0: symbol
compiler.err.type.doesnt.take.params=Typ {0} akzeptiert keine Parameter

compiler.err.type.var.cant.be.deref=Auswahl aus Typvariable nicht möglich

compiler.err.type.var.may.not.be.followed.by.other.bounds=Auf eine Typvariable dürfen keine anderen Begrenzungen folgen

compiler.err.type.var.more.than.once=Typvariable {0} tritt mehrmals im Ergebnistyp von {1} auf. Sie muss instanziiert werden

compiler.err.type.var.more.than.once.in.result=Typvariable {0} tritt mehrmals im Typ von {1} auf. Sie muss instanziiert werden

# 0: type, 1: type, 2: fragment
compiler.err.types.incompatible=Die Typen {0} und {1} sind inkompatibel.\n{2}

# 0: name, 1: list of type
compiler.misc.incompatible.diff.ret=Beide definieren {0}({1}), aber mit nicht verwandten Rückgabetypen

# 0: type, 1: name, 2: list of type
compiler.err.incompatible.diff.ret.same.type=Typ {0} definiert {1}({2}) mehr als einmal mit nicht verwandten Rückgabetypen

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.unrelated.defaults={0} {1} erbt nicht verwandte Standardwerte für {2}({3}) von Typen {4} und {5}

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.abstract.default={0} {1} erbt abstrakte und Standardmethode für {2}({3}) von Typen {4} und {5}

# 0: name, 1: kind name, 2: symbol
compiler.err.default.overrides.object.member=Standardmethode {0} in {1} {2} setzt ein Mitglied von java.lang.Object außer Kraft

# 0: type
compiler.err.illegal.static.intf.meth.call=Unzulässiger statischer Schnittstellenmethodenaufruf\nDer Empfängerausdruck muss durch den Typ-Qualifier "{0}" ersetzt werden

# 0: symbol or type, 1: message segment
compiler.err.illegal.default.super.call=Ungültiger Typ-Qualifier {0} in Standardsuperaufruf\n{1}

# 0: symbol, 1: type
compiler.misc.overridden.default=Methode {0} wird in {1} außer Kraft gesetzt

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=Redundante Schnittstelle {0} wird durch {1} erweitert

compiler.err.unclosed.char.lit=Nicht geschlossenes Zeichenliteral

compiler.err.unclosed.comment=Nicht geschlossener Kommentar

compiler.err.unclosed.str.lit=Nicht geschlossenes Zeichenfolgenliteral

compiler.err.unclosed.text.block=Nicht geschlossener Textblock

# 0: string
compiler.err.unsupported.encoding=Nicht unterstützte Codierung: {0}

compiler.err.io.exception=Fehler beim Lesen der Quelldatei: {0}

# 0: name
compiler.err.undef.label=Nicht definiertes Label: {0}

# 0: name
compiler.err.illegal.ref.to.restricted.type=Unzulässige Referenz zu eingeschränktem Typ "{0}"

# 0: name
compiler.warn.illegal.ref.to.restricted.type=Unzulässige Referenz zu eingeschränktem Typ "{0}"

# 0: name, 1: source
compiler.err.restricted.type.not.allowed="{0}" ist hier nicht zulässig\nAb Release {1} ist "{0}" ein eingeschränkter Typname, der nicht für Typdeklarationen verwendet werden kann

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed=Ab Release {1} ist "{0}" ein eingeschränkter Typname, der nicht für Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed.preview="{0}" kann in einem zukünftigen Release ein eingeschränkter Typname werden, der nicht für Typdeklarationen oder als Elementtyp eines Arrays verwendet werden kann

# 0: name (variable), 1: message segment
compiler.err.cant.infer.local.var.type=Typ für lokale Variable {0} kann nicht abgeleitet werden\n({1})

# 0: name
compiler.err.restricted.type.not.allowed.here="{0}" ist hier nicht zulässig

# 0: name
compiler.err.restricted.type.not.allowed.array="{0}" ist nicht als Elementtyp eines Arrays zulässig

# 0: name
compiler.err.restricted.type.not.allowed.compound="{0}" ist nicht in einer zusammengesetzten Deklaration zulässig

# 0: fragment
compiler.err.invalid.lambda.parameter.declaration=Ungültige Lambda-Parameterdeklaration\n({0})

compiler.misc.implicit.and.explicit.not.allowed=Implizit typisierte Parameter können nicht mit explizit typisierten Parametern gemischt werden

compiler.misc.var.and.explicit.not.allowed="var" kann nicht mit explizit typisierten Parametern gemischt werden

compiler.misc.var.and.implicit.not.allowed="var" kann nicht mit implizit typisierten Parametern gemischt werden

compiler.misc.local.cant.infer.null=Variablen-Initializer ist "null"

compiler.misc.local.cant.infer.void=Variablen-Initializer ist "void"

compiler.misc.local.missing.init="var" kann nicht für Variable ohne Initializer verwendet werden

compiler.misc.local.lambda.missing.target=Lambda-Ausdruck erfordert einen expliziten Zieltyp

compiler.misc.local.mref.missing.target=Methodenreferenz erfordert einen expliziten Zieltyp

compiler.misc.local.array.missing.target=Array-Initializer erfordert einen expliziten Zieltyp

compiler.misc.local.self.ref="var" kann nicht für selbstreferenzierende Variable verwendet werden

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond=Typargumente für {0} können nicht abgeleitet werden

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1=Typargumente für {0} können nicht abgeleitet werden\nGrund: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1=Typargumente für {0} können nicht abgeleitet werden\nGrund: {1}

compiler.err.unreachable.stmt=Nicht erreichbare Anweisung

compiler.err.not.exhaustive=Der Switch-Ausdruck deckt nicht alle möglichen Eingabewerte ab

compiler.err.not.exhaustive.statement=Die Switch-Anweisung deckt nicht alle möglichen Eingabewerte ab

compiler.err.initializer.must.be.able.to.complete.normally=Initializer muss normal abgeschlossen werden können

compiler.err.initializer.not.allowed=Initializer in Schnittstellen nicht zulässig

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgelöst zu werden

# 0: type
compiler.err.unreported.exception.default.constructor=Nicht gemeldete Ausnahme {0} in Standardkonstruktor

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=Nicht gemeldete Ausnahme {0}. Muss abgefangen oder deklariert werden, um ausgelöst zu werden\nAusnahme bei implizitem Aufruf von close() für Ressourcenvariable "{1}" ausgelöst

compiler.err.void.not.allowed.here="void"-Typ hier nicht zulässig

# 0: string
compiler.err.wrong.number.type.args=Falsche Anzahl Typargumente. {0} erforderlich

# 0: symbol
compiler.err.var.might.already.be.assigned=Variable {0} wurde möglicherweise bereits zugewiesen

# 0: symbol
compiler.err.var.might.not.have.been.initialized=Variable {0} wurde möglicherweise nicht initialisiert

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=Variable {0} nicht im Standardkonstruktor initialisiert

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=Variable {0} wurde möglicherweise in Schleife zugewiesen

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno=Ungültige {0}-Annotation. {1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs-Elementtyp {0} ist reifizierbar.

# 0: type, 1: type
compiler.err.instanceof.reifiable.not.safe={0} kann nicht sicher in {1} konvertiert werden

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=Methode {0} ist keine varargs-Methode.

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.accessor=Accessor {0} ist keine varargs-Methode.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=Instanzmethode {0} ist weder final noch privat.

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs.final.only=Instanzmethode {0} ist nicht final.

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=Auf den formalen varargs-Elementtyp {0} kann nicht von {1} {2} zugegriffen werden

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write=Fehler beim Schreiben von {0}: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: kind name, 1: name
compiler.err.class.public.should.be.in.file={0} {1} ist öffentlich und muss in einer Datei namens {1}.java deklariert werden

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=Fehler:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=Lesen nicht möglich: {0}

# 0: string
compiler.err.plugin.not.found=Plug-in nicht gefunden: {0}

# 0: path
compiler.warn.locn.unknown.file.on.module.path=Unbekannte Datei in Modulpfad: {0}


# 0: path
compiler.err.locn.bad.module-info=Problem beim Lesen von module-info.class in {0}

# 0: path
compiler.err.locn.cant.read.directory=Verzeichnis {0} kann nicht gelesen werden

# 0: path
compiler.err.locn.cant.read.file=Datei {0} kann nicht gelesen werden

# 0: path
compiler.err.locn.cant.get.module.name.for.jar=Modulname für {0} kann nicht bestimmt werden

# 0: path
compiler.err.multi-module.outdir.cannot.be.exploded.module=Im Modus für mehrere Module kann das Ausgabeverzeichnis kein entpacktes Modul sein: {0}

# 0: path
compiler.warn.outdir.is.in.exploded.module=Das Ausgabeverzeichnis befindet sich in einem entpackten Modul: {0}

# 0: file object
compiler.err.locn.module-info.not.allowed.on.patch.path=module-info.class nicht in Patchpfad zulässig: {0}

# 0: string
compiler.err.locn.invalid.arg.for.xpatch=Ungültiges Argument für --patch-module-Option: {0}

compiler.err.file.sb.on.source.or.patch.path.for.module=Datei muss sich im Quellpfad oder im Patchpfad für das Modul befinden

compiler.err.no.java.lang=Package java.lang kann in Plattformklassen nicht gefunden werden

#####

# Fatal Errors

# 0: name
compiler.misc.fatal.err.cant.locate.meth=Schwerwiegender Fehler: Methode {0} kann nicht gefunden werden

# 0: name
compiler.misc.fatal.err.cant.locate.field=Schwerwiegender Fehler: Feld {0} kann nicht gefunden werden

# 0: type
compiler.misc.fatal.err.cant.locate.ctor=Schwerwiegender Fehler: Konstruktor für {0} kann nicht gefunden werden

compiler.misc.fatal.err.cant.close=Schwerwiegender Fehler: Compiler-Ressourcen können nicht geschlossen werden

#####

##
## miscellaneous strings
##

compiler.misc.diamond.anonymous.methods.implicitly.override=(aufgrund von <> muss jede nicht private Methode, die in dieser anonymen Klasse deklariert ist, eine Methode aus einem Supertyp außer Kraft setzen oder implementieren)

compiler.misc.source.unavailable=(Quelle nicht verfügbar)

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=Prozessor {0} entspricht {1} und gibt {2} zurück.

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=Runde {0}:\n\tEingabedateien: {1}\n\tAnnotationen: {2}\n\tLetzte Runde: {3}

# 0: file name
compiler.warn.file.from.future=Änderungsdatum liegt in der Zukunft für Datei {0}

# 0: path
compiler.warn.output.file.clash=Ausgabedatei mehrmals geschrieben: {0}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=Einige Meldungen wurden vereinfacht. Wiederholen Sie die Kompilierung mit -Xdiags:verbose, um die vollständige Ausgabe abzurufen

# 0: boolean, 1: symbol
compiler.note.lambda.stat=Lambda-Ausdruck wird übersetzt\nAlternative Metafactory = {0}\nSynthetische Methode = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=Methodenreferenz wird übersetzt\nAlternative Metafactory = {0}\n
# 0: boolean, 1: symbol
compiler.note.mref.stat.1=Methodenreferenz wird übersetzt\nAlternative Metafactory = {0}\nBridgemethode = {1}

compiler.note.note=Hinweis:\u0020

# 0: file name
compiler.note.deprecated.filename={0} verwendet oder überschreibt eine veraltete API.

compiler.note.deprecated.plural=Einige Eingabedateien verwenden oder überschreiben eine veraltete API.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=Wiederholen Sie die Kompilierung mit -Xlint:deprecation, um Details zu erhalten.

# 0: file name
compiler.note.deprecated.filename.additional={0} hat weitere Verwendungen oder Overrides einer veralteten API.

compiler.note.deprecated.plural.additional=Einige Eingabedateien verwenden oder überschreiben zusätzlich eine veraltete API.

# 0: file name
compiler.note.removal.filename={0} verwendet oder überschreibt eine veraltete API, die zum Entfernen markiert ist.

compiler.note.removal.plural=Einige Eingabedateien verwenden oder überschreiben eine veraltete API, die zum Entfernen markiert ist.

# The following string may appear after one of the above removal messages.
compiler.note.removal.recompile=Wiederholen Sie die Kompilierung mit -Xlint:removal, um Details zu erhalten.

# 0: file name
compiler.note.removal.filename.additional={0} hat weitere Verwendungen oder Overrides einer veralteten API, die zum Entfernen markiert ist.

compiler.note.removal.plural.additional=Einige Eingabedateien verwenden oder überschreiben zusätzlich eine veraltete API, die zum Entfernen markiert ist.

# 0: file name
compiler.note.unchecked.filename={0} verwendet nicht geprüfte oder unsichere Vorgänge.

compiler.note.unchecked.plural=Einige Eingabedateien verwenden nicht geprüfte oder unsichere Vorgänge.

# The following string may appear after one of the above unchecked messages.
compiler.note.unchecked.recompile=Wiederholen Sie die Kompilierung mit -Xlint:unchecked, um Details zu erhalten.

# 0: file name
compiler.note.unchecked.filename.additional={0} weist weitere nicht geprüfte oder unsichere Vorgänge auf.

compiler.note.unchecked.plural.additional=Einige Eingabedateien verwenden zusätzlich nicht geprüfte oder unsichere Vorgänge.

# 0: file name, 1: source
compiler.note.preview.filename={0} verwendet Vorschaufeatures von Java SE {1}.

# 0: source
compiler.note.preview.plural=Einige Eingabedateien verwenden Vorschaufeatures von Java SE {0}.

# The following string may appear after one of the above deprecation
# messages.
compiler.note.preview.recompile=Wiederholen Sie die Kompilierung mit -Xlint:preview, um Details zu erhalten.

# 0: file name, 1: source
compiler.note.preview.filename.additional={0} hat weitere Verwendungen von Vorschaufeatures von Java SE {1}.

# 0: source
compiler.note.preview.plural.additional=Einige Eingabedateien verwenden zusätzlich Vorschaufeatures von Java SE {0}.

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager={0}

# 0: string, 1: string, 2: string
compiler.note.multiple.elements=Mehrere Elemente namens "{1}" in Modulen "{2}" wurden von javax.lang.model.util.Elements.{0} gefunden.

compiler.note.implicit.annotation.processing=Die Annotationsverarbeitung ist aktiviert, da mindestens ein Prozessor im\nClasspath gefunden wurde. In einem zukünftigen Release von javac kann die Annotationsverarbeitung deaktiviert werden,\nes sei denn, mindestens ein Prozessor ist namentlich angegeben (-processor), oder ein Suchpfad\nist angegeben (--processor-path, --processor-module-path), oder die Annotationsverarbeitung\nwurde explizit aktiviert (-proc:only, -proc:full).\nVerwenden Sie "-Xlint:-options", um diese Meldung zu unterdrücken.\nVerwenden Sie "-proc:none", um die Annotationsverarbeitung zu deaktivieren.

#####

# 0: number
compiler.misc.count.error={0} Fehler

# 0: number
compiler.misc.count.error.plural={0} Fehler

# 0: number, 1: number
compiler.misc.count.error.recompile=Nur die ersten {0} Fehler von insgesamt {1} werden angezeigt. Mit -Xmaxerrs können Sie mehr Fehler anzeigen

# 0: number, 1: number
compiler.misc.count.warn.recompile=Nur die ersten {0} Warnungen von insgesamt {1} werden angezeigt. Mit -Xmaxwarns können Sie mehr Warnungen anzeigen

# 0: number
compiler.misc.count.warn={0} Warnung

# 0: number
compiler.misc.count.warn.plural={0} Warnungen

compiler.misc.version.not.available=(Versionsinformationen nicht verfügbar)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=[{0} wird geprüft]

# 0: string
compiler.misc.verbose.parsing.done=[Parsen abgeschlossen: {0} ms]

# 0: file name
compiler.misc.verbose.parsing.started=[Parsen gestartet: {0}]

# 0: string
compiler.misc.verbose.total=[{0} ms gesamt]

# 0: file name
compiler.misc.verbose.wrote.file=[{0} geschrieben]

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=[{0} wird geladen]

# 0: string
compiler.misc.verbose.sourcepath=[Suchpfad für Quelldateien: {0}]

# 0: string
compiler.misc.verbose.classpath=[Suchpfad für Klassendateien: {0}]

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=F)ortsetzen, A)bbruch>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=Warnung:\u0020

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=[{0}]\u0020

# 0: symbol
compiler.warn.constant.SVUID=serialVersionUID muss Konstante in Klasse {0} sein

compiler.warn.dangling.doc.comment=Dokumentationskommentar ist an keine Deklaration angehängt

# 0: path
compiler.warn.dir.path.element.not.found=Ungültiges Pfadelement "{0}": Verzeichnis nicht vorhanden

# 0: file name
compiler.warn.dir.path.element.not.directory=Ungültiges Pfadelement "{0}": kein Verzeichnis

# 0: symbol, 1: symbol, 2: symbol
compiler.warn.missing-explicit-ctor=Klasse {0} in exportiertem Package {1} deklariert keine expliziten Konstruktoren und stellt daher einen Standardkonstruktor für Clients des Moduls {2} bereit

compiler.warn.strictfp=Ab Release 17 werden alle Gleitkommaausdrücke streng ausgewertet. Daher ist "strictfp" nicht erforderlich

compiler.warn.finally.cannot.complete=Finally-Klausel kann nicht normal abgeschlossen werden

# 0: name
compiler.warn.poor.choice.for.module.name=Modulnamenskomponente {0} darf keine Ziffern am Ende enthalten

# 0: string
compiler.warn.incubating.modules=Inkubatormodul(e) verwendet: {0}

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated={0} in {1} ist veraltet

# 0: symbol, 1: symbol
compiler.warn.has.been.deprecated.for.removal={0} in {1} ist veraltet und wurde zum Entfernen markiert

# 0: symbol
compiler.warn.is.preview={0} ist eine Vorschau-API, die in einem zukünftigen Release entfernt werden kann.

# 0: symbol
compiler.err.is.preview={0} ist eine Vorschau-API, die standardmäßig deaktiviert ist.\n(Verwenden Sie --enable-preview, um Vorschau-APIs zu aktivieren)

# 0: symbol
compiler.warn.is.preview.reflective={0} ist eine reflektive Vorschau-API, die in einem zukünftigen Release entfernt werden kann.

# 0: symbol, 1: symbol
compiler.warn.restricted.method={0}.{1} ist eine eingeschränkte Methode.\n(Eingeschränkte Methoden sind nicht sicher und können bei falscher Verwendung die JRE zum Absturz bringen oder den Arbeitsspeicher beschädigen)

# 0: symbol
compiler.warn.has.been.deprecated.module=Modul {0} ist veraltet

# 0: symbol
compiler.warn.has.been.deprecated.for.removal.module=Modul {0} ist veraltet und wurde zum Entfernen markiert

# 0: symbol
compiler.warn.sun.proprietary={0} ist eine interne proprietäre API, die in einem zukünftigen Release entfernt werden kann

compiler.warn.illegal.char.for.encoding=Nicht zuordenbares Zeichen für Codierung {0}

# 0: symbol
compiler.warn.improper.SVUID=serialVersionUID muss als "static final" in Klasse {0} deklariert sein

compiler.warn.improper.SPF=serialPersistentFields muss als "private static final" deklariert sein, um in Kraft zu treten

compiler.warn.SPF.null.init=serialPersistentFields tritt bei Initialisierung als Null nicht in Kraft.\nFühren Sie die Initialisierung zu einem leeren Array aus, um keine Felder anzugeben


# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=Nicht-varargs-Aufruf von varargs-Methode mit ungenauem Argumenttyp für den letzten Parameter.\nFühren Sie für einen varargs-Aufruf eine Umwandlung mit Cast in {0} aus\nFühren Sie für einen Nicht-varargs-Aufruf eine Umwandlung mit Cast in {1} aus, um diese Warnung zu unterdrücken

# 0: list of type
compiler.warn.unreachable.catch=Nicht erreichbare Catch-Klausel\nAusgelöster Typ {0} wurde bereits abgefangen

# 0: list of type
compiler.warn.unreachable.catch.1=Nicht erreichbare Catch-Klausel\nAusgelöste Typen {0} wurden bereits abgefangen

# 0: symbol
compiler.warn.long.SVUID=serialVersionUID muss den Typ "long" in Klasse {0} aufweisen

compiler.warn.OSF.array.SPF=serialPersistentFields muss den Typ "java.io.ObjectStreamField[]" aufweisen, um in Kraft zu treten

# 0: symbol
compiler.warn.missing.SVUID=Serialisierbare Klasse {0} enthält keine Definition von serialVersionUID

# 0: name
compiler.warn.serializable.missing.access.no.arg.ctor=Zugriff auf einen no-arg-Konstruktor in der ersten nicht serialisierbaren Superklasse {0} nicht möglich

# 0: name
compiler.warn.serial.method.not.private=Serialisierungsbezogene Methode {0} nicht als privat deklariert

# 0: name
compiler.warn.serial.concrete.instance.method=Serialisierungsbezogene Methode {0} muss eine konkrete Instanzmethode sein, um in Kraft zu treten. Sie darf nicht abstrakt oder statisch sein

# 0: name
compiler.warn.serial.method.static=Serialisierungsbezogene Methode {0} ist als statisch deklariert. Sie muss stattdessen eine Instanzmethode sein, um in Kraft zu treten.

# 0: name
compiler.warn.serial.method.no.args=Serialisierungsbezogene Methode {0} darf keine Parameter aufweisen, um in Kraft zu treten

# 0: name, 1: number
compiler.warn.serial.method.one.arg=Serialisierungsbezogene Methode {0} muss genau einen Parameter aufweisen, um in Kraft zu treten. Sie darf nicht {1} Parameter enthalten

# 0: name, 1: type, 2: type
compiler.warn.serial.method.parameter.type=Der einzige Parameter der serialisierungsbezogenen Methode {0} muss den Typ {1} haben, um in Kraft zu treten. Er darf nicht den Typ {2} aufweisen

# 0: name, 1: type, 2: type
compiler.warn.serial.method.unexpected.return.type=Serialisierungsbezogene Methode {0} wurde mit dem Rückgabetyp {1} und nicht dem erwarteten Typ {2} deklariert.\nMit dieser Deklaration ist die Methode ungültig für die Serialisierung

# 0: name, 1: type
compiler.warn.serial.method.unexpected.exception=Serialisierungsbezogene Methode {0} wurde zum Auslösen eines unerwarteten Typs {1} deklariert

compiler.warn.ineffectual.serial.field.interface=serialPersistentFields ist in einer Schnittstelle nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.field.enum=Serialisierungsbezogenes Feld {0} ist in einer Enum-Klasse nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.method.enum=Serialisierungsbezogene Methode {0} ist in einer Enum-Klasse nicht effektiv

# 0: string
compiler.warn.ineffectual.extern.method.enum=Externalisierungsbezogene Methode {0} ist in einer Enum-Klasse nicht effektiv

compiler.warn.ineffectual.serial.field.record=serialPersistentFields ist in einer Datensatzklasse nicht effektiv

# 0: string
compiler.warn.ineffectual.serial.method.record=Serialisierungsbezogene Methode {0} ist in einer Datensatzklasse nicht effektiv

# 0: string
compiler.warn.ineffectual.externalizable.method.record=Externalisierungsbezogene Methode {0} ist in einer Datensatzklasse nicht effektiv

# 0: name
compiler.warn.ineffectual.serial.method.externalizable=Serialisierungsbezogene Methode {0} ist in einer externalisierbaren Klasse nicht effektiv

compiler.warn.ineffectual.serial.field.externalizable=serialPersistentFields ist in einer externalisierbaren Klasse nicht effektiv

compiler.warn.externalizable.missing.public.no.arg.ctor=Eine externalisierbare Klasse erfordert einen öffentlichen no-arg-Konstruktor

compiler.warn.non.serializable.instance.field=Nicht transientes Instanzfeld einer serialisierbaren Klasse mit einem nicht serialisierbaren Typ deklariert

# 0: type
compiler.warn.non.serializable.instance.field.array=Nicht transientes Instanzfeld einer serialisierbaren Klasse wurde mit einem Array mit einem nicht serialisierbaren Basiskomponententyp {0} deklariert

compiler.warn.non.private.method.weaker.access=Serialisierungsbezogene Methode, die in einer Schnittstelle als nicht privat deklariert ist, verhindert,\ndass Klassen, die die Schnittstelle implementieren, die Methode als privat deklarieren

compiler.warn.default.ineffective=Serialisierungsbezogene Standardmethode aus einer Schnittstelle wird nicht von der Serialisierung für eine implementierende Klasse ausgeführt

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.warn.potentially.ambiguous.overload={0} in {1} ist möglicherweise mehrdeutig mit {2} in {3}

# 0: message segment
compiler.warn.override.varargs.missing={0}. Außer Kraft gesetzte Methode umfasst kein "..."

# 0: message segment
compiler.warn.override.varargs.extra={0}. In außer Kraft setzender Methode fehlt "..."

# 0: message segment
compiler.warn.override.bridge={0}. Außer Kraft setzende Methode ist eine Bridgemethode

# 0: symbol
compiler.warn.pkg-info.already.seen=Die Datei package-info.java wurde bereits für Package {0} gefunden

# 0: path
compiler.warn.path.element.not.found=Ungültiges Pfadelement "{0}": Datei oder Verzeichnis nicht vorhanden

compiler.warn.possible.fall-through.into.case=Möglicher Fallthrough in Case

# 0: type
compiler.warn.redundant.cast=Redundantes Casting in {0}

# 0: number
compiler.warn.position.overflow=Positionscodierungsüberlauf bei Zeile {0}

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version={0}: Hauptversion {1} ist neuer als {2}, die höchste Hauptversion, die von diesem Compiler unterstützt wird.\nEs wird empfohlen, dass Sie den Compiler upgraden.

# 0: file name, 1: fragment
compiler.warn.invalid.utf8.in.classfile={0}: Klassendatei enthält ungültige UTF-8-Codierung: {1}

# 0: kind name, 1: symbol
compiler.warn.static.not.qualified.by.type=Statische {0} muss mit Typname {1} anstelle eines Ausdrucks qualifiziert werden

# 0: kind name
compiler.warn.static.not.qualified.by.type2={0} (statisch) darf nicht als Member einer anonymen Klasse verwendet werden

# 0: string, 1: fragment
compiler.warn.source.no.bootclasspath=Bootstrap Classpath ist nicht zusammen mit -source {0} festgelegt\n{1}

# 0: string, 1: fragment
compiler.warn.source.no.system.modules.path=Systemmodulpfad ist nicht zusammen mit -source {0} festgelegt\n{1}

# 0: string
compiler.misc.source.no.bootclasspath=Wenn Sie den Bootstrap Classpath nicht festlegen, kann dies zu Klassendateien führen, die auf JDK {0} nicht ausgeführt werden können\n--release {0} wird anstelle von -source {0} empfohlen, weil dadurch der Bootstrap Classpath automatisch festgelegt wird

# 0: string
compiler.misc.source.no.system.modules.path=Wenn Sie den Speicherort der Systemmodule nicht festlegen, kann dies zu Klassendateien führen, die auf JDK {0} nicht ausgeführt werden können\n--release {0} wird anstelle von -source {0} empfohlen, weil dadurch der Speicherort der Systemmodule automatisch festgelegt wird

# 0: string, 1: string
compiler.misc.source.no.bootclasspath.with.target=Wenn Sie den Bootstrap Classpath nicht festlegen, kann dies zu Klassendateien führen, die auf JDK 8 nicht ausgeführt werden können\n--release {0} wird anstelle von -source {0} -target {1} empfohlen, weil dadurch der Bootstrap Classpath automatisch festgelegt wird

# 0: string, 1: string
compiler.misc.source.no.system.modules.path.with.target=Wenn Sie den Speicherort der Systemmodule nicht festlegen, kann dies zu Klassendateien führen, die auf JDK {0} nicht ausgeführt werden können\n--release {0} wird anstelle von -source {0} -target {1} empfohlen, weil dadurch der Speicherort der Systemmodule automatisch festgelegt wird

# 0: string
compiler.warn.option.obsolete.source=Quellwert {0} ist veraltet und wird in einem zukünftigen Release entfernt

# 0: target
compiler.warn.option.obsolete.target=Zielwert {0} ist veraltet und wird in einem zukünftigen Release entfernt

# 0: string, 1: string
compiler.err.option.removed.source=Quelloption {0} wird nicht mehr unterstützt. Verwenden Sie {1} oder höher.

# 0: target, 1: target
compiler.err.option.removed.target=Zieloption {0} wird nicht mehr unterstützt. Verwenden Sie {1} oder höher.

compiler.warn.option.obsolete.suppression=Verwenden Sie -Xlint:-options, um Warnungen zu veralteten Optionen zu unterdrücken.

# 0: name, 1: number, 2: number, 3: number, 4: number
compiler.warn.future.attr={0}-Attribut, das in Klassendateien der Version {1}.{2} eingeführt wurde, wird in Klassendateien der Version {3}.{4} ignoriert

compiler.warn.requires.automatic=Erfordert Direktive für ein automatisches Modul

compiler.warn.requires.transitive.automatic=Erfordert transitive-Direktive für ein automatisches Modul

# Warnings related to annotation processing
# 0: string
compiler.warn.proc.package.does.not.exist=Package {0} ist nicht vorhanden

# 0: string
compiler.warn.proc.file.reopening=Versuch, mehrmals eine Datei für "{0}" zu erstellen

# 0: string
compiler.warn.proc.type.already.exists=Es ist bereits eine Datei für Typ "{0}" im Quellpfad oder Classpath vorhanden

# 0: string
compiler.warn.proc.type.recreate=Versuch, mehrmals eine Datei für Typ "{0}" zu erstellen

# 0: string
compiler.warn.proc.illegal.file.name=Datei kann nicht für unzulässigen Namen "{0}" erstellt werden.

# 0: string, 1: string
compiler.warn.proc.suspicious.class.name=Datei für einen Typ, dessen Name mit {1} endet, wird erstellt: "{0}"

# 0: string
compiler.warn.proc.file.create.last.round=Datei für Typ "{0}", die in der letzten Runde erstellt wurde, wird keiner Annotationsverarbeitung unterzogen.

# 0: string, 1: string
compiler.warn.proc.malformed.supported.string=Nicht wohlgeformte Zeichenfolge "{0}" für eine unterstützte Annotationsschnittstelle von Prozessor "{1}" zurückgegeben

# 0: set of string
compiler.warn.proc.annotations.without.processors=Diese Annotationen wurden von keinem Prozessor beansprucht: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=Unterstützte Quellversion "{0}" von Annotationsprozessor "{1}" kleiner als -source "{2}"

# 0: string, 1: string
compiler.warn.proc.duplicate.option.name=Doppelte unterstützte Option "{0}" von Annotationsprozessor "{1}" zurückgegeben

# 0: string, 1: string
compiler.warn.proc.duplicate.supported.annotation=Doppelte unterstützte Annotationsschnittstelle "{0}" von Annotationsprozessor "{1}" zurückgegeben

# 0: string
compiler.warn.proc.redundant.types.with.wildcard=Annotationsprozessor "{0}" unterstützt redundant sowohl "*" als auch andere Annotationsschnittstellen

compiler.warn.proc.proc-only.requested.no.procs=Annotationsverarbeitung ohne Kompilierung angefordert, aber keine Prozessoren gefunden.

compiler.warn.proc.use.implicit=Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -implicit, um eine Policy für die implizite Kompilierung anzugeben.

compiler.warn.proc.use.proc.or.implicit=Implizit kompilierte Dateien wurden keiner Annotationsverarbeitung unterzogen.\nVerwenden Sie -proc:none, um die Annotationsverarbeitung zu deaktivieren, oder -implicit, um eine Policy für die implizite Kompilierung anzugeben.

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager={0}

# 0: set of string
compiler.warn.proc.unclosed.type.files=Nicht geschlossene Dateien für die Typen "{0}". Diese Typen werden keiner Annotationsverarbeitung unterzogen

# 0: string
compiler.warn.proc.unmatched.processor.options=Die folgenden Optionen wurden von keinem Prozessor erkannt: "{0}"

compiler.warn.try.explicit.close.call=Expliziter Aufruf von close() für eine automatisch schließbare Ressource

# 0: symbol
compiler.warn.try.resource.not.referenced=Automatisch schließbare Ressource {0} wird nie im Body der entsprechenden try-Anweisung referenziert

# 0: type
compiler.warn.try.resource.throws.interrupted.exc=Automatisch schließbare Ressource {0} umfasst die Mitgliedsmethode close(), die InterruptedException auslösen könnte

compiler.warn.unchecked.assign=Nicht geprüfte Zuweisung: {0} zu {1}

# 0: symbol, 1: type
compiler.warn.unchecked.assign.to.var=Nicht geprüfte Zuweisung zu Variable {0} als Mitglied des Raw-Typs {1}

# 0: symbol, 1: type
compiler.warn.unchecked.call.mbr.of.raw.type=Nicht geprüfter Aufruf von {0} als Mitglied des Raw-Typs {1}

compiler.warn.unchecked.cast.to.type=Nicht geprüftes Casting zu Typ {0}

# 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
compiler.warn.unchecked.meth.invocation.applied=Nicht geprüfter Methodenaufruf: {0} {1} in {4} {5} wird auf die angegebenen Typen angewendet\nErforderlich: {2}\nErmittelt:    {3}

# 0: type
compiler.warn.unchecked.generic.array.creation=Nicht geprüfte Erstellung eines generischen Arrays für varargs-Parameter des Typs {0}

# 0: type
compiler.warn.unchecked.varargs.non.reifiable.type=Möglich Heap-Beschädigung aus parametrisiertem vararg-Typ {0}

# 0: symbol
compiler.warn.varargs.unsafe.use.varargs.param=Varargs-Methode könnte Heap-Beschädigung aus nicht reifizierbarem varargs-Parameter {0} verursachen

compiler.warn.missing.deprecated.annotation=Veraltetes Element ist nicht mit @Deprecated-Annotation versehen

# 0: kind name
compiler.warn.deprecated.annotation.has.no.effect=@Deprecated-Annotation hat keine Auswirkung auf diese {0}-Deklaration

# 0: string
compiler.warn.invalid.path=Ungültiger Dateiname: {0}

compiler.warn.doclint.not.available=Kein Serviceprovider für doclint verfügbar

# 0: string
compiler.err.invalid.path=Ungültiger Dateiname: {0}


# 0: path
compiler.warn.invalid.archive.file=Unerwartete Datei in Pfad: {0}

# 0: path
compiler.warn.unexpected.archive.file=Unerwartete Erweiterung für Archivdatei: {0}

# 0: path
compiler.err.no.zipfs.for.archive=Kein Dateisystemprovider zur Verarbeitung dieser Datei verfügbar: {0}

compiler.warn.div.zero=Division durch Null

compiler.warn.empty.if=Leere Anweisung nach "if"

# 0: type, 1: name
compiler.warn.annotation.method.not.found=Annotationsmethode "{1}()" kann nicht in Typ "{0}" gefunden werden

# 0: type, 1: name, 2: message segment
compiler.warn.annotation.method.not.found.reason=Annotationsmethode "{1}()" kann nicht in Typ "{0}" gefunden werden: {2}

# 0: file object, 1: symbol, 2: name
compiler.warn.unknown.enum.constant=Unbekannte Enum-Konstante {1}.{2}

# 0: file object, 1: symbol, 2: name, 3: message segment
compiler.warn.unknown.enum.constant.reason=Unbekannte Enum-Konstante {1}.{2}\nGrund: {3}

# 0: type, 1: type
compiler.warn.raw.class.use=Raw-Typ gefunden: {0}\nTypargumente für generische Klasse {1} fehlen

compiler.warn.diamond.redundant.args=Redundante Typargumente in neuem Ausdruck (verwenden Sie stattdessen den Rautenoperator).

compiler.warn.local.redundant.type=Redundanter Typ für lokale Variable (ersetzen Sie den expliziten Typ durch "var").

compiler.warn.potential.lambda.found=Die Erstellung dieser anonymen inneren Klasse kann in einen Lambda-Ausdruck umgewandelt werden.

compiler.warn.method.redundant.typeargs=Redundante Typargumente in Methodenaufruf.

# 0: symbol, 1: message segment
compiler.warn.varargs.redundant.trustme.anno=Redundante {0}-Annotation. {1}

# 0: symbol
compiler.warn.access.to.member.from.serializable.element=Zugriff auf Mitglied {0} aus serialisierbarem Element kann öffentlich für nicht vertrauenswürdigen Code zugänglich sein

# 0: symbol
compiler.warn.access.to.member.from.serializable.lambda=Zugriff auf Mitglied {0} aus serialisierbarem Lambda kann öffentlich für nicht vertrauenswürdigen Code zugänglich sein

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=<ID>

compiler.misc.token.character=<Zeichen>

compiler.misc.token.string=<Zeichenfolge>

compiler.misc.token.integer=<Ganzzahl>

compiler.misc.token.long-integer=<Ganzzahl vom Typ "long">

compiler.misc.token.float=<Float>

compiler.misc.token.double=<Double>

compiler.misc.token.bad-symbol=<ungültiges Symbol>

compiler.misc.token.end-of-input=<Ende der Eingabe>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected={0} erwartet

# 0: string
compiler.err.expected.str={0} erwartet

# 0: token, 1: token
compiler.err.expected2={0} oder {1} erwartet

# 0: token, 1: token, 2: token
compiler.err.expected3={0}, {1} oder {2} erwartet

# 0: token, 1: token, 2: token, 3: string
compiler.err.expected4={0}, {1}, {2} oder {3} erwartet

compiler.err.premature.eof=Dateiende beim Parsen erreicht

compiler.err.enum.constant.expected=Hier wird eine Enum-Konstante erwartet

compiler.err.enum.constant.not.expected=Hier wird keine Enum-Konstante erwartet

compiler.err.extraneous.semicolon=Überflüssiges Semikolon

compiler.warn.extraneous.semicolon=Überflüssiges Semikolon

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.expected.module.or.open="module" oder "open" erwartet

compiler.err.dot.class.expected=".class" erwartet

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned={0} verwaist

# 0: name
compiler.misc.anonymous.class=<anonyme {0}>

# 0: name, 1: type
compiler.misc.type.captureof=capture#{0} von {1}

compiler.misc.type.captureof.1=capture#{0}

compiler.misc.type.none=<kein Wert>

compiler.misc.unnamed.package=Unbenanntes Package

compiler.misc.unnamed.module=Unbenanntes Modul

#####

# 0: symbol, 1: message segment
compiler.err.cant.access=Kein Zugriff auf {0}\n{1}

# 0: name
compiler.misc.bad.class.file=Klassendatei ist ungültig für Klasse {0}

# 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
compiler.misc.bad.const.pool.entry=Ungültiger Konstantenpooleintrag in {0}\n{1} bei Index {2} erwartet

# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
compiler.misc.bad.const.pool.index=Ungültiger Konstantenpoolindex in {0}\nIndex {1} liegt nicht innerhalb der Poolgröße {2}.

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=Ungültige Klassendatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Classpath vorhanden ist.

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=Ungültige Quelldatei: {0}\n{1}\nEntfernen Sie die Datei, oder stellen Sie sicher, dass sie im richtigen Unterverzeichnis des Quellpfades vorhanden ist.

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=Ungültige Klassensignatur: {0}

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class=Ungültige einschließende Klasse für {0}: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=Ungültiges einschließendes Methodenattribut für Klasse {0}

compiler.misc.bad.runtime.invisible.param.annotations=Ungültiges RuntimeInvisibleParameterAnnotations-Attribut: {0}

compiler.misc.bad.const.pool.tag=Ungültiges Konstantenpooltag: {0}

compiler.misc.bad.const.pool.tag.at=Ungültiges Konstantenpooltag {0} bei {1}

# 0: number
compiler.misc.bad.utf8.byte.sequence.at=Ungültige UTF-8-Bytesequenz bei {0}

compiler.misc.unexpected.const.pool.tag.at=Unerwartetes Konstantenpooltag {0} bei {1}

# 0: number
compiler.misc.bad.class.truncated.at.offset=Klassendatei abgeschnitten bei Offset {0}

compiler.misc.bad.signature=Ungültige Signatur: {0}

compiler.misc.bad.type.annotation.value=Ungültiger Typ für Annotationszielwert: {0}

compiler.misc.bad.module-info.name=Ungültiger Klassenname

compiler.misc.class.file.wrong.class=Klassendatei enthält falsche Klasse: {0}

compiler.misc.module.info.invalid.super.class=module-info mit ungültiger Superklasse

# 0: name
compiler.misc.class.file.not.found=Klassendatei für {0} nicht gefunden

# 0: string (constant value), 1: symbol (constant field), 2: type (field type)
compiler.misc.bad.constant.range=Konstantenwert "{0}" für {1} liegt außerhalb des erwarteten Bereichs für {2}

# 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
compiler.misc.bad.constant.value=Ungültiger Konstantenwert "{0}" für {1}. {2} erwartet

# 0: type (field type)
compiler.misc.bad.constant.value.type=Variable des Typs "{0}" darf keinen Konstantenwert aufweisen, aber es wurde einer für sie angegeben

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.default.interface=Standardmethode in Klassendatei der Version {0}.{1} gefunden

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.static.interface=Statische Methode in Klassendatei der Version {0}.{1} gefunden

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.anachronistic.module.info=Moduldeklaration in Klassendatei der Version {0}.{1} gefunden

compiler.misc.module.info.definition.expected=module-info-Definition erwartet

# 0: name
compiler.misc.file.doesnt.contain.class=Datei enthält nicht Klasse {0}

# 0: symbol
compiler.misc.file.does.not.contain.package=Datei enthält nicht Package {0}

compiler.misc.file.does.not.contain.module=Datei enthält keine Moduldeklaration

compiler.misc.illegal.start.of.class.file=Unzulässiger Klassendateibeginn

# 0: name
compiler.misc.method.descriptor.invalid=Methodendeskriptor ungültig für {0}

compiler.misc.unable.to.access.file=Zugriff auf Datei nicht möglich: {0}

compiler.misc.unicode.str.not.supported=Unicode-Zeichenfolge wird in Klassendatei nicht unterstützt

compiler.misc.undecl.type.var=Nicht deklarierte Typvariable: {0}

compiler.misc.malformed.vararg.method=Klassendatei enthält nicht wohlgeformte Methode mit variabler Argumentanzahl: {0}

compiler.misc.wrong.version=Klassendatei hat die falsche Version {0}.{1}. Sie muss {2}.{3} lauten

compiler.misc.illegal.flag.combo=Klassendatei enthält unzulässige Kennzeichenkombination {0} für {1} {2}

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=Typargument {0} liegt nicht innerhalb des gültigen Bereichs von Typvariable {1}

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=Inkompatible Typen: {0}

# 0: message segment
compiler.misc.prob.found.req=Inkompatible Typen: {0}

# 0: message segment, 1: type, 2: type
compiler.warn.prob.found.req={0}\nErforderlich: {2}\nErmittelt:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types={0} kann nicht in {1} konvertiert werden

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=Möglicher Verlust bei Konvertierung von {0} in {1}

# 0: type, 1: type
compiler.warn.possible.loss.of.precision=Möglicher Verlust eines impliziten Cast von {0} bis {1} in zusammengesetzter Zuweisung

compiler.misc.unchecked.assign=Nicht geprüfte Konvertierung

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=Nicht geprüftes Casting

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: message segment
compiler.misc.try.not.applicable.to.type=try-with-resources nicht auf Variablentyp anwendbar\n({0})

#####

# 0: object, 1: message segment
compiler.err.type.found.req=Unerwarteter Typ\nErforderlich: {1}\nErmittelt:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=Klasse

compiler.misc.type.req.class.array=Klasse oder Array

compiler.misc.type.req.array.or.iterable=Array oder java.lang.Iterable

compiler.misc.type.req.ref=Referenz

compiler.misc.type.req.exact=Klasse oder Schnittstelle ohne Grenzwerte

# 0: type
compiler.misc.type.parameter=Typparameter {0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=Keine eindeutige maximale Instanz für Typvariable {0} mit oberen Grenzwerten {1} vorhanden

# 0: type, 1: list of type
compiler.misc.no.unique.minimal.instance.exists=Keine eindeutige minimale Instanz für Typvariable {0} mit unteren Grenzwerten {1} vorhanden

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=Inferenzvariable {0} hat inkompatible obere Grenzwerte {1}

# 0: type, 1: list of type
compiler.misc.incompatible.eq.bounds=Inferenzvariable {0} hat inkompatible Gleichheits-Constraints {1}

# 0: type, 1: fragment, 2: fragment
compiler.misc.incompatible.bounds=Inferenzvariable {0} hat inkompatible Grenzwerte\n{1}\n{2}

# 0: list of type
compiler.misc.lower.bounds=Untere Grenzwerte: {0}

# 0: list of type
compiler.misc.eq.bounds=Gleichheits-Constraints: {0}

# 0: list of type
compiler.misc.upper.bounds=Obere Grenzen: {0}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=Keine Instanzen von Typvariablen {0} vorhanden, sodass {1} {2} entspricht

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=Typvariable(n) {0} nicht ableitbar\n(nicht übereinstimmende Argumente; {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=Typvariable(n) {0} nicht ableitbar\n(Liste der tatsächlichen Argumente hat eine andere Länge als die der formalen Argumente)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=Typvariable(n) {0} nicht ableitbar\n(nicht übereinstimmende varargs, {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=Abgeleiteter Typ entspricht nicht den oberen Grenzwerten\nAbgeleitet: {0}\nObere Grenzwerte: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=Abgeleiteter Typ entspricht nicht den unteren Grenzwerten\nAbgeleitet: {0}\nUntere Grenzwerte: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=Abgeleiteter Typ entspricht nicht den Gleichheits-Constraints\nAbgeleitet: {0}\nGleichheits-Constraint(s): {1}

# 0: symbol
compiler.misc.diamond={0}<>

# 0: type
compiler.misc.diamond.non.generic="<>" kann nicht mit der nicht generischen Klasse {0} verwendet werden

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.arg=Typargument {0}, das für {1} abgeleitet wurde, ist in diesem Kontext nicht zulässig\nDas abgeleitete Argument kann nicht im Signaturattribut ausgedrückt werden

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.args=Typargumente {0}, die für {1} abgeleitet wurden, sind in diesem Kontext nicht zulässig\nAbgeleitete Argumente können nicht im Signaturattribut ausgedrückt werden

# 0: type
compiler.misc.diamond.and.explicit.params="<>" kann nicht mit expliziten Typparametern für Konstruktor verwendet werden

compiler.misc.mref.infer.and.explicit.params=Raw-Konstruktorreferenz kann nicht mit expliziten Typparametern für Konstruktor verwendet werden

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=Explizites Typargument {0} entspricht nicht den deklarierten Grenzwerten {1}

compiler.misc.arg.length.mismatch=Liste der tatsächlichen Argumente hat eine andere Länge als die der formalen Argumente

# 0: string
compiler.misc.wrong.number.type.args=Falsche Anzahl Typargumente. {0} erforderlich

# 0: message segment
compiler.misc.no.conforming.assignment.exists=Keine übereinstimmenden Argumente, {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=Keine übereinstimmenden varargs; {0}

#####

# 0: symbol or type, 1: file name
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file=Auf Auxiliary-Klasse {0} in {1} darf nicht von außerhalb der eigenen Quelldatei zugegriffen werden

## The first argument ({0}) is a "kindname".
# 0: kind name, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly={0} {1} in {2} ist abstrakt und kann nicht direkt aufgerufen werden

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref={0} {1} ist nicht statisch und kann nicht aus einem statischen Kontext referenziert werden

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.unbound.lookup=Unerwartete statische {0} {1} in ungebundenem Lookup gefunden

# 0: symbol kind, 1: symbol
compiler.misc.bad.instance.method.in.unbound.lookup=Unerwartete Instanz {0} {1} in ungebundenem Lookup gefunden

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.bound.lookup=Unerwartete statische {0} {1} in gebundenem Lookup gefunden

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
# 0: set of kind name, 1: set of kind name
compiler.err.unexpected.type=Unerwarteter Typ\nErforderlich: {0}\nErmittelt:    {1}

compiler.err.unexpected.lambda=Hier wird kein Lambda-Ausdruck erwartet

compiler.err.unexpected.mref=Hier wird keine Methodenreferenz erwartet

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: kind name, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=Symbol nicht gefunden\nSymbol: {0} {1}

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.misc.cant.resolve.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})

# 0: kind name, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=Symbol nicht gefunden\nSymbol: {0} {1}\nOrt: {4}

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}

### Following are replicated/used for method reference diagnostics

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=Symbol nicht gefunden\nSymbol: {0} {1}({3})\nOrt: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=Symbol nicht gefunden\nSymbol: {0} <{2}>{1}({3})\nOrt: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: kind name, 1: type or symbol, 2: unused
compiler.misc.location={0} {1}

# 0: kind name, 1: symbol, 2: type
compiler.misc.location.1={0} {1} von Typ {2}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=@interface

compiler.misc.kindname.constructor=Konstruktor

compiler.misc.kindname.enum=Enumeration

compiler.misc.kindname.interface=Schnittstelle

compiler.misc.kindname.static=statisch

compiler.misc.kindname.type.variable=Typvariable

compiler.misc.kindname.type.variable.bound=Grenzwert von Typvariable

compiler.misc.kindname.variable=Variable

compiler.misc.kindname.value=Wert

compiler.misc.kindname.method=Methode

compiler.misc.kindname.class=Klasse

compiler.misc.kindname.package=Package

compiler.misc.kindname.module=Modul

compiler.misc.kindname.static.init=statischer Initializer

compiler.misc.kindname.instance.init=Instanz-Initializer

compiler.misc.kindname.record.component=Datensatzkomponente

compiler.misc.kindname.record=Datensatz

#####

compiler.misc.no.args=keine Argumente

# 0: message segment
compiler.err.override.static={0}\nAußer Kraft setzende Methode ist statisch

# 0: message segment, 1: set of flag
compiler.err.override.meth={0}\nAußer Kraft gesetzte Methode ist {1}

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw={0}\nAußer Kraft gesetzte Methode löst nicht {1} aus

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of flag or string
compiler.err.override.weaker.access={0}\nVersuch, niedrigere Zugriffsberechtigungen zuzuweisen. War {1}

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret={0}\nRückgabetyp {1} ist nicht mit {2} kompatibel

# 0: message segment, 1: type, 2: type
compiler.warn.override.unchecked.ret={0}\nRückgabetyp erfordert eine nicht geprüfte Konvertierung von {1} in {2}

# 0: message segment, 1: type
compiler.warn.override.unchecked.thrown={0}\nAußer Kraft gesetzte Methode löst nicht {1} aus

# 0: symbol
compiler.warn.override.equals.but.not.hashcode=Klasse {0} setzt Gleichwertige außer Kraft. hashCode-Methode wird aber weder von der Klasse noch einer Superklasse außer Kraft gesetzt

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override={0} in {1} kann nicht {2} in {3} außer Kraft setzen

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.hide={0} in {1} kann nicht {2} in {3} ausblenden

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement={0} in {1} kann nicht {2} in {3} implementieren

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with={0} in {1} steht mit {2} in {3} in Konflikt

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override={0} in {1} setzt {2} in {3} außer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement={0} in {1} implementiert {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with={0} in {1} setzt {2} in {3} außer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override={0} in {1} setzt {2} in {3} außer Kraft

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement={0} in {1} implementiert {2} in {3}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with={0} in {1} setzt {2} in {3} außer Kraft

# 0: kind name, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method={0} {1}.{2} ist nicht anwendbar\n({3})

########################################
# Diagnostics for language feature changes.
# Such diagnostics have a common template which can be customized by using a feature
# diagnostic fragment (one of those given below).
########################################

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source={0} wird in -source {1} nicht unterstützt\n(Verwenden Sie -source {2} oder höher, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.err.feature.not.supported.in.source.plural={0} werden in -source {1} nicht unterstützt\n(Verwenden Sie -source {2} oder höher, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source={0} wird in -source {1} nicht unterstützt\n(Verwenden Sie -source {2} oder höher, um {0} zu aktivieren)

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source.plural={0} werden in -source {1} nicht unterstützt\n(Verwenden Sie -source {2} oder höher, um {0} zu aktivieren)

# 0: message segment (feature)
compiler.err.preview.feature.disabled={0} ist ein Vorschaufeature, das standardmäßig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)

# 0: message segment (feature)
compiler.err.preview.feature.disabled.plural={0} sind ein Vorschaufeature, das standardmäßig deaktiviert ist.\n(Verwenden Sie --enable-preview, um {0} zu aktivieren)

# 0: file object (classfile), 1: string (expected version)
compiler.err.preview.feature.disabled.classfile=Klassendatei für {0} verwendet Vorschaufeatures von Java SE {1}.\n(Verwenden Sie --enable-preview, um das Laden von Klassendateien mit Vorschaufeatures zu ermöglichen)

# 0: message segment (feature)
compiler.warn.preview.feature.use={0} ist ein Vorschaufeature, das in einem zukünftigen Release entfernt werden kann.

# 0: message segment (feature)
compiler.warn.preview.feature.use.plural={0} sind ein Vorschaufeature, das in einem zukünftigen Release entfernt werden kann.

# 0: file object (classfile), 1: string (expected version)
compiler.warn.preview.feature.use.classfile=Klassendatei für {0} verwendet Vorschaufeatures von Java SE {1}.

compiler.misc.feature.modules=Module

compiler.misc.feature.diamond.and.anon.class="<>" mit anonymen inneren Klassen

compiler.misc.feature.var.in.try.with.resources=Variablen in try-with-resources

compiler.misc.feature.private.intf.methods=Private Schnittstellenmethoden

compiler.misc.feature.text.blocks=Textblöcke

compiler.misc.feature.multiple.case.labels=Mehrere CASE-Labels

compiler.misc.feature.switch.rules=Switch-Regeln

compiler.misc.feature.switch.expressions=Switch-Ausdrücke

compiler.misc.feature.var.syntax.in.implicit.lambda=var-Syntax in impliziten Lambdas

compiler.misc.feature.pattern.matching.instanceof=Musterabgleich in instanceof

compiler.misc.feature.reifiable.types.instanceof=Reifizierbare Typen in instanceof

compiler.misc.feature.deconstruction.patterns=Dekonstruktionsmuster

compiler.misc.feature.unnamed.variables=Unbenannte Variablen

compiler.misc.feature.primitive.patterns=Primitive Muster

compiler.misc.feature.records=Datensätze

compiler.misc.feature.sealed.classes=Verschlüsselte Klassen

compiler.misc.feature.case.null=Null in Switch Cases

compiler.misc.feature.pattern.switch=Muster in Switch-Anweisungen

compiler.misc.feature.unconditional.patterns.in.instanceof=Nicht bedingte Muster in instanceof

compiler.misc.feature.implicit.classes=Implizit deklarierte Klassen

compiler.misc.feature.flexible.constructors=Flexible Konstruktoren

compiler.misc.feature.module.imports=Modulimporte

compiler.warn.underscore.as.identifier=Ab Release 9 ist "_" ein Schlüsselwort und kann nicht als ID verwendet werden

compiler.err.underscore.as.identifier=Ab Release 9 ist "_" ein Schlüsselwort und kann nicht als ID verwendet werden

compiler.err.use.of.underscore.not.allowed=Unterstrich ist hier nicht zulässig\nAb Release 9 ist ''_'' ein Schlüsselwort und kann nicht als ID verwendet werden\nAb Release 22 kann ''_'' als Name in der Deklaration unbenannter Muster, lokaler Variablen, Ausnahmeparameter oder Lambda-Parameter verwendet werden

compiler.err.use.of.underscore.not.allowed.non.variable=Unterstrich ist hier nicht zulässig

compiler.err.use.of.underscore.not.allowed.with.brackets=Auf das Unterstrichschlüsselwort "_" dürfen keine Klammern folgen

compiler.err.enum.as.identifier=Ab Release 5 ist "enum" ein Schlüsselwort und kann nicht als ID verwendet werden

compiler.err.assert.as.identifier=Ab Release 1.4 ist "assert" ein Schlüsselwort und kann nicht als ID verwendet werden

# TODO 308: make a better error message
compiler.err.this.as.identifier=Ab Release 8 ist "this" nur als Parametername für den Empfängertyp zulässig.\nDas muss der erste Parameter sein und darf kein Lambda-Parameter sein

compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=receiver-Parameter nicht für Konstruktor der obersten Klasse anwendbar

# TODO 308: make a better error message
# 0: annotation
compiler.err.cant.type.annotate.scoping.1=Scoping-Konstrukt kann nicht mit type-use-Annotation versehen werden: {0}

# TODO 308: make a better error message
# 0: list of annotation
compiler.err.cant.type.annotate.scoping=Scoping-Konstrukt kann nicht mit type-use-Annotationen versehen werden: {0}

# 0: type, 1: type
compiler.err.incorrect.receiver.name=Der Empfängername stimmt nicht mit dem einschließenden Klassentyp überein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=Der Empfängertyp stimmt nicht mit dem einschließenden Klassentyp überein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=Der Empfängertyp stimmt nicht mit dem einschließenden äußeren Klassentyp überein\nErforderlich: {0}\nErmittelt:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=Der Empfängername stimmt nicht mit dem einschließenden äußeren Klassentyp überein\nErforderlich: {0}\nErmittelt:    {1}

compiler.err.no.annotations.on.dot.class=Keine Annotationen im Typ eines Klassenliterals zulässig

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=#{0} anwendbare Methode gefunden: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=#{0} anwendbare Methode gefunden: {1}\n({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=#{0} nicht anwendbare Methode gefunden: {1}\n({2})

# 0: type
compiler.misc.partial.inst.sig=Teilweise instanziiert in: {0}

# 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=Methode {0} wird in Typ {1} als Kandidat {2} aufgelöst\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:

# 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=Fehlerhafte Auflösung für Methode {0} in Typ {1}\nPhase: {3}\nMit Istwerten: {4}\nMit type-args: {5}\nKandidaten:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=Instanziierung von Methode {0} verzögert\nInstanziierte Signatur: {1}\ntarget-type: {2}

########################################
# Diagnostics for lambda deduplication
# used by LambdaToMethod (debug only)
########################################

# 0: symbol
compiler.note.verbose.l2m.deduplicate=Lambda-Implementierungsmethode {0} wird dedupliziert

########################################
# Diagnostics for method reference search
# results used by Resolve (debug only)
########################################

# 0: fragment, 1: string, 2: number
compiler.note.method.ref.search.results.multi={0} Suchergebnisse für {1}, mit spezifischsten {2}\nAnwendbare Kandidaten:

# 0: number, 1: fragment, 2: symbol
compiler.misc.applicable.method.found.2=#{0} anwendbare Methode gefunden: {1} {2}

# 0: number, 1: fragment, 2: symbol, 3: message segment
compiler.misc.applicable.method.found.3=#{0} anwendbare Methode gefunden: {1} {2}\n({3})

compiler.misc.static=statisch

compiler.misc.non.static=nicht statisch

compiler.misc.bound=gebunden

compiler.misc.unbound=ungebunden

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=<Null>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var={0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured={0} erweitert {1} Super: {2} aus Erfassung von {3}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1={0} erweitert {1} aus Erfassung von {3}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar={0} erweitert {1}, deklariert in {2} {3}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1={0} deklariert in {2} {3}

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar={0} erweitert {1}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection={0} erweitert {1}

### Where clause headers ###
compiler.misc.where.description.captured=Dabei ist {0} eine neue Typvariable:

# 0: set of type
compiler.misc.where.description.typevar=Dabei ist {0} eine Typvariable:

# 0: set of type
compiler.misc.where.description.intersection=Dabei ist {0} ein Schnittmengentyp:

# 0: set of type
compiler.misc.where.description.captured.1=Dabei sind {0} neue Typvariablen:

# 0: set of type
compiler.misc.where.description.typevar.1=Dabei sind {0} Typvariablen:

# 0: set of type
compiler.misc.where.description.intersection.1=Dabei sind {0} Schnittmengentypen:

###
# errors related to doc comments

compiler.err.dc.bad.entity=Ungültige HTML-Entity

compiler.err.dc.bad.inline.tag=Falsche Verwendung von Inlinetag

compiler.err.dc.identifier.expected=ID erwartet

compiler.err.dc.invalid.html=ungültige HTML

compiler.err.dc.malformed.html=Nicht wohlgeformte HTML

compiler.err.dc.missing.semicolon=Semikolon fehlt

compiler.err.dc.no.content=kein Inhalt

compiler.err.dc.no.tag.name=Kein Tagname nach "@"

compiler.err.dc.no.url=keine URL

compiler.err.dc.no.title=kein Name

compiler.err.dc.gt.expected=">" erwartet

compiler.err.dc.ref.bad.parens=Unerwarteter Text nach Klammer

compiler.err.dc.ref.syntax.error=Syntaxfehler in Referenz

compiler.err.dc.ref.unexpected.input=Unerwarteter Text

compiler.err.dc.unexpected.content=Unerwarteter Inhalt

compiler.err.dc.unterminated.inline.tag=Nicht abgeschlossenes Inlinetag

compiler.err.dc.unterminated.signature=Nicht abgeschlossene Signatur

compiler.err.dc.unterminated.string=Nicht abgeschlossene Zeichenfolge

compiler.err.dc.ref.annotations.not.allowed=Annotationen nicht zulässig

###
# errors related to modules

compiler.err.expected.module="module" erwartet

# 0: symbol
compiler.err.module.not.found=Modul nicht gefunden: {0}

# 0: symbol
compiler.warn.module.not.found=Modul nicht gefunden: {0}

# 0: name
compiler.err.import.module.not.found=Importiertes Modul nicht gefunden: {0}

# 0: symbol
compiler.err.import.module.does.not.read.unnamed=Unbenanntes Modul kann Folgendes nicht lesen: {0}

# 0: symbol, 1: symbol
compiler.err.import.module.does.not.read=Modul {0} kann Folgendes nicht lesen: {1}

compiler.err.too.many.modules=Zu viele Moduldeklarationen gefunden

compiler.err.module.not.found.on.module.source.path=Modul nicht in Modulquellpfad gefunden

compiler.err.not.in.module.on.module.source.path=Nicht in einem Modul im Modulquellpfad

# 0: symbol
compiler.err.duplicate.module=Doppeltes Modul: {0}

# 0: symbol
compiler.err.duplicate.requires=Doppelte "requires": {0}

# 0: symbol
compiler.err.conflicting.exports=Doppelte oder unvereinbare Exporte: {0}

# 0: symbol
compiler.err.conflicting.opens=Doppelte oder unvereinbare "opens": {0}

# 0: symbol
compiler.err.conflicting.exports.to.module=Doppelte oder unvereinbare Exporte in Modul: {0}

# 0: symbol
compiler.err.conflicting.opens.to.module=Doppelte oder unvereinbare "opens" in Modul: {0}

compiler.err.no.opens.unless.strong="opens" nur in starken Modulen zulässig

# 0: symbol
compiler.err.repeated.provides.for.service=Mehrere "provides" für Service {0}

# 0: symbol, 1: symbol
compiler.err.duplicate.provides=Doppelte "provides": Service {0}, Implementierung {1}

# 0: symbol
compiler.err.duplicate.uses=Doppelte Verwendungen: {0}

# 0: symbol
compiler.err.service.implementation.is.abstract=Die Serviceimplementierung ist eine abstrakte Klasse: {0}

compiler.err.service.implementation.must.be.subtype.of.service.interface=Der Serviceimplementierungstyp muss ein Subtyp des Serviceschnittstellentyps sein oder eine öffentliche statische no-args-Methode namens "provider" aufweisen, die die Serviceimplementierung zurückgibt

compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface=Der Rückgabetyp der "provider"-Methode muss ein Subtyp des Serviceschnittstellentyps sein

# 0: symbol
compiler.err.service.implementation.is.inner=Die Serviceimplementierung ist eine innere Klasse: {0}

# 0: symbol
compiler.err.service.definition.is.enum=Die Servicedefinition ist eine Enumeration: {0}

# 0: symbol
compiler.err.service.implementation.doesnt.have.a.no.args.constructor=Die Serviceimplementierung hat keinen Standardkonstruktor: {0}

# 0: symbol
compiler.err.service.implementation.no.args.constructor.not.public=Der "no arguments"-Konstruktor der Serviceimplementierung ist nicht öffentlich: {0}

# 0: symbol
compiler.err.package.empty.or.not.found=Package ist leer oder nicht vorhanden: {0}

# 0: symbol
compiler.warn.package.empty.or.not.found=Package ist leer oder nicht vorhanden: {0}

compiler.err.no.output.dir=Kein Klassenausgabeverzeichnis angegeben

compiler.err.unnamed.pkg.not.allowed.named.modules=Unbenanntes Package ist in benannten Modulen nicht zulässig

# 0: name, 1: name
compiler.err.module.name.mismatch=Modulname {0} stimmt nicht mit dem erwarteten Namen {1} überein

# 0: name, 1: name
compiler.misc.module.name.mismatch=Modulname {0} stimmt nicht mit dem erwarteten Namen {1} überein

# 0: name
compiler.err.module.non.zero.opens=Bei geöffnetem Modul {0} ist opens_count ungleich Null

# 0: name
compiler.misc.module.non.zero.opens=Bei geöffnetem Modul {0} ist opens_count ungleich Null

compiler.err.module.decl.sb.in.module-info.java=Moduldeklarationen müssen in einer Datei namens module-info.java vorhanden sein

# 0: set of string
compiler.err.too.many.patched.modules=Zu viele gepatchte Module ({0}). Verwenden Sie --module-source-path

# 0: name, 1: name
compiler.err.file.patched.and.msp=Datei sowohl von --patch-module als auch von --module-source-path zugänglich, gehört aber in jedem Pfad zu einem anderen Modul: {0}, {1}

compiler.err.processorpath.no.processormodulepath=Unzulässige Kombination aus -processorpath und --processor-module-path

# 0: symbol
compiler.err.package.in.other.module=Package ist in einem anderen Modul vorhanden: {0}

# 0: symbol, 1: name, 2: symbol, 3: symbol
compiler.err.package.clash.from.requires=Modul {0} liest Package {1} sowohl aus {2} als auch aus {3}

# 0: name, 1: symbol, 2: symbol
compiler.err.package.clash.from.requires.in.unnamed=Das unbenannte Modul liest Package {0} sowohl aus {1} als auch aus {2}

# 0: string
compiler.err.module.not.found.in.module.source.path=Modul {0} nicht in Modulquellpfad gefunden

compiler.err.output.dir.must.be.specified.with.dash.m.option=Klassenausgabeverzeichnis muss angegeben werden, wenn die Option -m verwendet wird

compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=Modulquellpfad muss angegeben werden, wenn die Option -m verwendet wird

# 0: symbol
compiler.err.service.implementation.not.in.right.module=Serviceimplementierung muss in demselben Modul wie die provides-Direktive definiert werden

# 0: symbol
compiler.err.cyclic.requires=Zyklische Abhängigkeit mit {0}

# 0: fragment, 1: name
compiler.err.duplicate.module.on.path=Doppeltes Modul in {0}\nModul in {1}

# 0: option name, 1: string
compiler.warn.bad.name.for.option=Ungültiger Name im Wert für {0}-Option: "{1}"

# 0: option name, 1: string
compiler.err.bad.name.for.option=Ungültiger Name im Wert für {0}-Option: "{1}"

# 0: option name, 1: symbol
compiler.warn.module.for.option.not.found=Modulname in {0}-Option nicht gefunden: {1}

compiler.err.addmods.all.module.path.invalid=--add-modules ALL-MODULE-PATH kann nur beim Kompilieren des unbenannten Moduls oder beim Kompilieren im Kontext eines automatischen Moduls verwendet werden

# 0: symbol
compiler.err.add.exports.with.release=Export eines Packages aus Systemmodul {0} ist mit --release nicht zulässig

# 0: symbol
compiler.err.add.reads.with.release=Hinzufügen von Lese-Edges für Systemmodul {0} ist mit --release nicht zulässig

compiler.warn.addopens.ignored=--add-opens hat zur Kompilierungszeit keine Auswirkungen

compiler.misc.locn.module_source_path=Modulquellpfad

compiler.misc.locn.upgrade_module_path=Upgrademodulpfad

compiler.misc.locn.system_modules=Systemmodule

compiler.misc.locn.module_path=Anwendungsmodulpfad

compiler.misc.cant.resolve.modules=Module können nicht aufgelöst werden

compiler.misc.bad.requires.flag=Ungültiges requires-Kennzeichen: {0}

# 0: string
compiler.err.invalid.module.specifier=Modulbezeichner nicht zulässig: {0}

# 0: symbol
compiler.warn.service.provided.but.not.exported.or.used=Serviceschnittstelle angegeben, aber nicht exportiert oder verwendet

# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible={0} {1} in Modul {2} ist nicht zugänglich für Clients, die dieses Modul benötigen
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported={0} {1} in Modul {2} wird nicht exportiert
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.not.required.transitive={0} {1} in Modul {2} wird nicht indirekt mit "requires transitive" exportiert
# 0: kind name, 1: symbol, 2: symbol
compiler.warn.leaks.not.accessible.unexported.qualified={0} {1} in Modul {2} ist möglichweise nicht für alle Clients, die dieses Modul benötigen, sichtbar

###
# errors related to options

# 0: string, 1: string
compiler.err.illegal.argument.for.option=Unzulässiges Argument für {0}: {1}

compiler.err.match.binding.exists=Unzulässiger Versuch, ein vorhandenes Übereinstimmungs-Binding neu zu definieren

compiler.err.switch.case.unexpected.statement=Unerwartete Anweisung in Case. Ausdruck, Block oder throw-Anweisung erwartet

compiler.err.switch.mixing.case.types=Unterschiedliche Case-Typen im Switch verwendet

###
# errors related to sealed classes

# permits clause
# 0: fragment
compiler.err.invalid.permits.clause=Ungültige PERMITS-Klausel\n({0})

# 0: string
compiler.misc.class.is.not.sealed={0} muss verschlüsselt sein

# 0: type
compiler.misc.is.a.type.variable=Darf keine Typvariablen enthalten: {0}

# 0: type
compiler.misc.is.duplicated=Darf keine Duplikate enthalten: {0}

# 0: type
compiler.misc.doesnt.extend.sealed=Unterklasse {0} muss verschlüsselte Klasse erweitern

compiler.misc.must.not.be.same.class=Unzulässige Selbstreferenz in PERMITS-Klausel

# 0: type
compiler.misc.must.not.be.supertype=Unzulässige Referenz zu Supertyp {0}

# other sealed types related errors

compiler.err.sealed.class.must.have.subclasses=Verschlüsselte Klasse muss Unterklassen aufweisen

# errors in subclasses of sealed classes
# 0: symbol
compiler.err.cant.inherit.from.sealed=Klasse darf nicht verschlüsselte Klasse erweitern: {0} (da diese nicht in der "permits"-Klausel enthalten ist)

# 0: symbol
compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=Klasse {0} in unbenanntem Modul darf keine verschlüsselte Klasse in einem anderen Package erweitern

# 0: symbol, 1: symbol
compiler.err.class.in.module.cant.extend.sealed.in.diff.module=Klasse {0} in Modul {1} darf keine verschlüsselte Klasse in einem anderen Modul erweitern

# 0: symbol
compiler.err.non.sealed.with.no.sealed.supertype=Modifikator "non-sealed" ist hier nicht zulässig\n(Klasse {0} hat keine verschlüsselten Supertypen)

compiler.err.non.sealed.sealed.or.final.expected=Modifikator "sealed", "non-sealed" oder "final" erwartet

compiler.err.non.sealed.or.sealed.expected=Modifikator "sealed" oder "non-sealed" erwartet

compiler.err.sealed.or.non.sealed.local.classes.not.allowed=Lokale Klassen mit "sealed" oder "non-sealed" nicht zulässig

# 0: fragment
compiler.err.local.classes.cant.extend.sealed=Klassen vom Typ "{0}" dürfen keine verschlüsselten Klassen erweitern
compiler.misc.anonymous=Anonym

compiler.misc.local=Lokal

###
# errors related to records

# record components
compiler.err.record.cant.declare.field.modifiers=Datensatzkomponenten können keine Modifikatoren aufweisen

# 0: symbol
compiler.err.illegal.record.component.name=Unzulässiger Datensatzkomponentenname {0}

compiler.err.record.component.and.old.array.syntax=Legacy-Arraynotation für Datensatzkomponenten nicht zulässig

# accessor methods
# 0: symbol, 1: fragment
compiler.err.invalid.accessor.method.in.record=Ungültige Accessor-Methode in Datensatz {0}\n({1})

compiler.misc.method.must.be.public=Accessor-Methode muss öffentlich sein

# 0: symbol, 1: symbol
compiler.misc.accessor.return.type.doesnt.match=Rückgabetyp von Accessor-Methode {0} muss mit dem Typ der Datensatzkomponente {1} übereinstimmen

compiler.misc.accessor.method.cant.throw.exception=Throws-Klausel für Accessor-Methode nicht zulässig

compiler.misc.accessor.method.must.not.be.generic=Accessor-Methode darf nicht generisch sein

compiler.misc.accessor.method.must.not.be.static=Accessor-Methode darf nicht statisch sein

# canonical constructors
# 0: fragment, 1: name, 2: fragment
compiler.err.invalid.canonical.constructor.in.record=Ungültiger Konstruktor vom Typ {0} in Datensatz {1}\n({2})

compiler.misc.canonical=Kanonisch

compiler.misc.compact=Kompakt

# 0: fragment
compiler.misc.throws.clause.not.allowed.for.canonical.constructor=Throws-Klausel für Konstruktor des Typs {0} nicht zulässig

compiler.misc.canonical.with.name.mismatch=Ungültige Parameternamen in kanonischem Konstruktor

compiler.misc.canonical.cant.have.return.statement=Kompakter Konstruktor darf keine return-Anweisungen verwenden

compiler.misc.canonical.must.not.declare.type.variables=Kanonischer Konstruktor darf keine Typvariablen deklarieren

compiler.misc.type.must.be.identical.to.corresponding.record.component.type=Typ und Argumentanzahl müssen mit den Werten der entsprechenden Datensatzkomponente übereinstimmen
compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=Kanonischer Konstruktor darf keinen expliziten Konstruktoraufruf enthalten

# 0: set of flag or string
compiler.misc.canonical.must.not.have.stronger.access=Versuch, höhere Zugriffsberechtigungen zuzuweisen. War {0}

# other
compiler.err.record.cannot.declare.instance.fields=Felddeklaration muss statisch sein\n(ersetzen Sie unter Umständen das Feld durch eine Datensatzkomponente)

# 0: symbol
compiler.err.invalid.supertype.record=Klassen können {0} nicht direkt erweitern

# 0: symbol
compiler.err.non.canonical.constructor.invoke.another.constructor=Konstruktor ist nicht kanonisch. Daher muss ein anderer Konstruktor der Klasse {0} aufgerufen werden

compiler.err.instance.initializer.not.allowed.in.records=Instanz-Initializer in Datensätzen nicht zulässig

compiler.err.static.declaration.not.allowed.in.inner.classes=Statische Deklarationen in inneren Klassen nicht zulässig

compiler.err.record.patterns.annotations.not.allowed=Annotationen in Datensatzmustern nicht zulässig

############################################
# messages previously at javac.properties

compiler.err.empty.A.argument=-A erfordert ein Argument. Verwenden Sie "-Akey" oder "-Akey=value"

# 0: string
compiler.err.invalid.A.key=Schlüssel in Annotationsprozessoroption "{0}" ist keine durch Punkt getrennte ID-Sequenz

# 0: string
compiler.err.invalid.flag=Ungültiges Kennzeichen: {0}

compiler.err.profile.bootclasspath.conflict=Optionen "profile" und "bootclasspath" können nicht zusammen verwendet werden

# 0: string
compiler.err.invalid.profile=Ungültiges Profil: {0}

# 0: string
compiler.err.invalid.target=Ungültiges Zielrelease: {0}

# 0: option name, 1: target
compiler.err.option.not.allowed.with.target=Option {0} mit Ziel {1} nicht zulässig

# 0: string
compiler.err.option.too.many=Option {0} kann nur einmal angegeben werden

compiler.err.no.source.files=Keine Quelldateien

compiler.err.no.source.files.classes=Keine Quelldateien oder Klassennamen

# 0: string
compiler.err.req.arg={0} erfordert ein Argument

# 0: string
compiler.err.invalid.source=Ungültiges Quellrelease: {0}

# 0: string, 1: string
compiler.err.error.writing.file=Fehler beim Schreiben von {0}. {1}

compiler.err.sourcepath.modulesourcepath.conflict=--source-path und --module-source-path können nicht beide angegeben werden

# 0: string, 1: string
compiler.err.source.target.conflict=Angegebenes Zielrelease {1} ist zu alt für das angegebene Quellrelease {0}\n--release {1} wird beim Kompilieren von Code, der auf JDK {1} ausgeführt werden soll, empfohlen

# 0: string, 1: string
compiler.err.target.default.source.conflict=Angegebenes Zielrelease {1} ist zu alt für das standardmäßige Quellrelease {0}\n--release {1} wird beim Kompilieren von Code, der auf JDK {1} ausgeführt werden soll, empfohlen

# 0: profile, 1: target
compiler.warn.profile.target.conflict=Profil {0} ist für Zielrelease {1} nicht gültig

# 0: string
compiler.err.file.not.directory=Kein Verzeichnis: {0}

# 0: object
compiler.err.file.not.file=Keine Datei: {0}

compiler.err.two.class.loaders.1=javac ist auf mehrere Class Loader aufgeteilt: Prüfen Sie die Konfiguration

# 0: url, 1: url
compiler.err.two.class.loaders.2=javac ist auf mehrere Class Loader aufgeteilt:\nEine Klasse stammt aus Datei {0},\nwährend javac aus {1} stammt

# 0: string, 1: string
compiler.err.bad.value.for.option=Ungültiger Wert für {0}-Option: "{1}"

# 0: string
compiler.err.no.value.for.option=Kein Wert für {0}-Option

# 0: string
compiler.err.repeated.value.for.patch.module=--patch-module mehrmals für Modul {0} angegeben

# 0: string
compiler.err.repeated.value.for.module.source.path=--module-source-path mehrmals für Modul {0} angegeben

compiler.err.multiple.values.for.module.source.path=--module-source-path mehrmals mit Musterargument angegeben

# 0: string
compiler.err.unmatched.quote=Alleinstehendes Anführungszeichen in Umgebungsvariable {0}

# 0: option name
compiler.err.release.bootclasspath.conflict=Option {0} kann nicht zusammen mit --release verwendet werden

# 0: string
compiler.err.unsupported.release.version=Releaseversion {0} nicht unterstützt

# 0: string
compiler.err.file.not.found=Datei nicht gefunden: {0}

# 0: string, 1: source
compiler.err.preview.not.latest=Ungültiges Quellrelease {0} mit --enable-preview\n(Vorschausprachfeatures werden nur für Release {1} unterstützt)

compiler.err.preview.without.source.or.release=--enable-preview muss mit -source oder --release verwendet werden

# 0: symbol
compiler.err.deconstruction.pattern.only.records=Dekonstruktionsmuster können nur auf Datensätze angewendet werden. {0} ist kein Datensatz

compiler.err.deconstruction.pattern.var.not.allowed=Dekonstruktionsmuster können nur auf Datensätze angewendet werden, "var" ist nicht zulässig

# 0: list of type, 1: list of type
compiler.err.incorrect.number.of.nested.patterns=Falsche Anzahl verschachtelter Muster\nErforderlich: {0}\nGefunden: {1}

# 0: kind name, 1: symbol
compiler.warn.declared.using.preview={0} {1} ist mit einem Vorschaufeature deklariert, das in einem zukünftigen Release entfernt werden kann.

compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class=Versuch der Synchronisierung für eine Instanz einer wertbasierten Klasse

# 0: type
compiler.err.enclosing.class.type.non.denotable=Einschließender Klassentyp: {0}\nist nicht deklarierbar. Führen Sie das Casting in einen deklarierbaren Typ aus
