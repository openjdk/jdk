#
# Copyright (c) 1999, 2025, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# Messages in this file which use "placeholders" for values (e.g. {0}, {1})
# are preceded by a stylized comment describing the type of the corresponding
# values.
# The simple types currently in use are:
#
# annotation        annotation compound
# boolean           true or false
# diagnostic        a sub-message; see compiler.misc.*
# fragment          similar to 'message segment', but with more specific type
# modifier          a Java modifier; e.g. public, private, protected
# file              a file URL
# file object       a file URL - similar to 'file' but typically used for source/class files, hence more specific
# flag              a Flags.Flag instance
# name              a name, typically a Java identifier
# number            an integer
# option name       the name of a command line option
# path              a path
# profile           a profile name
# source            a source version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.code.Source
# source version    a source version number, such as 1.5, 1.6, 1.7, taken from a javax.lang.model.SourceVersion
# string            a general string
# symbol            the name of a declared type
# symbol kind       the kind of a symbol (i.e. method, variable)
# kind name         an informative description of the kind of a declaration; see compiler.misc.kindname.*
# target            a target version number, such as 1.5, 1.6, 1.7, taken from a com.sun.tools.javac.jvm.Target
# token             the name of a non-terminal in source code; see compiler.misc.token.*
# tree tag          the name of a non-terminal in source code; see compiler.misc.token.*
# type              a Java type; e.g. int, X, X<T>
# url               a URL
# object            a Java object (unspecified)
# unused            the value is not used in this message
#
# The following compound types are also used:
#
# collection of X   a comma-separated collection of items; e.g. collection of type
# list of X         a comma-separated list of items; e.g. list of type
# set of X          a comma-separated set of items; e.g. set of modifier
#
# These may be composed:
#
# list of type or message segment
#
# The following type aliases are supported:
#
# message segment --> diagnostic or fragment
# file name --> file, path or file object
#
# Custom comments are supported in parenthesis i.e.
#
# number (classfile major version)
#
# These comments are used internally in order to generate an enum-like class declaration containing
# a method/field for each of the diagnostic keys listed here. Those methods/fields can then be used
# by javac code to build diagnostics in a type-safe fashion.
#
# In addition, these comments are verified by the jtreg test test/tools/javac/diags/MessageInfo,
# using info derived from the collected set of examples in test/tools/javac/diags/examples.
# MessageInfo can also be run as a standalone utility providing more facilities
# for manipulating this file. For more details, see MessageInfo.java.

##
## errors
##

# 0: symbol
compiler.err.abstract.cant.be.instantiated={0}是抽象的; 无法实例化

compiler.err.abstract.meth.cant.have.body=抽象方法不能有主体

# 0: kind name, 1: symbol
compiler.err.already.annotated={0} {1} 已进行批注

# 0: kind name, 1: symbol, 2: kind name, 3: symbol
compiler.err.already.defined=已在{2} {3}中定义了{0} {1}

# 0: kind name, 1: symbol, 2: kind name, 3: kind name, 4: symbol
compiler.err.already.defined.in.clinit=已在{3} {4}的{2}中定义了{0} {1}

# 0: symbol
compiler.err.already.defined.single.import={0}的 single-type-import 已定义具有相同简名的类型

# 0: symbol
compiler.err.already.defined.static.single.import={0}的静态 single-type-import 已定义具有相同简名的类型

# 0: symbol
compiler.err.already.defined.this.unit=已在该编译单元中定义{0}

compiler.err.annotation.missing.element.value=批注缺少元素值

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value=对于元素 ''{1}'', 批注 @{0} 缺少默认值

# 0: type, 1: list of name
compiler.err.annotation.missing.default.value.1=对于元素{1}, 批注 @{0} 缺少默认值

# 0: type
compiler.err.annotation.not.valid.for.type=批注对于类型{0}的元素无效

compiler.err.annotation.type.not.applicable=批注接口不适用于此类型的声明

# 0: type
compiler.err.annotation.type.not.applicable.to.type=批注 @{0} 在此类型上下文中不适用

compiler.err.annotation.value.must.be.annotation=批注值必须为批注

compiler.err.annotation.value.must.be.class.literal=批注值必须为类文字

compiler.err.annotation.value.must.be.name.value=批注值必须采用 ''name=value'' 格式

compiler.err.annotation.value.not.allowable.type=批注值不是允许的类型

compiler.err.expression.not.allowable.as.annotation.value=表达式不允许用作批注值

# 0: type, 1: name
compiler.err.annotation.unrecognized.attribute.name=批注 @{0} 具有名为 ''{1}'' 的未知属性

compiler.err.anon.class.impl.intf.no.args=匿名类实现接口; 不能有参数

compiler.err.anon.class.impl.intf.no.typeargs=匿名类实现接口; 不能具有类型参数

compiler.err.anon.class.impl.intf.no.qual.for.new=匿名类实现接口; 不能有限定符 - 对于新

compiler.err.cant.inherit.from.anon=无法从匿名类继承

# 0: symbol, 1: symbol, 2: symbol
compiler.err.array.and.varargs=无法在{2}中同时声明{0}和{1}

compiler.err.array.dimension.missing=缺少数组维

compiler.err.illegal.array.creation.both.dimension.and.initialization=同时使用维表达式和初始化创建数组是非法的

# 0: type
compiler.err.array.req.but.found=需要数组, 但找到{0}

compiler.err.attribute.value.must.be.constant=元素值必须为常量表达式

# 0: string (statement type)
compiler.err.bad.initializer={0}的初始化程序错误

compiler.err.break.outside.switch.loop=在 switch 或 loop 外部中断

compiler.err.break.outside.switch.expression=尝试从 switch 表达式中断

compiler.err.continue.outside.switch.expression=尝试从 switch 表达式继续

compiler.err.return.outside.switch.expression=尝试从 switch 表达式返回

compiler.err.rule.completes.normally=switch 规则完结但没有提供值\n（switch 表达式中的 switch 规则必须提供值或抛出）

compiler.err.switch.expression.completes.normally=switch 表达式完结但没有提供值\n（switch 表达式必须为所有可能的输入值提供值或抛出）

compiler.err.no.switch.expression =yield 在 switch 表达式外部

compiler.err.no.switch.expression.qualify=yield 在 switch 表达式外部\n（要调用称为 yield 的方法，请通过接收方或类型名称限定 yield）

compiler.err.invalid.yield=受限标识符 ''yield'' 的用法无效\n（要调用称为 yield 的方法，请通过接收方或类型名称限定 yield）

compiler.warn.invalid.yield=''yield'' 在未来发行版中可能会成为受限标识符\n（要调用称为 yield 的方法，请通过接收方或类型名称限定 yield）

compiler.err.switch.expression.empty=switch 表达式中没有任何 case 子句

compiler.err.switch.expression.no.result.expressions=switch 表达式没有任何结果表达式

compiler.err.call.must.only.appear.in.ctor=显式构造器调用只能出现在构造器主体中

compiler.err.redundant.superclass.init=冗余显式构造器调用

compiler.err.ctor.calls.not.allowed.here=此处不允许使用显式构造器调用

compiler.err.return.before.superclass.initialized=在显式构造器调用之前不允许使用 ''return''

# 0: symbol kind, 1: name, 2: symbol kind, 3: type, 4: message segment
compiler.err.cant.apply.symbol.noargs=无法将 {2} {3} 中的 {0} {1} 应用于给定类型；\n原因：{4}

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.err.cant.apply.symbol=无法将{4} {5}中的{0} {1}应用到给定类型;\n需要: {2}\n找到:    {3}\n原因: {6}

# 0: symbol kind, 1: name, 2: list of type
compiler.err.cant.apply.symbols=对于{1}({2}), 找不到合适的{0}

# 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
compiler.misc.cant.apply.symbol=无法将 {4} {5}中的 {0} {1}应用到给定类型\n需要: {2}\n找到:    {3}\n原因: {6}

# 0: list of type or message segment, 1: list of type or message segment, 2: message segment
compiler.misc.cant.apply.array.ctor=无法基于给定类型创建数组\n需要：{0}\n找到：{1}\n原因：{2}

# 0: symbol kind, 1: name, 2: list of type
compiler.misc.cant.apply.symbols=对于{1}({2}), 找不到合适的{0}

# 0: kind name, 1: symbol
compiler.misc.no.abstracts=在 {0} {1} 中找不到抽象方法

# 0: kind name, 1: symbol
compiler.misc.incompatible.abstracts=在 {0} {1} 中找到多个非覆盖抽象方法

compiler.err.bad.functional.intf.anno=意外的 @FunctionalInterface 批注

# 0: message segment
compiler.err.bad.functional.intf.anno.1=意外的 @FunctionalInterface 批注\n{0}

# 0: message segment
compiler.err.anonymous.diamond.method.does.not.override.superclass=方法不会覆盖或实现超类型中的方法\n{0}

# 0: symbol
compiler.misc.not.a.functional.intf={0} 不是函数接口

# 0: symbol, 1: message segment
compiler.misc.not.a.functional.intf.1={0} 不是函数接口\n{1}

# 0: type, 1: kind name, 2: symbol
compiler.misc.invalid.generic.lambda.target=lambda 表达式的函数描述符无效\n{1} {2} 中的方法 {0} 为泛型方法

# 0: kind name, 1: symbol
compiler.misc.incompatible.descs.in.functional.intf=在 {0} {1} 中找到不兼容的函数描述符

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor=描述符: {2} {0}({1})

# 0: name, 1: list of type, 2: type, 3: list of type
compiler.misc.descriptor.throws=描述符: {2} {0}({1}) 抛出{3}

# 0: type
compiler.misc.no.suitable.functional.intf.inst=无法推断{0}的函数接口描述符

# 0: message segment
compiler.misc.bad.intersection.target.for.functional.expr=lambda 或方法引用的交叉类型目标错误\n{0}

# 0: symbol or type
compiler.misc.not.an.intf.component=组件类型 {0} 不是接口或 java.lang.Object

# 0: kind name, 1: message segment
compiler.err.invalid.mref={0}引用无效\n{1}

# 0: kind name, 1: message segment
compiler.misc.invalid.mref={0}引用无效\n{1}

compiler.misc.static.mref.with.targs=有关静态方法引用的参数化限定符

# 0: set of flag or string, 1: symbol
compiler.err.cant.assign.val.to.var=无法为 {0} 变量 {1} 分配值

compiler.err.cant.assign.val.to.this=无法分配给 ''this''

# 0: symbol, 1: message segment
compiler.err.cant.ref.non.effectively.final.var=从{1}引用的本地变量必须是最终变量或实际上的最终变量

compiler.err.try.with.resources.expr.needs.var=try-with-resources 资源必须是变量声明, 或者是指示对最终变量或实际上的最终变量的引用的表达式

# 0: symbol
compiler.err.try.with.resources.expr.effectively.final.var=用作 try-with-resources 资源的变量 {0} 既不是最终变量, 也不是实际上的最终变量


compiler.misc.lambda=lambda 表达式

compiler.misc.inner.cls=内部类

compiler.misc.guard=卫士

# 0: type
compiler.err.cant.deref=无法取消引用{0}

compiler.err.cant.extend.intf.annotation=对于 @interfaces, 不允许 ''extends''

compiler.err.annotation.decl.not.allowed.here=此处不允许批注接口声明

# 0: symbol
compiler.err.cant.inherit.from.final=无法从最终{0}进行继承

# 0: symbol or name
compiler.err.cant.ref.before.ctor.called=无法在调用超类型构造器之前引用{0}

# 0: symbol or name
compiler.err.cant.assign.initialized.before.ctor.called=无法在调用超类型构造器之前分配初始化字段 ''{0}''

compiler.err.cant.select.static.class.from.param.type=无法从参数化的类型中选择静态类

# 0: symbol, 1: string, 2: string
compiler.err.cant.inherit.diff.arg=无法使用以下不同的参数继承{0}: <{1}> 和 <{2}>

compiler.err.catch.without.try=有 ''catch'', 但是没有 ''try''

# 0: kind name, 1: symbol
compiler.err.clash.with.pkg.of.same.name={0} {1}与带有相同名称的程序包冲突

compiler.err.class.not.allowed=此处不允许使用类, 接口或枚举声明

compiler.err.const.expr.req=需要常量表达式

compiler.err.pattern.or.enum.req=需要模式或枚举常量

compiler.err.cont.outside.loop=continue 在 loop 外部

# 0: symbol or type
compiler.err.cyclic.inheritance=涉及{0}的循环继承

# 0: symbol
compiler.err.cyclic.annotation.element=元素 {0} 的类型为循环

# 0: symbol
compiler.err.call.to.super.not.allowed.in.enum.ctor=在枚举构造器中不允许调用超类

# 0: type
compiler.err.no.superclass={0}不具有超类。

# 0: symbol, 1: type, 2: symbol, 3: type, 4: type
compiler.err.concrete.inheritance.conflict={1}中的方法{0}和{3}中的方法{2}是使用相同的签名继承的

compiler.err.default.allowed.in.intf.annotation.member=批注接口声明中仅允许默认值

# 0: symbol
compiler.err.doesnt.exist=程序包{0}不存在

# 0: type
compiler.err.duplicate.annotation.invalid.repeated=批注{0}不是有效的可重复批注

# 0: name, 1: type
compiler.err.duplicate.annotation.member.value=批注@{1}中的元素 ''{0}'' 重复。

# 0: type
compiler.err.duplicate.annotation.missing.container={0} 不是可重复的批注接口

# 0: symbol
compiler.err.invalid.repeatable.annotation=批注重复: 使用无效的 @Repeatable 批注对{0}进行了批注

# 0: symbol or type
compiler.err.invalid.repeatable.annotation.no.value={0}不是有效的 @Repeatable, 未声明任何值元素方法

# 0: type, 1: number
compiler.err.invalid.repeatable.annotation.multiple.values={0}不是有效的 @Repeatable, 已声明 {1} 个名为 ''value'' 的元素方法

# 0: type
compiler.err.invalid.repeatable.annotation.invalid.value={0}不是有效的 @Repeatable: 值元素无效

# 0: symbol or type, 1: type, 2: type
compiler.err.invalid.repeatable.annotation.value.return=包含批注接口 ({0}) 必须声明类型 {2} 的名为 ''value'' 的元素

# 0: symbol or type, 1: symbol
compiler.err.invalid.repeatable.annotation.elem.nondefault=包含批注接口 ({0}) 没有元素 {1} 的默认值

# 0: symbol, 1: string, 2: symbol, 3: string
compiler.err.invalid.repeatable.annotation.retention=包含批注接口 ({0}) 的保留期短于可重复批注接口 ({2}) 的保留期

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.documented=可重复批注接口 ({1}) 是 @Documented，而包含批注接口 ({0}) 则不是

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.not.inherited=可重复批注接口 ({1}) 是 @Inherited，而包含批注接口 ({0}) 则不是

# 0: symbol, 1: symbol
compiler.err.invalid.repeatable.annotation.incompatible.target=包含批注接口 ({0}) 适用的目标多于可重复批注接口 ({1})

# 0: symbol
compiler.err.invalid.repeatable.annotation.repeated.and.container.present=容器 {0} 不得与其包含的元素同时存在

# 0: type, 1: symbol
compiler.err.invalid.repeatable.annotation.not.applicable=容器{0}不适用于元素 {1}

# 0: type
compiler.err.invalid.repeatable.annotation.not.applicable.in.context=容器{0}在此类型上下文中不适用

# 0: name
compiler.err.duplicate.class=类重复: {0}

# 0: string
compiler.err.bad.file.name=文件名错误：{0}

compiler.err.implicit.class.should.not.have.package.declaration=压缩源文件不应有程序包声明

compiler.err.implicit.class.does.not.have.main.method=压缩源文件没有 void main() 或 void main(String[] args) 形式的 main 方法

# 0: name, 1: name
compiler.err.same.binary.name=类：{0} 和 {1} 具有相同的二进制名称

compiler.err.duplicate.case.label=case 标签重复

compiler.err.pattern.dominated=此 case 标签由前一个 case 标签支配

compiler.err.duplicate.default.label=default 标签重复

compiler.err.duplicate.unconditional.pattern=无条件模式重复

compiler.err.unconditional.pattern.and.default=switch 有一个无条件模式和一个 default 标签

compiler.err.unconditional.pattern.and.both.boolean.values=switch 有布尔值和一个无条件模式

compiler.err.default.and.both.boolean.values=switch 有布尔值和一个 default 标签

compiler.err.guard.not.allowed=只有包含模式的 case 允许使用卫士

compiler.err.guard.has.constant.expression.false=此 case 标签有一个卫士，它是值为 ''false'' 的常量表达式

# 0: symbol
compiler.err.cannot.assign.not.declared.guard=无法分配给 {0}，因为未在卫士内声明它

# 0: type, 1: type
compiler.err.constant.label.not.compatible={0} 类型的常量标签与 switch 选择器类型 {1} 不兼容

compiler.err.flows.through.to.pattern=贯穿 (fall-through) 到模式非法\n（上一个 case 标签缺少中断）

compiler.err.flows.through.from.pattern=从模式贯穿 (fall-through) 非法\n（当前 case 标签缺少中断）

compiler.err.invalid.case.label.combination=case 标签组合无效

compiler.err.default.label.not.allowed=此处不允许使用 default 标签

compiler.err.pattern.type.cannot.infer=无法推断模式类型

compiler.err.else.without.if=有 ''if'', 但是没有 ''else''

compiler.err.empty.char.lit=空字符文字

# 0: symbol
compiler.err.encl.class.required=需要包含{0}的封闭实例

compiler.err.enum.annotation.must.be.enum.constant=枚举批注值必须是枚举常量

compiler.err.enum.cant.be.instantiated=无法实例化枚举类

compiler.err.enum.label.must.be.unqualified.enum=枚举 switch case 标签必须为枚举常量的非限定名称

compiler.err.enum.label.must.be.enum.constant=枚举 switch 常量 case 的标签必须为枚举常量

compiler.err.enum.no.subclassing=类无法直接扩展 java.lang.Enum

compiler.err.enum.types.not.extensible=枚举类不可扩展

compiler.err.enum.no.finalize=枚举不能有 finalize 方法

compiler.err.enum.cant.be.generic=枚举不能为泛型

# 0: file name, 1: string
compiler.err.error.reading.file=读取{0}时出错; {1}

# 0: type
compiler.err.except.already.caught=已捕获到异常错误{0}

# 0: type
compiler.err.except.never.thrown.in.try=在相应的 try 语句主体中不能抛出异常错误{0}

# 0: symbol
compiler.err.final.parameter.may.not.be.assigned=不能分配最终参数{0}

# 0: symbol
compiler.err.try.resource.may.not.be.assigned=可能未分配可自动关闭的资源{0}

# 0: symbol
compiler.err.multicatch.parameter.may.not.be.assigned=可能未分配 multi-catch 参数{0}

# 0: type, 1: type
compiler.err.multicatch.types.must.be.disjoint=multi-catch 语句中的替代无法通过子类化关联\n替代{0}是替代{1}的子类

compiler.err.finally.without.try=有 ''finally'', 但是没有 ''try''

# 0: type, 1: message segment
compiler.err.foreach.not.applicable.to.type=for-each 不适用于表达式类型\n要求: {1}\n找到:    {0}

compiler.err.fp.number.too.large=浮点数太大

compiler.err.fp.number.too.small=浮点数太小

compiler.err.generic.array.creation=创建泛型数组

compiler.err.generic.throwable=泛型类不能扩展 java.lang.Throwable

# 0: symbol
compiler.err.icls.cant.have.static.decl=内部类{0}中的静态声明非法\n修饰符 ''static'' 仅允许在常量变量声明中使用

# 0: string
compiler.err.illegal.char=非法字符: ''{0}''

# 0: string, 1: string
compiler.err.illegal.char.for.encoding=编码 {1} 的不可映射字符 (0x{0})

# 0: set of flag, 1: set of flag
compiler.err.illegal.combination.of.modifiers=非法的修饰符组合: {0}和{1}

compiler.err.illegal.enum.static.ref=初始化程序中对静态字段的引用不合法

compiler.err.illegal.char.literal.multiple.surrogates=字符文字包含多个 UTF-16 代码单元

compiler.err.illegal.esc.char=非法逃逸 符

compiler.err.illegal.forward.ref=非法前向引用

# 0: symbol, 1: object
compiler.err.not.in.profile={0}在配置文件 ''{1}'' 中不可用

# 0: symbol
compiler.warn.forward.ref=先引用变量 ''{0}'', 然后再对其初始化

# lint: this-escape
compiler.warn.possible.this.escape=可能在完全初始化子类之前逃逸了 ''this''

# lint: this-escape
compiler.warn.possible.this.escape.location=此处以前可能通过调用逃逸 了 ''this''

compiler.err.illegal.self.ref=初始化程序中存在自引用

# 0: symbol
compiler.warn.self.ref=变量 ''{0}'' 的初始化程序中存在自引用

# 0: type
compiler.err.illegal.initializer.for.type={0}的初始化程序不合法

compiler.err.illegal.line.end.in.char.lit=字符文字的行结尾不合法

compiler.err.illegal.text.block.open=文本块起始分隔符序列非法，缺少行终止符

# lint: text-blocks
compiler.warn.inconsistent.white.space.indentation=空格缩进不一致

# lint: text-blocks
compiler.warn.trailing.white.space.will.be.removed=将删除尾随空格

compiler.err.illegal.nonascii.digit=非法的非 ASCII 数字

compiler.err.illegal.underscore=非法下划线

compiler.err.illegal.dot=非法 ''.''

compiler.err.illegal.digit.in.binary.literal=二进制文字中的数字非法

compiler.err.illegal.digit.in.octal.literal=八进制文字中的数字非法

# 0: symbol
compiler.err.illegal.qual.not.icls=非法限定符; {0}不是内部类

compiler.err.illegal.start.of.expr=非法的表达式开始

compiler.err.illegal.start.of.stmt=非法的语句开始

compiler.err.illegal.start.of.type=非法的类型开始

compiler.err.illegal.parenthesized.expression=非法的含括号表达式

compiler.err.illegal.unicode.esc=非法的 Unicode 逃逸

# 0: symbol
compiler.err.import.requires.canonical=导入需要{0}的规范名称

compiler.err.improperly.formed.type.param.missing=类型的格式不正确, 缺少某些参数

compiler.err.improperly.formed.type.inner.raw.param=类型的格式不正确, 给出了原始类型的类型参数

# 0: type, 1: type
compiler.err.incomparable.types=不可比较的类型: {0}和{1}

# 0: string
compiler.err.int.number.too.large=整数太大

compiler.err.intf.annotation.members.cant.have.params=批注接口声明中的元素无法声明形参

# 0: symbol
compiler.err.intf.annotation.cant.have.type.params=批注接口 {0} 不能为泛型

compiler.err.intf.annotation.members.cant.have.type.params=批注接口声明中的元素不能为泛型方法

# 0: symbol, 1: type
compiler.err.intf.annotation.member.clash=批注接口 {1} 声明的元素与方法 {0} 同名

compiler.err.intf.expected.here=此处需要接口

compiler.err.intf.meth.cant.have.body=接口抽象方法不能带有主体

compiler.err.invalid.annotation.member.type=批注接口元素的类型无效

compiler.err.invalid.binary.number=二进制数字中必须包含至少一个二进制数

compiler.err.invalid.hex.number=十六进制数字必须包含至少一位十六进制数

compiler.err.invalid.meth.decl.ret.type.req=方法声明无效; 需要返回类型

compiler.err.varargs.and.old.array.syntax=variable-arity 参数中不允许使用传统数组记号

compiler.err.varargs.and.receiver =接收方参数不允许使用 varargs 记号

compiler.err.varargs.must.be.last =varargs 参数必须是最后一个参数

compiler.err.array.and.receiver =接收方参数不允许使用传统数组记号

compiler.err.wrong.receiver =错误的接收方参数名

compiler.err.variable.not.allowed=此处不允许使用变量声明

# 0: name
compiler.err.label.already.in.use=标签{0}已使用

compiler.err.local.enum=枚举类不能为本地类

compiler.err.cannot.create.array.with.type.arguments=无法创建具有类型变量的数组

compiler.err.cannot.create.array.with.diamond=无法创建具有 ''<>'' 的数组

compiler.err.invalid.module.directive=预期为模块指令关键字或 ''}''

#
# limits.  We don't give the limits in the diagnostic because we expect
# them to change, yet we want to use the same diagnostic.  These are all
# detected during code generation.
#
compiler.err.limit.code=代码过长

compiler.err.limit.code.too.large.for.try.stmt=try 语句的代码过长

compiler.err.limit.dimensions=数组类型维过多

compiler.err.limit.locals=本地变量过多

compiler.err.limit.parameters=参数过多

compiler.err.limit.pool=常量过多

compiler.err.limit.pool.in.class=类{0}中的常量过多

compiler.err.limit.stack=代码需要过多堆栈

compiler.err.limit.string=常量字符串过长

# 0: symbol
compiler.err.annotation.array.too.large="{0}" 中的批注数组元素太大

# 0: string
compiler.err.limit.string.overflow=对于常量池来说, 字符串 "{0}..." 的 UTF8 表示过长

compiler.err.malformed.fp.lit=浮点文字的格式错误

compiler.err.method.does.not.override.superclass=方法不会覆盖或实现超类型的方法

compiler.err.static.methods.cannot.be.annotated.with.override=不能使用 @Override 对静态方法进行批注

compiler.err.missing.meth.body.or.decl.abstract=缺少方法主体, 或声明抽象

compiler.err.missing.ret.stmt=缺少返回语句

# 0: type
compiler.misc.missing.ret.val=缺少返回值

compiler.misc.unexpected.ret.val=意外的返回值

# 0: set of flag
compiler.err.mod.not.allowed.here=此处不允许使用修饰符{0}

compiler.err.intf.not.allowed.here=此处不允许使用接口

# 0: symbol, 1: symbol
compiler.err.name.clash.same.erasure=名称冲突: {0}和{1}具有相同疑符

# 0: name, 1: list of type, 2: symbol, 3: name, 4: list of type, 5: symbol
compiler.err.name.clash.same.erasure.no.override=名称冲突: {2} 中的 {0}({1}) 和 {5} 中的 {3}({4}) 具有相同疑符, 但两者均不覆盖对方

# 0: string, 1: name, 2: name, 3: list of type, 4: symbol, 5: name, 6: list of type, 7: symbol
compiler.err.name.clash.same.erasure.no.override.1=名称冲突: {0} {1} 的两种方法具有相同的疑符, 但两者均不覆盖对方\n第一种方法: {4} 中的 {2}({3})\n第二种方法: {7} 中的 {5}({6})

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.err.name.clash.same.erasure.no.hide=名称冲突: {1} 中的 {0} 和 {3} 中的 {2} 具有相同疑符, 但两者均不隐藏对方

compiler.err.name.reserved.for.internal.use={0}为内部使用保留

compiler.err.native.meth.cant.have.body=本机方法不能带有主体


# 0: message segment
compiler.misc.incompatible.type.in.conditional=条件表达式中的类型错误\n{0}

compiler.misc.conditional.target.cant.be.void=条件表达式的目标类型不能为空

compiler.misc.switch.expression.target.cant.be.void=switch 表达式的目标类型不能为空

# 0: message segment
compiler.misc.incompatible.type.in.switch.expression=switch 表达式中的类型错误\n{0}

# 0: message segment
compiler.misc.incompatible.ret.type.in.lambda=lambda 表达式中的返回类型错误\n{0}

compiler.misc.stat.expr.expected=lambda 主体与 void 函数接口不兼容\n(请考虑使用块 lambda 主体, 或者改为使用语句表达式)

# 0: message segment
compiler.misc.incompatible.ret.type.in.mref=方法引用中的返回类型错误\n{0}

compiler.err.lambda.body.neither.value.nor.void.compatible=lambda 主体不是值, 也不与 void 兼容

# 0: list of type
compiler.err.incompatible.thrown.types.in.mref=函数表达式中抛出的类型 {0} 不兼容

compiler.misc.incompatible.arg.types.in.lambda=lambda 表达式中的参数类型不兼容

compiler.misc.incompatible.arg.types.in.mref=方法引用中的参数类型不兼容

compiler.err.new.not.allowed.in.annotation=批注中不允许使用 ''new''

# 0: name, 1: type
compiler.err.no.annotation.member={1}中没有批注成员{0}

# 0: symbol
compiler.err.no.encl.instance.of.type.in.scope=作用域中没有类型为{0}的封闭实例

compiler.err.no.intf.expected.here=此处不需要接口

compiler.err.no.match.entry={0}在{1}的条目中没有匹配项; 需要{2}

# 0: type
compiler.err.not.annotation.type={0} 不是批注接口

# 0: symbol, 1: symbol, 2: message segment
compiler.err.not.def.access.package.cant.access={0} 不可见\n({2})

# 0: symbol, 1: symbol, 2: message segment
compiler.misc.not.def.access.package.cant.access={0} 不可见\n({2})

# 0: symbol, 1: message segment
compiler.err.package.not.visible=程序包 {0} 不可见\n({1})

# 0: symbol, 1: message segment
compiler.misc.package.not.visible=程序包 {0} 不可见\n({1})

# {0} - current module
# {1} - package in which the invisible class is declared
# {2} - module in which {1} is declared
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.does.not.read=程序包 {1} 已在模块 {2} 中声明, 但模块 {0} 未读取它

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.from.unnamed=程序包 {0} 已在模块 {1} 中声明, 但该模块不在模块图中

# {0} - package in which the invisible class is declared
# {1} - current module
# 0: symbol, 1: symbol
compiler.misc.not.def.access.does.not.read.unnamed=程序包 {0} 已在未命名模块中声明，但模块 {1} 未读取它

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported=程序包 {0} 已在模块 {1} 中声明, 但该模块未导出它

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.from.unnamed=程序包 {0} 已在模块 {1} 中声明, 但该模块未导出它

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# {2} - current module
# 0: symbol, 1: symbol, 2: symbol
compiler.misc.not.def.access.not.exported.to.module=程序包 {0} 已在模块 {1} 中声明, 但该模块未将它导出到模块 {2}

# {0} - package in which the invisible class is declared
# {1} - module in which {0} is declared
# 0: symbol, 1: symbol
compiler.misc.not.def.access.not.exported.to.module.from.unnamed=程序包 {0} 已在模块 {1} 中声明, 但该模块未将它导出到未命名模块

# 0: symbol, 1: symbol
compiler.err.not.def.access.class.intf.cant.access={1}.{0} 是在不可访问的类或接口中定义的

# 0: symbol, 1: symbol
compiler.misc.not.def.access.class.intf.cant.access={1}.{0} 是在不可访问的类或接口中定义的

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.err.not.def.access.class.intf.cant.access.reason=程序包 {2} 中的 {1}.{0} 不可访问\n({3})

# 0: symbol, 1: symbol, 2: symbol, 3: message segment
compiler.misc.not.def.access.class.intf.cant.access.reason=程序包 {2} 中的 {1}.{0} 不可访问\n({3})

# 0: symbol, 1: symbol
compiler.err.not.def.public.cant.access={0}在{1}中不是公共的; 无法从外部程序包中对其进行访问

# 0: symbol, 1: symbol
compiler.err.not.def.public={0} 在 {1} 中不是公共的

# 0: symbol, 1: symbol
compiler.misc.not.def.public.cant.access={0}在{1}中不是公共的; 无法从外部程序包中对其进行访问

# 0: name
compiler.err.not.loop.label=不是 loop 标签: {0}

compiler.err.not.stmt=不是语句

# 0: symbol
compiler.err.not.encl.class=不是封闭类: {0}

# 0: name, 1: type
compiler.err.operator.cant.be.applied=一元运算符 ''{0}'' 的操作数类型{1}错误

# 0: name, 1: type, 2: type
compiler.err.operator.cant.be.applied.1=二元运算符 ''{0}'' 的操作数类型错误\n第一个类型:  {1}\n第二个类型: {2}

compiler.err.pkg.annotations.sb.in.package-info.java=程序包批注应在文件 package-info.java 中

compiler.err.no.pkg.in.module-info.java=文件 module-info.java 中不允许使用程序包声明

# 0: symbol
compiler.err.pkg.clashes.with.class.of.same.name=程序包{0}与带有相同名称的类冲突

compiler.err.warnings.and.werror=发现警告, 但指定了 -Werror

# Errors related to annotation processing

# 0: symbol, 1: message segment, 2: string (stack-trace)
compiler.err.proc.cant.access=无法访问{0}\n{1}\n有关详细信息, 请参阅以下堆栈跟踪。\n{2}

# 0: symbol, 1: message segment
compiler.err.proc.cant.access.1=无法访问{0}\n{1}

# 0: string
compiler.err.proc.cant.find.class=找不到 ''{0}'' 的类文件。

# 0: string
compiler.err.proc.cant.load.class=由于 ''{0}''，无法加载处理器类文件。

# Print a client-generated error message; assumed to be localized, no translation required
# 0: string
compiler.err.proc.messager={0}

# 0: string
compiler.misc.exception.message={0}

compiler.misc.user.selected.completion.failure=按类名列出的用户选择输入提示失败

# 0: collection of string
compiler.err.proc.no.explicit.annotation.processing.requested=仅当显式请求批注处理时才接受类名称 ''{0}''

# 0: string, 1: string
compiler.err.proc.processor.bad.option.name=处理程序 ''{1}'' 提供的选项名称 ''{0}'' 错误

# 0: string
compiler.err.proc.processor.cant.instantiate=无法实例化处理程序 ''{0}'' 的实例

# 0: string
compiler.err.proc.processor.not.found=找不到批注处理程序 ''{0}''

# 0: string
compiler.err.proc.processor.wrong.type=批注处理程序 ''{0}'' 未实现 javax.annotation.processing.Processor

compiler.err.proc.service.problem=创建服务加载器以加载处理程序时出错。

# 0: string
compiler.err.proc.bad.config.file=服务配置文件不正确, 或构造处理程序对象{0}时抛出异常错误

compiler.err.proc.cant.create.loader=无法为批注处理程序{0}创建类加载器

# 0: symbol
compiler.err.qualified.new.of.static.class=限定的新静态类

compiler.err.recursive.ctor.invocation=递归构造器调用

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.err.ref.ambiguous=对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配

# 0: name, 1: symbol kind, 2: symbol, 3: symbol, 4: symbol kind, 5: symbol, 6: symbol
compiler.misc.ref.ambiguous=对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配

compiler.err.repeated.annotation.target=批注目标重复

compiler.err.repeated.interface=接口重复

compiler.err.repeated.modifier=修饰符重复

# 0: symbol, 1: set of modifier, 2: symbol
compiler.err.report.access={0} 在 {2} 中是 {1} 访问控制

# 0: symbol, 1: set of modifier, 2: symbol
compiler.misc.report.access={0} 在 {2} 中是 {1} 访问控制

compiler.err.ret.outside.meth=返回外部方法

compiler.err.signature.doesnt.match.supertype=签名与{0}不匹配; 不兼容的超类型

compiler.err.signature.doesnt.match.intf=签名与{0}不匹配; 不兼容的接口

# 0: symbol, 1: symbol, 2: symbol
compiler.err.does.not.override.abstract={0}不是抽象的, 并且未覆盖{2}中的抽象方法{1}

# 0: file object
compiler.err.source.cant.overwrite.input.file=写入源时出错; 无法覆盖输入文件{0}

# 0: symbol
compiler.err.stack.sim.error=内部错误: {0}中的堆栈 sim 错误

compiler.err.static.imp.only.classes.and.interfaces=仅从类和接口静态导入

compiler.err.string.const.req=需要常量字符串表达式

compiler.err.pattern.expected=需要类型模式

# 0: symbol, 1: fragment
compiler.err.cannot.generate.class=生成类 {0} 时出错\n({1})

# 0: symbol, 1: symbol
compiler.misc.synthetic.name.conflict=符号{0}与{1}中的 compiler-synthesized 符号冲突

# 0: symbol, 1: type
compiler.misc.illegal.signature=类型 {1} 的签名属性非法

compiler.err.throws.not.allowed.in.intf.annotation=@interface 成员中不允许使用 throws 子句

compiler.err.try.without.catch.finally.or.resource.decls=''try'' 不带有 ''catch'', ''finally'' 或资源声明

# 0: symbol
compiler.err.type.doesnt.take.params=类型{0}不带有参数

compiler.err.type.var.cant.be.deref=无法从类型变量中进行选择

compiler.err.type.var.may.not.be.followed.by.other.bounds=类型变量后面不能带有其他限制范围

compiler.err.type.var.more.than.once=类型变量{0}在{1}的结果类型中多次出现; 必须对其进行实例化

compiler.err.type.var.more.than.once.in.result=类型变量{0}在{1}的类型中多次出现; 必须对其进行实例化

# 0: type, 1: type, 2: fragment
compiler.err.types.incompatible=类型 {0} 和 {1} 不兼容；\n{2}

# 0: name, 1: list of type
compiler.misc.incompatible.diff.ret=两者都定义了 {0}({1})，但返回类型不相关

# 0: type, 1: name, 2: list of type
compiler.err.incompatible.diff.ret.same.type=类型 {0} 多次定义了 {1}({2})，但返回类型不相关

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.unrelated.defaults={0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的不相关默认值

# 0: kind name, 1: type, 2: name, 3: list of type, 4: symbol, 5: symbol
compiler.misc.incompatible.abstract.default={0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的抽象和默认值

# 0: name, 1: kind name, 2: symbol
compiler.err.default.overrides.object.member={1} {2} 中的默认方法{0}覆盖了 java.lang.Object 的成员

# 0: type
compiler.err.illegal.static.intf.meth.call=静态接口方法调用非法\n应将接收方表达式替换为类型限定符 ''{0}''

# 0: symbol or type, 1: message segment
compiler.err.illegal.default.super.call=默认超级调用中的类型限定符{0}错误\n{1}

# 0: symbol, 1: type
compiler.misc.overridden.default=覆盖了{1}中的方法 {0}

# 0: symbol, 1: type or symbol
compiler.misc.redundant.supertype=冗余接口 {0} 已由 {1} 扩展

compiler.err.unclosed.char.lit=未结束的字符文字

compiler.err.unclosed.comment=未结束的注释

compiler.err.unclosed.str.lit=未结束的字符串文字

compiler.err.unclosed.text.block=文本块未闭合

# 0: string
compiler.err.unsupported.encoding=不支持的编码: {0}

compiler.err.io.exception=读取源文件时出错: {0}

# 0: name
compiler.err.undef.label=未定义的标签: {0}

# 0: name
compiler.err.illegal.ref.to.restricted.type=对受限制类型 ''{0}'' 的引用非法

# 0: name
compiler.warn.illegal.ref.to.restricted.type=对受限制类型 ''{0}'' 的引用非法

# 0: name, 1: source
compiler.err.restricted.type.not.allowed=此处不允许使用 ''{0}''\n从发行版 {1} 开始，''{0}'' 是受限类型名称，不能用于类型声明

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed=从发行版 {1} 开始，''{0}'' 是受限类型名称，不能用于类型声明，也不能用作数组的元素类型

# 0: name, 1: source
compiler.warn.restricted.type.not.allowed.preview=''{0}'' 在未来发行版中可能会成为受限类型名称，可能无法用于类型声明，也不能用作数组的元素类型

# 0: name (variable), 1: message segment
compiler.err.cant.infer.local.var.type=无法推断本地变量 {0} 的类型\n({1})

# 0: name
compiler.err.restricted.type.not.allowed.here=此处不允许使用 ''{0}''

# 0: name
compiler.err.restricted.type.not.allowed.array=''{0}'' 不允许用作数组的元素类型

# 0: name
compiler.err.restricted.type.not.allowed.compound=''{0}'' 不允许在复合声明中使用

# 0: fragment
compiler.err.invalid.lambda.parameter.declaration=无效的 lambda 参数声明\n({0})

compiler.misc.implicit.and.explicit.not.allowed=不能将隐式类型和显式类型的参数混合使用

compiler.misc.var.and.explicit.not.allowed=不能将 ''var'' 和显式类型的参数混合使用

compiler.misc.var.and.implicit.not.allowed=不能将 ''var'' 和隐式类型的参数混合使用

compiler.misc.local.cant.infer.null=变量初始化程序为 ''null''

compiler.misc.local.cant.infer.void=变量初始化程序为 ''void''

compiler.misc.local.missing.init=无法在不带初始化程序的变量上使用 ''var''

compiler.misc.local.lambda.missing.target=lambda 表达式需要显式目标类型

compiler.misc.local.mref.missing.target=方法引用需要显式目标类型

compiler.misc.local.array.missing.target=数组初始化程序需要显式目标类型

compiler.misc.local.self.ref=无法在自引用变量上使用 ''var''

# 0: message segment, 1: unused
compiler.err.cant.apply.diamond=无法推断{0}的类型参数

# 0: message segment or type, 1: message segment
compiler.err.cant.apply.diamond.1=无法推断{0}的类型参数\n原因: {1}

# 0: message segment or type, 1: message segment
compiler.misc.cant.apply.diamond.1=无法推断{0}的类型参数\n原因: {1}

compiler.err.unreachable.stmt=无法访问的语句

compiler.err.not.exhaustive=switch 表达式不包含所有可能的输入值

compiler.err.not.exhaustive.statement=并非所有可能的输入值都包含在 switch 语句中

compiler.err.initializer.must.be.able.to.complete.normally=初始化程序必须能够正常完成

compiler.err.initializer.not.allowed=接口中不允许有初始化程序

# 0: type
compiler.err.unreported.exception.need.to.catch.or.throw=未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出

# 0: type
compiler.err.unreported.exception.default.constructor=默认构造器中未报告的异常错误{0}

# 0: type, 1: name
compiler.err.unreported.exception.implicit.close=未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出\n对资源变量 ''{1}'' 隐式调用 close() 时抛出了异常错误

compiler.err.void.not.allowed.here=此处不允许使用 ''空'' 类型

# 0: string
compiler.err.wrong.number.type.args=类型变量数目错误; 需要{0}

# 0: symbol
compiler.err.var.might.already.be.assigned=可能已分配变量{0}

# 0: symbol
compiler.err.var.might.not.have.been.initialized=可能尚未初始化变量{0}

# 0: symbol
compiler.err.var.not.initialized.in.default.constructor=变量 {0} 未在默认构造器中初始化

# 0: symbol
compiler.err.var.might.be.assigned.in.loop=可能在 loop 中分配了变量{0}

# 0: symbol, 1: message segment
compiler.err.varargs.invalid.trustme.anno={0} 批注无效。{1}

# 0: type
compiler.misc.varargs.trustme.on.reifiable.varargs=Varargs 元素类型{0}可具体化。

# 0: type, 1: type
compiler.err.instanceof.reifiable.not.safe={0} 无法安全地转换为 {1}

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.meth=方法 {0} 不是 varargs 方法。

# 0: symbol
compiler.misc.varargs.trustme.on.non.varargs.accessor=存取方法 {0} 不是 varargs 方法。

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs=实例方法 {0} 既不是最终的, 也不是私有的。

# 0: symbol
compiler.misc.varargs.trustme.on.virtual.varargs.final.only=实例方法 {0} 不是最终的。

# 0: type, 1: symbol kind, 2: symbol
compiler.misc.inaccessible.varargs.type=形式 varargs 元素类型{0}无法从 {1} {2} 进行访问

# In the following string, {1} will always be the detail message from
# java.io.IOException.
# 0: symbol, 1: string
compiler.err.class.cant.write=写入{0}时出错: {1}

# In the following string, {0} is the name of the class in the Java source.
# It really should be used two times..
# 0: kind name, 1: name
compiler.err.class.public.should.be.in.file={0} {1} 是公共的, 应在名为 {1}.java 的文件中声明

## All errors which do not refer to a particular line in the source code are
## preceded by this string.
compiler.err.error=错误:\u0020

# The following error messages do not refer to a line in the source code.
compiler.err.cant.read.file=无法读取: {0}

# 0: string
compiler.err.plugin.not.found=找不到插件: {0}

# 0: path
# lint: path
compiler.warn.locn.unknown.file.on.module.path=模块路径中的未知文件: {0}


# 0: path
compiler.err.locn.bad.module-info=读取 {0} 中的 module-info.class 时出现问题

# 0: path
compiler.err.locn.cant.read.directory=无法读取目录 {0}

# 0: path
compiler.err.locn.cant.read.file=无法读取文件 {0}

# 0: path
compiler.err.locn.cant.get.module.name.for.jar=无法确定 {0} 的模块名称

# 0: path
compiler.err.multi-module.outdir.cannot.be.exploded.module=在多模块模式下, 输出目录不能是展开的模块: {0}

# 0: path
# lint: path
compiler.warn.outdir.is.in.exploded.module=输出目录位于展开的模块中: {0}

# 0: file object
compiler.err.locn.module-info.not.allowed.on.patch.path=在补丁程序路径中不允许 module-info.class: {0}

# 0: string
compiler.err.locn.invalid.arg.for.xpatch=--patch-module 选项的参数无效: {0}

compiler.err.file.sb.on.source.or.patch.path.for.module=文件应在源路径或模块的补丁程序路径中

compiler.err.no.java.lang=在平台类中找不到程序包 java.lang

compiler.err.statement.not.expected=语句不应在方法和初始化程序外部

compiler.err.class.method.or.field.expected=需要类、接口、批注类型、枚举、记录、方法或字段

#####

# Fatal Errors

# 0: name
compiler.misc.fatal.err.cant.locate.meth=致命错误: 找不到方法{0}

# 0: name
compiler.misc.fatal.err.cant.locate.field=致命错误: 找不到字段{0}

# 0: type
compiler.misc.fatal.err.cant.locate.ctor=致命错误: 找不到{0}的构造器

compiler.misc.fatal.err.cant.close=致命错误: 无法关闭编译器资源

#####

##
## miscellaneous strings
##

compiler.misc.diamond.anonymous.methods.implicitly.override=(由于 <>, 匿名类中声明的每个非私有方法必须覆盖或实现超类型中的方法)

compiler.misc.source.unavailable=(源不可用)

# 0: string, 1: string, 2: boolean
compiler.misc.x.print.processor.info=处理程序{0}与{1}匹配并返回{2}。

# 0: number, 1: string, 2: set of symbol, 3: boolean
compiler.misc.x.print.rounds=循环 {0}:\n\t输入文件: {1}\n\t批注: {2}\n\t最后一个循环: {3}

# 0: file name
compiler.warn.file.from.future=文件 {0} 的修改日期是未来的日期

# 0: path
# lint: output-file-clash
compiler.warn.output.file.clash=多次写入输出文件：{0}

#####

## The following string will appear before all messages keyed as:
## "compiler.note".

compiler.note.compressed.diags=某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出

# 0: boolean, 1: symbol
compiler.note.lambda.stat=转换 lambda 表达式\n替代 metafactory = {0}\n合成方法 = {1}

# 0: boolean, 1: unused
compiler.note.mref.stat=转换方法引用\n替代 metafactory = {0}\n
# 0: boolean, 1: symbol
compiler.note.mref.stat.1=转换方法引用\n替代 metafactory = {0}\nbridge 方法 = {1}

compiler.note.note=注:\u0020

# 0: file name
compiler.note.deprecated.filename={0}使用或覆盖了已过时的 API。

compiler.note.deprecated.plural=某些输入文件使用或覆盖了已过时的 API。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.deprecated.recompile=有关详细信息, 请使用 -Xlint:deprecation 重新编译。

# 0: file name
compiler.note.deprecated.filename.additional={0}还使用或覆盖了已过时的 API。

compiler.note.deprecated.plural.additional=某些输入文件还使用或覆盖了已过时的 API。

# 0: file name
compiler.note.removal.filename={0} 使用或覆盖了标记为待删除的已过时 API。

compiler.note.removal.plural=某些输入文件使用或覆盖了标记为待删除的已过时 API。

# The following string may appear after one of the above removal messages.
compiler.note.removal.recompile=有关详细信息, 请使用 -Xlint:removal 重新编译。

# 0: file name
compiler.note.removal.filename.additional={0} 额外使用或覆盖了标记为待删除的已过时 API。

compiler.note.removal.plural.additional=某些输入文件额外使用或覆盖了标记为待删除的已过时 API。

# 0: file name
compiler.note.unchecked.filename={0}使用了未经检查或不安全的操作。

compiler.note.unchecked.plural=某些输入文件使用了未经检查或不安全的操作。

# The following string may appear after one of the above unchecked messages.
compiler.note.unchecked.recompile=有关详细信息, 请使用 -Xlint:unchecked 重新编译。

# 0: file name
compiler.note.unchecked.filename.additional={0}还有未经检查或不安全的操作。

compiler.note.unchecked.plural.additional=某些输入文件还使用了未经检查或不安全的操作。

# 0: file name, 1: source
compiler.note.preview.filename={0} 使用 Java SE {1} 的预览功能。

# 0: source
compiler.note.preview.plural=某些输入文件使用 Java SE {0} 的预览功能。

# The following string may appear after one of the above deprecation
# messages.
compiler.note.preview.recompile=有关详细信息，请使用 -Xlint:preview 重新编译。

# 0: file name, 1: source
compiler.note.preview.filename.additional={0} 还使用 Java SE {1} 的预览功能。

# 0: source
compiler.note.preview.plural.additional=某些输入文件还使用 Java SE {0} 的预览功能。

# Notes related to annotation processing

# Print a client-generated note; assumed to be localized, no translation required
# 0: string
compiler.note.proc.messager={0}

# 0: string, 1: string, 2: string
compiler.note.multiple.elements=通过 javax.lang.model.util.Elements.{0} 在模块 ''{2}'' 中找到了多个名为 ''{1}'' 的元素。

compiler.note.implicit.annotation.processing=由于在类路径中发现了一个或多个处理程序，因此启用了\n批注处理。未来发行版的 javac 可能会禁用批注处理，\n除非至少按名称指定了一个处理程序 (-processor)，\n或指定了搜索路径 (--processor-path, --processor-module-path)，\n或显式启用了批注处理 (-proc:only, -proc:full)。\n可使用 -Xlint:-options 隐藏此消息。\n可使用 -proc:none 禁用批注处理。

#####

# 0: number
compiler.misc.count.error={0} 个错误

# 0: number
compiler.misc.count.error.plural={0} 个错误

# 0: number, 1: number
compiler.misc.count.error.recompile=仅显示前 {0} 个错误（共 {1} 个）；若要查看更多错误，请使用 -Xmaxerrs

# 0: number, 1: number
compiler.misc.count.warn.recompile=仅显示前 {0} 个警告（共 {1} 个）；若要查看更多错误，请使用 -Xmaxwarns

# 0: number
compiler.misc.count.warn={0} 个警告

# 0: number
compiler.misc.count.warn.plural={0} 个警告

compiler.misc.version.not.available=(版本信息不可用)

## extra output when using -verbose (JavaCompiler)

# 0: symbol
compiler.misc.verbose.checking.attribution=[正在检查{0}]

# 0: string
compiler.misc.verbose.parsing.done=[语法分析已完成, 用时 {0} 毫秒]

# 0: file name
compiler.misc.verbose.parsing.started=[语法分析开始时间 {0}]

# 0: string
compiler.misc.verbose.total=[共 {0} 毫秒]

# 0: file name
compiler.misc.verbose.wrote.file=[已写入{0}]

## extra output when using -verbose (code/ClassReader)
# 0: string
compiler.misc.verbose.loading=[正在加载{0}]

# 0: string
compiler.misc.verbose.sourcepath=[源文件的搜索路径: {0}]

# 0: string
compiler.misc.verbose.classpath=[类文件的搜索路径: {0}]

## extra output when using -prompt (util/Log)
compiler.misc.resume.abort=继续(R), 放弃(A)>

#####

##
## warnings
##

## All warning messages are preceded by the following string.
compiler.warn.warning=警告:\u0020

## Warning messages may also include the following prefix to identify a
## lint option
# 0: option name
compiler.warn.lintOption=[{0}]\u0020

# 0: symbol
# lint: serial
compiler.warn.constant.SVUID=serialVersionUID 在类{0}中必须是常量

# lint: dangling-doc-comments
compiler.warn.dangling.doc.comment=文档注释未附加到任何声明

# 0: path
# lint: path
compiler.warn.dir.path.element.not.found=错误的路径元素 "{0}": 没有这种目录

# 0: file name
# lint: path
compiler.warn.dir.path.element.not.directory=错误的路径元素 "{0}": 不是目录

# 0: symbol, 1: symbol, 2: symbol
# lint: missing-explicit-ctor
compiler.warn.missing-explicit-ctor=导出的程序包 {1} 中的类 {0} 未声明显式构造器，因此将向模块 {2} 的客户机公开默认构造器

# lint: strictfp
compiler.warn.strictfp=从发行版 17 开始，所有浮点表达式都经过严格计算，不需要 ''strictfp''

# lint: finally
compiler.warn.finally.cannot.complete=finally 子句无法正常完成

# 0: name
# lint: module
compiler.warn.poor.choice.for.module.name=模块名称组成部分 {0} 应避免以数字结尾

# 0: string
# lint: incubating
compiler.warn.incubating.modules=使用 incubating 模块: {0}

# 0: symbol, 1: symbol
# lint: deprecation
# flags: aggregate
compiler.warn.has.been.deprecated={1}中的{0}已过时

# 0: symbol, 1: symbol
# lint: removal
# flags: aggregate
compiler.warn.has.been.deprecated.for.removal={1} 中的 {0} 已过时, 且标记为待删除

# 0: symbol
# lint: preview
# flags: aggregate
compiler.warn.is.preview={0} 是预览 API，可能会在未来发行版中删除。

# 0: symbol
compiler.err.is.preview={0} 是预览 API，默认情况下处于禁用状态。\n（请使用 --enable-preview 以启用预览 API）

# 0: symbol
# lint: preview
# flags: aggregate
compiler.warn.is.preview.reflective={0} 是反射预览 API，可能会在未来发行版中删除。

# 0: symbol, 1: symbol
# lint: restricted
compiler.warn.restricted.method={0}.{1} 是受限制的方法。\n（受限制的方法不安全，如果使用不当，可能会导致 Java 运行时崩溃或内存损坏）

# 0: symbol
# lint: deprecation
# flags: aggregate
compiler.warn.has.been.deprecated.module=模块 {0} 已过时

# 0: symbol
# lint: removal
# flags: aggregate
compiler.warn.has.been.deprecated.for.removal.module=模块 {0} 已过时, 且标记为待删除

# 0: symbol
# flags: strict
compiler.warn.sun.proprietary={0}是内部专用 API, 可能会在未来发行版中删除

compiler.warn.illegal.char.for.encoding=编码{0}的不可映射字符

# 0: symbol
# lint: serial
compiler.warn.improper.SVUID=必须在类{0}中将 serialVersionUID 声明为 static final

# lint: serial
compiler.warn.improper.SPF=serialPersistentFields 必须声明为 private static final 才能生效

# lint: serial
compiler.warn.SPF.null.init=serialPersistentFields 如果初始化为空值，则无效。\n请初始化为空数组以指示没有字段


# 0: type, 1: type
compiler.warn.inexact.non-varargs.call=最后一个参数使用了不准确的变量类型的 varargs 方法的非 varargs 调用; \n对于 varargs 调用, 应使用 {0}\n对于非 varargs 调用, 应使用 {1}, 这样也可以抑制此警告

# 0: list of type
compiler.warn.unreachable.catch=catch 子句无法访问\n已捕获到抛出的类型{0}

# 0: list of type
compiler.warn.unreachable.catch.1=catch 子句无法访问\n已捕获到抛出的类型{0}

# 0: symbol
# lint: serial
compiler.warn.long.SVUID=serialVersionUID 在类{0}中必须是 long 类型

# lint: serial
compiler.warn.OSF.array.SPF=serialPersistentFields 的类型必须为 java.io.ObjectStreamField[] 才能生效

# 0: symbol
# lint: serial
compiler.warn.missing.SVUID=可序列化类{0}没有 serialVersionUID 的定义

# 0: name
# lint: serial
compiler.warn.serializable.missing.access.no.arg.ctor=无法访问第一个不可序列化超类 {0} 中的无参数构造器

# 0: name
# lint: serial
compiler.warn.serial.method.not.private=与序列化相关的方法 {0} 未声明为 private

# 0: name
# lint: serial
compiler.warn.serial.concrete.instance.method=与序列化相关的方法 {0} 必须是具体的实例方法才能生效，既不能是抽象方法也不能是静态方法

# 0: name
# lint: serial
compiler.warn.serial.method.static=与序列化相关的方法 {0} 声明为 static；必须改为实例方法才能有效

# 0: name
# lint: serial
compiler.warn.serial.method.no.args=与序列化相关的方法 {0} 必须没有参数才能生效

# 0: name, 1: number
# lint: serial
compiler.warn.serial.method.one.arg=与序列化相关的方法 {0} 必须只有一个参数（而非 {1} 个参数）才能生效

# 0: name, 1: type, 2: type
# lint: serial
compiler.warn.serial.method.parameter.type=与序列化相关的方法 {0} 的唯一参数的类型必须为 {1}（而非 {2}）才能生效

# 0: name, 1: type, 2: type
# lint: serial
compiler.warn.serial.method.unexpected.return.type=与序列化相关的方法 {0} 是用返回类型 {1}（而不是预期类型 {2}）声明的。\n如声明的那样，该方法对序列化无效

# 0: name, 1: type
# lint: serial
compiler.warn.serial.method.unexpected.exception=与序列化相关的方法 {0} 声明为抛出意外类型 {1}

# lint: serial
compiler.warn.ineffectual.serial.field.interface=serialPersistentFields 在接口中无效

# 0: string
# lint: serial
compiler.warn.ineffectual.serial.field.enum=与序列化相关的字段 {0} 在枚举类中无效

# 0: string
# lint: serial
compiler.warn.ineffectual.serial.method.enum=与序列化相关的方法 {0} 在枚举类中无效

# 0: string
# lint: serial
compiler.warn.ineffectual.extern.method.enum=与外部化相关的方法 {0} 在枚举类中无效

# lint: serial
compiler.warn.ineffectual.serial.field.record=serialPersistentFields 在记录类中无效

# 0: string
# lint: serial
compiler.warn.ineffectual.serial.method.record=与序列化相关的方法 {0} 在记录类中无效

# 0: string
# lint: serial
compiler.warn.ineffectual.externalizable.method.record=与外部化相关的方法 {0} 在记录类中无效

# 0: name
# lint: serial
compiler.warn.ineffectual.serial.method.externalizable=与序列化相关的方法 {0} 在可外部化的类中无效

# lint: serial
compiler.warn.ineffectual.serial.field.externalizable=serialPersistentFields 在可外部化的类中无效

# lint: serial
compiler.warn.externalizable.missing.public.no.arg.ctor=可外部化的类需要一个公共的无参数构造器

# lint: serial
compiler.warn.non.serializable.instance.field=可序列化类的非瞬时实例字段是用不可序列化的类型声明的

# 0: type
# lint: serial
compiler.warn.non.serializable.instance.field.array=可序列化类的非瞬时实例字段是用具有不可序列化基本组件类型 {0} 的数组声明的

# lint: serial
compiler.warn.non.private.method.weaker.access=在接口中声明为 non-private 的序列化相关方法将阻止\n实现接口的类将方法声明为 private

# lint: serial
compiler.warn.default.ineffective=实现类的序列化不会运行接口中与序列化相关的默认方法

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
# lint: overloads
compiler.warn.potentially.ambiguous.overload={1} 中的 {0} 可能与 {3} 中的 {2} 混淆

# 0: message segment
# lint: overrides
compiler.warn.override.varargs.missing={0}; 被覆盖的方法没有 ''...''

# 0: message segment
# lint: overrides
compiler.warn.override.varargs.extra={0}; 覆盖的方法缺少 ''...''

# 0: message segment
compiler.warn.override.bridge={0}; 被覆盖的方法为 bridge 方法

# 0: symbol
compiler.warn.pkg-info.already.seen=已找到程序包{0}的 package-info.java 文件

# 0: path
# lint: path
compiler.warn.path.element.not.found=错误的路径元素 "{0}": 没有这种文件或目录

# lint: fallthrough
compiler.warn.possible.fall-through.into.case=可能无法实现 case

# 0: type
# lint: cast
compiler.warn.redundant.cast=出现冗余的到{0}的转换

# 0: number
compiler.warn.position.overflow=行 {0} 处的位置编码溢出

# 0: file name, 1: number, 2: number
compiler.warn.big.major.version={0}: 主版本 {1} 比 {2} 新, 此编译器支持最新的主版本。\n建议升级此编译器。

# 0: file name, 1: fragment
compiler.warn.invalid.utf8.in.classfile={0}：类文件包含无效 UTF-8：{1}

# 0: kind name, 1: symbol
# lint: static
compiler.warn.static.not.qualified.by.type=static {0}应由类型名称{1}而不是表达式限定

# 0: kind name
# lint: static
compiler.warn.static.not.qualified.by.type2=static {0} 不应用作匿名类的成员

# 0: string, 1: fragment
# lint: options
compiler.warn.source.no.bootclasspath=未与 -source {0} 一起设置引导类路径\n{1}

# 0: string, 1: fragment
# lint: options
compiler.warn.source.no.system.modules.path=未与 -source {0} 一起设置系统模块的位置\n{1}

# 0: string
compiler.misc.source.no.bootclasspath=不设置引导类路径可能会导致类文件无法在 JDK {0} 上运行\n建议使用 --release {0} 而不是 -source {0}，因为它会自动设置引导类路径

# 0: string
compiler.misc.source.no.system.modules.path=不设置系统模块的位置可能会导致类文件无法在 JDK {0} 上运行\n建议使用 --release {0} 而不是 -source {0}，因为它会自动设置系统模块的位置

# 0: string, 1: string
compiler.misc.source.no.bootclasspath.with.target=不设置引导类路径可能会导致类文件无法在 JDK 8 上运行\n建议使用 --release {0} 而不是 -source {0} -target {1}，因为它会自动设置引导类路径

# 0: string, 1: string
compiler.misc.source.no.system.modules.path.with.target=不设置系统模块的位置可能会导致类文件无法在 JDK {0} 上运行\n建议使用 --release {0} 而不是 -source {0} -target {1}，因为它会自动设置系统模块的位置

# 0: string
# lint: options
compiler.warn.option.obsolete.source=源值 {0} 已过时，将在未来发行版中删除

# 0: target
# lint: options
compiler.warn.option.obsolete.target=目标值 {0} 已过时，将在未来发行版中删除

# 0: string, 1: string
compiler.err.option.removed.source=不再支持源选项 {0}。请使用 {1} 或更高版本。

# 0: target, 1: target
compiler.err.option.removed.target=不再支持目标选项 {0}。请使用 {1} 或更高版本。

# lint: options
compiler.warn.option.obsolete.suppression=要隐藏有关已过时选项的警告, 请使用 -Xlint:-options。

# 0: name, 1: number, 2: number, 3: number, 4: number
# lint: classfile
compiler.warn.future.attr={1}.{2} 版类文件中引入的 {0} 属性在 {3}.{4} 版类文件中被忽略

# lint: requires-automatic
compiler.warn.requires.automatic=需要自动模块的指令

# lint: requires-transitive-automatic
compiler.warn.requires.transitive.automatic=需要自动模块的过渡指令

# Warnings related to annotation processing
# 0: string
compiler.warn.proc.package.does.not.exist=程序包{0}不存在

# 0: string
# lint: processing
compiler.warn.proc.file.reopening=尝试多次为 ''{0}'' 创建文件

# 0: string
# lint: processing
compiler.warn.proc.type.already.exists=类型 ''{0}'' 的文件已经存在于源路径或类路径中

# 0: string
# lint: processing
compiler.warn.proc.type.recreate=尝试多次创建类型 ''{0}'' 的文件

# 0: string
# lint: processing
compiler.warn.proc.illegal.file.name=无法创建带有非法名称 ''{0}'' 的文件。

# 0: string, 1: string
# lint: processing
compiler.warn.proc.suspicious.class.name=正在为名称以{1}结尾的类型创建文件: ''{0}''

# 0: string
compiler.warn.proc.file.create.last.round=将不对在最后一个循环中创建的类型为 ''{0}'' 的文件进行批注处理。

# 0: string, 1: string
# lint: processing
compiler.warn.proc.malformed.supported.string=处理程序 ''{1}'' 为支持的批注接口返回格式错误的字符串 ''{0}''

# 0: set of string
# lint: processing
compiler.warn.proc.annotations.without.processors=没有处理程序要使用以下任何批注: {0}

# 0: source version, 1: string, 2: string
compiler.warn.proc.processor.incompatible.source.version=来自批注处理程序 ''{1}'' 的受支持 source 版本 ''{0}'' 低于 -source ''{2}''

# 0: string, 1: string
# lint: processing
compiler.warn.proc.duplicate.option.name=批注处理程序 ''{1}'' 返回重复的支持的选项 ''{0}''

# 0: string, 1: string
# lint: processing
compiler.warn.proc.duplicate.supported.annotation=批注处理程序 ''{1}'' 返回重复的受支持批注接口 ''{0}''


# 0: string
# lint: processing
compiler.warn.proc.redundant.types.with.wildcard=批注处理程序 ''{0}'' 重复支持 ''*'' 和其他批注接口

compiler.warn.proc.proc-only.requested.no.procs=在未请求编译的情况下进行批注处理, 但找不到处理程序。

compiler.warn.proc.use.implicit=批注处理不适用于隐式编译的文件。\n使用 -implicit 指定用于隐式编译的策略。

compiler.warn.proc.use.proc.or.implicit=批注处理不适用于隐式编译的文件。\n使用 -proc:none 禁用批注处理或使用 -implicit 指定用于隐式编译的策略。

# Print a client-generated warning; assumed to be localized, no translation required
# 0: string
compiler.warn.proc.messager={0}

# 0: set of string
compiler.warn.proc.unclosed.type.files=类型 ''{0}'' 的文件未关闭; 将不针对这些类型进行批注处理

# 0: string
compiler.warn.proc.unmatched.processor.options=以下选项未被任何处理程序识别: ''{0}''

# lint: try
compiler.warn.try.explicit.close.call=在可自动结束的资源上显式调用 close()

# 0: symbol
# lint: try
compiler.warn.try.resource.not.referenced=不能在相应的 try 语句的正文中引用可自动结束的资源{0}

# 0: type
# lint: try
compiler.warn.try.resource.throws.interrupted.exc=可自动关闭的资源{0}包含的成员方法 close() 可能抛出 InterruptedException

# lint: unchecked
compiler.warn.unchecked.assign=未经检查的分配: 将{0}分配给{1}

# 0: symbol, 1: type
# lint: unchecked
# flags: aggregate
compiler.warn.unchecked.assign.to.var=对作为原始类型{1}的成员的变量{0}的分配未经过检查

# 0: symbol, 1: type
# lint: unchecked
# flags: aggregate
compiler.warn.unchecked.call.mbr.of.raw.type=对作为原始类型{1}的成员的{0}的调用未经过检查

# lint: unchecked
compiler.warn.unchecked.cast.to.type=向类型{0}的转换未经过检查

# 0: kind name, 1: name, 2: object, 3: object, 4: kind name, 5: symbol
# lint: unchecked
# flags: aggregate
compiler.warn.unchecked.meth.invocation.applied=方法调用未经过检查: 将{4} {5}中的{0} {1}应用到给定的类型\n需要: {2}\n找到:    {3}

# 0: type
# lint: unchecked
# flags: aggregate
compiler.warn.unchecked.generic.array.creation=对于类型为{0}的 varargs 参数, 泛型数组创建未经过检查

# 0: type
# lint: unchecked
# flags: aggregate
compiler.warn.unchecked.varargs.non.reifiable.type=参数化 vararg 类型{0}的堆可能已受污染

# 0: symbol
# lint: varargs
compiler.warn.varargs.unsafe.use.varargs.param=Varargs 方法可能导致来自不可具体化 varargs 参数 {0} 的堆污染

# lint: dep-ann
compiler.warn.missing.deprecated.annotation=未使用 @Deprecated 对已过时的项目进行批注

# 0: kind name
# lint: deprecation
compiler.warn.deprecated.annotation.has.no.effect=@Deprecated 批注对此 {0} 声明没有任何效果

# 0: string
# lint: path
compiler.warn.invalid.path=无效文件名: {0}

compiler.warn.doclint.not.available=没有 doclint 服务提供方可用

# 0: string
compiler.err.invalid.path=无效文件名: {0}


# 0: path
# lint: path
compiler.warn.invalid.archive.file=以下路径中存在意外的文件: {0}

# 0: path
# lint: path
compiler.warn.unexpected.archive.file=以下档案文件存在意外的扩展名: {0}

# 0: path
compiler.err.no.zipfs.for.archive=没有任何文件系统提供方可处理此文件: {0}

# lint: divzero
compiler.warn.div.zero=除数为零

# lint: empty
compiler.warn.empty.if=if 之后没有语句

# 0: type, 1: name
# lint: classfile
compiler.warn.annotation.method.not.found=无法找到类型 ''{0}'' 的批注方法 ''{1}()''

# 0: type, 1: name, 2: message segment
# lint: classfile
compiler.warn.annotation.method.not.found.reason=无法找到类型 ''{0}'' 的批注方法 ''{1}()'': {2}

# 0: list of annotation, 1: symbol, 2: name, 3: message segment
compiler.err.cant.attach.type.annotations=无法将类型批注 {0} 附加到 {1}.{2}：\n{3}

# 0: file object, 1: symbol, 2: name
compiler.warn.unknown.enum.constant=未知的枚举常量 {1}.{2}

# 0: file object, 1: symbol, 2: name, 3: message segment
compiler.warn.unknown.enum.constant.reason=未知的枚举常量 {1}.{2}\n原因: {3}

# 0: type, 1: type
# lint: rawtypes
compiler.warn.raw.class.use=找到原始类型: {0}\n缺少泛型类{1}的类型参数

compiler.warn.diamond.redundant.args=新表达式中存在冗余类型参数 (改用 diamond 运算符)。

compiler.warn.local.redundant.type=本地变量的冗余类型 (使用 ''var'' 替换显式类型)。

compiler.warn.potential.lambda.found=可将此匿名内部类创建转换为 lambda 表达式。

compiler.warn.method.redundant.typeargs=方法调用中存在冗余类型参数。

# 0: symbol, 1: message segment
# lint: varargs
compiler.warn.varargs.redundant.trustme.anno=冗余的 {0} 批注。{1}

# 0: symbol
# lint: serial
compiler.warn.access.to.member.from.serializable.element=可串行化元素对成员 {0} 的访问可以由不受信任的代码公开执行

# 0: symbol
# lint: serial
compiler.warn.access.to.member.from.serializable.lambda=可串行化 lambda 对成员 {0} 的访问可以由不受信任的代码公开执行

#####

## The following are tokens which are non-terminals in the language. They should
## be named as JLS3 calls them when translated to the appropriate language.
compiler.misc.token.identifier=<标识符>

compiler.misc.token.character=<字符>

compiler.misc.token.string=<字符串>

compiler.misc.token.integer=<整型>

compiler.misc.token.long-integer=<长整型>

compiler.misc.token.float=<浮点型>

compiler.misc.token.double=<双精度型>

compiler.misc.token.bad-symbol=<错误符号>

compiler.misc.token.end-of-input=<输入结束>

## The argument to the following string will always be one of the following:
## 1. one of the above non-terminals
## 2. a keyword (JLS1.8)
## 3. a boolean literal (JLS3.10.3)
## 4. the null literal (JLS3.10.7)
## 5. a Java separator (JLS3.11)
## 6. an operator (JLS3.12)
##
## This is the only place these tokens will be used.
# 0: token
compiler.err.expected=需要{0}

# 0: string
compiler.err.expected.str=需要 {0}

# 0: token, 1: token
compiler.err.expected2=需要{0}或{1}

# 0: token, 1: token, 2: token
compiler.err.expected3=需要{0}, {1}或{2}

# 0: token, 1: token, 2: token, 3: string
compiler.err.expected4=需要 {0}、{1}、{2} 或 {3}

compiler.err.premature.eof=进行语法分析时已到达文件结尾

compiler.err.enum.constant.expected=此处需要枚举常量

compiler.err.enum.constant.not.expected=此处不需要枚举常量

compiler.err.extraneous.semicolon=多余分号

compiler.warn.extraneous.semicolon=多余分号

## The following are related in form, but do not easily fit the above paradigm.
compiler.err.expected.module.or.open=需要 ''module'' 或 ''open''

compiler.err.dot.class.expected=需要 ''.class''

## The argument to this string will always be either 'case' or 'default'.
# 0: token
compiler.err.orphaned=孤立的{0}

# 0: name
compiler.misc.anonymous.class=<匿名{0}>

# 0: name, 1: type
compiler.misc.type.captureof=capture#{0}, 共 {1}

compiler.misc.type.captureof.1=capture#{0}

compiler.misc.type.none=<无>

compiler.misc.unnamed.package=未命名程序包

compiler.misc.unnamed.module=未命名模块

#####

# 0: symbol, 1: message segment
compiler.err.cant.access=无法访问{0}\n{1}

# 0: name
compiler.misc.bad.class.file=类文件对于类 {0} 无效

# 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
compiler.misc.bad.const.pool.entry={0} 中错误的常量池条目\n预期为索引 {2} 处的 {1}

# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
compiler.misc.bad.const.pool.index={0} 中的常量池索引错误\n索引 {1} 不在池大小 {2} 内。

# 0: file name, 1: message segment
compiler.misc.bad.class.file.header=错误的类文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的类路径子目录中。

# 0: file name, 1: message segment
compiler.misc.bad.source.file.header=错误的源文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的源路径子目录中。

## The following are all possible strings for the second argument ({1}) of the
## above strings.
compiler.misc.bad.class.signature=错误的类签名: {0}

#0: symbol, 1: symbol
compiler.misc.bad.enclosing.class={0}的封闭类错误: {1}

# 0: symbol
compiler.misc.bad.enclosing.method=类 {0} 的封闭方法属性错误

# 0: file name
# lint: classfile
compiler.warn.runtime.visible.invisible.param.annotations.mismatch={0} 中 RuntimeVisibleParameterAnnotations 属性和 RuntimeInvisibleParameterAnnotations 属性中的参数长度不匹配，将忽略这两个属性

# 0: file name
# lint: classfile
compiler.warn.runtime.invisible.parameter.annotations={0} 中的 RuntimeVisibleParameterAnnotations 属性和 RuntimeInvisibleParameterAnnotations 属性无法映射到方法的参数

compiler.misc.bad.const.pool.tag=错误的常量池标记: {0}

compiler.misc.bad.const.pool.tag.at=错误的常量池标记: {0}, 位于{1}

# 0: number
compiler.misc.bad.utf8.byte.sequence.at=位于 {0} 的 UTF-8 字节序列错误

compiler.misc.unexpected.const.pool.tag.at=意外的常量池标记：{0}，位于 {1}

# 0: number
compiler.misc.bad.class.truncated.at.offset=类文件在偏移 {0} 处截断

compiler.misc.bad.signature=错误的签名: {0}

compiler.misc.bad.type.annotation.value=错误的类型批注目标类型值: {0}

compiler.misc.bad.module-info.name=错误的类名

compiler.misc.class.file.wrong.class=类文件包含错误的类: {0}

compiler.misc.module.info.invalid.super.class=带有无效超类的 module-info

# 0: name
compiler.misc.class.file.not.found=找不到{0}的类文件

# 0: string (constant value), 1: symbol (constant field), 2: type (field type)
compiler.misc.bad.constant.range={1} 的常量值 ''{0}'' 超出了 {2} 的预期范围

# 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
compiler.misc.bad.constant.value={1} 的常量值 ''{0}'' 错误, 预期为 {2}

# 0: type (field type)
compiler.misc.bad.constant.value.type=''{0}'' 类型的变量不能具有常量值，但是为其指定了一个常量值

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.default.interface=在 {0}.{1} 版类文件中找到默认方法

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.invalid.static.interface=在 {0}.{1} 版类文件中找到静态方法

# 0: string (classfile major version), 1: string (classfile minor version)
compiler.misc.anachronistic.module.info=在 {0}.{1} 版类文件中找到模块声明

compiler.misc.module.info.definition.expected=需要 module-info 定义

# 0: name
compiler.misc.file.doesnt.contain.class=文件不包含类{0}

# 0: symbol
compiler.misc.file.does.not.contain.package=文件不包含程序包{0}

compiler.misc.file.does.not.contain.module=文件不包含模块声明

compiler.misc.illegal.start.of.class.file=非法的类文件开始

# 0: name
compiler.misc.method.descriptor.invalid=方法描述符对 {0} 无效

compiler.misc.unable.to.access.file=无法访问文件: {0}

compiler.misc.unicode.str.not.supported=不支持类文件中的 Unicode 字符串

compiler.misc.undecl.type.var=未声明的类型变量: {0}

compiler.misc.malformed.vararg.method=类文件包含格式错误的变量元数方法: {0}

compiler.misc.wrong.version=类文件具有错误的版本 {0}.{1}, 应为 {2}.{3}

compiler.misc.illegal.flag.combo=类文件包含 {1} {2} 的非法标记组合 {0}

#####

# 0: type, 1: type or symbol
compiler.err.not.within.bounds=类型参数{0}不在类型变量{1}的范围内

## The following are all possible strings for the second argument ({1}) of the
## above string.

## none yet...

#####

# 0: message segment
compiler.err.prob.found.req=不兼容的类型: {0}

# 0: message segment
compiler.misc.prob.found.req=不兼容的类型: {0}

# 0: message segment, 1: type, 2: type
# lint: unchecked
# flags: aggregate
compiler.warn.prob.found.req={0}\n需要: {2}\n找到:    {1}

# 0: type, 1: type
compiler.misc.inconvertible.types={0}无法转换为{1}

# 0: type, 1: type
compiler.misc.possible.loss.of.precision=从{0}转换到{1}可能会有损失

# 0: type, 1: type
# lint: lossy-conversions
compiler.warn.possible.loss.of.precision=在复合赋值中从 {0} 隐式转换为 {1} 可能会有损失

compiler.misc.unchecked.assign=未经检查的转换

# compiler.misc.storecheck=\
#     assignment might cause later store checks to fail
# compiler.misc.unchecked=\
#     assigned array cannot dynamically check its stores
compiler.misc.unchecked.cast.to.type=未经检查的转换

# compiler.err.star.expected=\
#     ''*'' expected
# compiler.err.no.elem.type=\
#     \[\*\] cannot have a type

# 0: message segment
compiler.misc.try.not.applicable.to.type=try-with-resources 不适用于变量类型\n({0})

#####

# 0: object, 1: message segment
compiler.err.type.found.req=意外的类型\n需要: {1}\n找到:    {0}

## The following are all possible strings for the first argument ({0}) of the
## above string.
compiler.misc.type.req.class=类

compiler.misc.type.req.class.array=类或数组

compiler.misc.type.req.array.or.iterable=数组或 java.lang.Iterable

compiler.misc.type.req.ref=引用

compiler.misc.type.req.exact=不带限制范围的类或接口

# 0: type
compiler.misc.type.parameter=类型参数{0}

#####

## The following are all possible strings for the last argument of all those
## diagnostics whose key ends in ".1"

# 0: type, 1: list of type
compiler.misc.no.unique.maximal.instance.exists=对于上限为{1}的类型变量{0}, 不存在唯一最大实例

# 0: type, 1: list of type
compiler.misc.no.unique.minimal.instance.exists=对于下限为{1}的类型变量{0}, 不存在唯一最小实例

# 0: type, 1: list of type
compiler.misc.incompatible.upper.bounds=推论变量 {0} 具有不兼容的上限 {1}

# 0: type, 1: list of type
compiler.misc.incompatible.eq.bounds=推论变量{0}具有不兼容的等式约束条件{1}

# 0: type, 1: fragment, 2: fragment
compiler.misc.incompatible.bounds=推论变量 {0} 具有不兼容的上限\n{1}\n{2}

# 0: list of type
compiler.misc.lower.bounds=下限：{0}

# 0: list of type
compiler.misc.eq.bounds=等式约束条件：{0}

# 0: list of type
compiler.misc.upper.bounds=上限：{0}

# 0: list of type, 1: type, 2: type
compiler.misc.infer.no.conforming.instance.exists=不存在类型变量{0}的实例, 以使{1}与{2}一致

# 0: list of type, 1: message segment
compiler.misc.infer.no.conforming.assignment.exists=无法推断类型变量 {0}\n(参数不匹配; {1})

# 0: list of type
compiler.misc.infer.arg.length.mismatch=无法推断类型变量 {0}\n(实际参数列表和形式参数列表长度不同)

# 0: list of type, 1: message segment
compiler.misc.infer.varargs.argument.mismatch=无法推断类型变量 {0}\n(varargs 不匹配; {1})

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.upper.bounds=推断类型不符合上限\n推断: {0}\n上限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.lower.bounds=推断类型不符合下限\n推断: {0}\n下限: {1}

# 0: type, 1: list of type
compiler.misc.inferred.do.not.conform.to.eq.bounds=推断类型不符合等式约束条件\n推断: {0}\n等式约束条件: {1}

# 0: symbol
compiler.misc.diamond={0}<>

# 0: type
compiler.misc.diamond.non.generic=无法将 ''<>'' 与非泛型类{0}一起使用

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.arg=此上下文中不允许使用为{1}推断的类型参数{0}\n推断参数在签名属性中无法表达

# 0: list of type, 1: message segment
compiler.misc.diamond.invalid.args=此上下文中不允许使用为{1}推断的类型参数{0}\n推断参数在签名属性中无法表达

# 0: type
compiler.misc.diamond.and.explicit.params=不能将 ''<>'' 与构造器的显式类型参数一起使用

compiler.misc.mref.infer.and.explicit.params=不能将原始构造器引用与构造器的显式类型参数一起使用

# 0: type, 1: list of type
compiler.misc.explicit.param.do.not.conform.to.bounds=显式类型参数{0}不符合声明的范围{1}

compiler.misc.arg.length.mismatch=实际参数列表和形式参数列表长度不同

# 0: string
compiler.misc.wrong.number.type.args=类型变量数目错误; 需要{0}

# 0: message segment
compiler.misc.no.conforming.assignment.exists=参数不匹配; {0}

# 0: message segment
compiler.misc.varargs.argument.mismatch=varargs 不匹配; {0}

#####

# 0: symbol or type, 1: file name
# lint: auxiliaryclass
compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file={1} 中的辅助类{0}不应从其自身的源文件以外访问

## The first argument ({0}) is a "kindname".
# 0: kind name, 1: symbol, 2: symbol
compiler.err.abstract.cant.be.accessed.directly=无法直接访问{2}中的抽象{0} {1}

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.non-static.cant.be.ref=无法从静态上下文中引用非静态 {0} {1}

## The first argument ({0}) is a "kindname".
# 0: symbol kind, 1: symbol
compiler.err.local.cant.be.inst.static=无法从静态上下文实例化本地 {0} {1}

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.unbound.lookup=在未绑定查找中找到意外的静态 {0} {1}

# 0: symbol kind, 1: symbol
compiler.misc.bad.instance.method.in.unbound.lookup=在未绑定查找中找到意外的实例 {0} {1}

# 0: symbol kind, 1: symbol
compiler.misc.bad.static.method.in.bound.lookup=在绑定查找中找到意外的静态 {0} {1}

## Both arguments ({0}, {1}) are "kindname"s.  {0} is a comma-separated list
## of kindnames (the list should be identical to that provided in source.
# 0: set of kind name, 1: set of kind name
compiler.err.unexpected.type=意外的类型\n需要: {0}\n找到:    {1}

compiler.err.unexpected.lambda=此处不应为 lambda 表达式

compiler.err.unexpected.mref=此处不应为方法引用

## The first argument {0} is a "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the non-resolved symbol
## The third argument {2} is a list of type parameters (non-empty if {1} is a method)
## The fourth argument {3} is a list of argument types (non-empty if {1} is a method)
# 0: kind name, 1: name, 2: unused, 3: unused
compiler.err.cant.resolve=找不到符号\n符号: {0} {1}

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.err.cant.resolve.args=找不到符号\n符号: {0} {1}({3})

# 0: kind name, 1: name, 2: unused, 3: list of type
compiler.misc.cant.resolve.args=找不到符号\n符号: {0} {1}({3})

# 0: kind name, 1: name, 2: list of type, 3: list of type
compiler.err.cant.resolve.args.params=找不到符号\n符号: {0} <{2}>{1}({3})

## arguments from {0} to {3} have the same meaning as above
## The fifth argument {4} is a location subdiagnostic (see below)
# 0: kind name, 1: name, 2: unused, 3: unused, 4: message segment
compiler.err.cant.resolve.location=找不到符号\n符号:   {0} {1}\n位置: {4}

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.err.cant.resolve.location.args=找不到符号\n符号:   {0} {1}({3})\n位置: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.err.cant.resolve.location.args.params=找不到符号\n符号:   {0} <{2}>{1}({3})\n位置: {4}

### Following are replicated/used for method reference diagnostics

# 0: kind name, 1: name, 2: unused, 3: list of type, 4: message segment
compiler.misc.cant.resolve.location.args=找不到符号\n符号:   {0} {1}({3})\n位置: {4}

# 0: kind name, 1: name, 2: list of type, 3: list, 4: message segment
compiler.misc.cant.resolve.location.args.params=找不到符号\n符号:   {0} <{2}>{1}({3})\n位置: {4}

##a location subdiagnostic is composed as follows:
## The first argument {0} is the location "kindname" (e.g. 'constructor', 'field', etc.)
## The second argument {1} is the location name
## The third argument {2} is the location type (only when {1} is a variable name)

# 0: kind name, 1: type or symbol, 2: unused
compiler.misc.location={0} {1}

# 0: kind name, 1: symbol, 2: type
compiler.misc.location.1=类型为{2}的{0} {1}

## The following are all possible string for "kindname".
## They should be called whatever the JLS calls them after it been translated
## to the appropriate language.
# compiler.misc.kindname.constructor=\
#     static member
compiler.misc.kindname.annotation=@interface

compiler.misc.kindname.constructor=构造器

compiler.misc.kindname.enum=枚举

compiler.misc.kindname.interface=接口

compiler.misc.kindname.static=静态

compiler.misc.kindname.type.variable=类型变量

compiler.misc.kindname.type.variable.bound=类型变量的限制范围

compiler.misc.kindname.variable=变量

compiler.misc.kindname.value=值

compiler.misc.kindname.method=方法

compiler.misc.kindname.class=类

compiler.misc.kindname.package=程序包

compiler.misc.kindname.module=模块

compiler.misc.kindname.static.init=静态初始化程序

compiler.misc.kindname.instance.init=实例初始化程序

compiler.misc.kindname.record.component=记录组件

compiler.misc.kindname.record=记录

#####

compiler.misc.no.args=没有参数

# 0: message segment
compiler.err.override.static={0}\n覆盖的方法为 static

# 0: message segment, 1: set of flag
compiler.err.override.meth={0}\n被覆盖的方法为{1}

# 0: message segment, 1: type
compiler.err.override.meth.doesnt.throw={0}\n被覆盖的方法未抛出{1}

# In the following string {1} is a space separated list of Java Keywords, as
# they would have been declared in the source code
# 0: message segment, 1: set of flag or string
compiler.err.override.weaker.access={0}\n正在尝试分配更低的访问权限; 以前为{1}

# 0: message segment, 1: type, 2: type
compiler.err.override.incompatible.ret={0}\n返回类型{1}与{2}不兼容

# 0: message segment, 1: type, 2: type
# lint: unchecked
# flags: aggregate
compiler.warn.override.unchecked.ret={0}\n返回类型需要从{1}到{2}的未经检查的转换

# 0: message segment, 1: type
# lint: unchecked
# flags: aggregate
compiler.warn.override.unchecked.thrown={0}\n被覆盖的方法未抛出{1}

# 0: symbol
# lint: overrides
compiler.warn.override.equals.but.not.hashcode=类{0}覆盖了 equals, 但该类或任何超类都未覆盖 hashCode 方法

## The following are all possible strings for the first argument ({0}) of the
## above strings.
# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.override={1}中的{0}无法覆盖{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.hide={1} 中的 {0} 无法隐藏 {3} 中的 {2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.cant.implement={1}中的{0}无法实现{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.clashes.with={1}中的{0}与{3}中的{2}冲突

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.override={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.implement={1}中的{0}实现了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.unchecked.clash.with={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.override={1}中的{0}覆盖了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.implement={1}中的{0}实现了{3}中的{2}

# 0: symbol, 1: symbol, 2: symbol, 3: symbol
compiler.misc.varargs.clash.with={1}中的{0}覆盖了{3}中的{2}

# 0: kind name, 1: symbol, 2: symbol, 3: message segment
compiler.misc.inapplicable.method={0} {1}.{2}不适用\n({3})

########################################
# Diagnostics for language feature changes.
# Such diagnostics have a common template which can be customized by using a feature
# diagnostic fragment (one of those given below).
########################################

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
# flags: source-level
compiler.err.feature.not.supported.in.source=-source {1} 中不支持 {0}\n(请使用 -source {2} 或更高版本以启用 {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
# flags: source-level
compiler.err.feature.not.supported.in.source.plural=-source {1} 中不支持 {0}\n(请使用 -source {2} 或更高版本以启用 {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source=-source {1} 中不支持 {0}\n(请使用 -source {2} 或更高版本以启用 {0})

# 0: message segment (feature), 1: string (found version), 2: string (expected version)
compiler.misc.feature.not.supported.in.source.plural=-source {1} 中不支持 {0}\n(请使用 -source {2} 或更高版本以启用 {0})

# 0: message segment (feature)
# flags: source-level
compiler.err.preview.feature.disabled={0} 是预览功能，默认情况下禁用。\n（请使用 --enable-preview 以启用 {0}）

# 0: message segment (feature)
# flags: source-level
compiler.err.preview.feature.disabled.plural={0} 是预览功能，默认情况下禁用。\n（请使用 --enable-preview 以启用 {0}）

# 0: file object (classfile), 1: string (expected version)
compiler.err.preview.feature.disabled.classfile={0} 的类文件使用 Java SE {1} 的预览功能。\n（请使用 --enable-preview 以允许加载包含预览功能的类文件）

# 0: message segment (feature)
# lint: preview
# flags: aggregate
compiler.warn.preview.feature.use={0} 是预览功能，可能会在未来发行版中删除。

# 0: message segment (feature)
# lint: preview
# flags: aggregate
compiler.warn.preview.feature.use.plural={0} 是预览功能，可能会在未来发行版中删除。

# 0: file object (classfile), 1: string (expected version)
# lint: preview
compiler.warn.preview.feature.use.classfile={0} 的类文件使用 Java SE {1} 的预览功能。

compiler.misc.feature.modules=模块

compiler.misc.feature.diamond.and.anon.class=''<>'' 具有匿名的内部类

compiler.misc.feature.var.in.try.with.resources=try-with-resources 中的变量

compiler.misc.feature.private.intf.methods=私有接口方法

compiler.misc.feature.text.blocks=文本块

compiler.misc.feature.multiple.case.labels=多个 case 标签

compiler.misc.feature.switch.rules=switch 规则

compiler.misc.feature.switch.expressions=switch 表达式

compiler.misc.feature.var.syntax.in.implicit.lambda=隐式 lambda 中的 var 语法

compiler.misc.feature.pattern.matching.instanceof=instanceof 中的模式匹配

compiler.misc.feature.reifiable.types.instanceof=instanceof 中的可具体化类型

compiler.misc.feature.deconstruction.patterns=解构模式

compiler.misc.feature.unnamed.variables=未命名变量

compiler.misc.feature.primitive.patterns=基元模式

compiler.misc.feature.records=记录

compiler.misc.feature.sealed.classes=密封类

compiler.misc.feature.case.null=switch case 中的空值

compiler.misc.feature.pattern.switch=switch 语句中的模式

compiler.misc.feature.unconditional.patterns.in.instanceof=instanceof 中的无条件模式

compiler.misc.feature.implicit.classes=隐式声明的类

compiler.misc.feature.flexible.constructors=灵活构造器

compiler.misc.feature.module.imports=模块导入

# L10N: do not localize: transitive
compiler.misc.feature.java.base.transitive=java.base 的 transitive 修饰符

compiler.warn.underscore.as.identifier=从发行版 9 开始, ''_'' 为关键字, 不能用作标识符

compiler.err.underscore.as.identifier=从发行版 9 开始, ''_'' 为关键字, 不能用作标识符

compiler.err.use.of.underscore.not.allowed=此处不允许使用下划线\n从发行版 9 开始，''_'' 为关键字，不能用作标识符\n从发行版 22 开始，''_'' 可以用作未命名模式、本地变量、异常错误参数或 lambda 参数的声明中的名称

compiler.err.use.of.underscore.not.allowed.non.variable=此处不允许使用下划线

compiler.err.use.of.underscore.not.allowed.with.brackets=下划线关键字 ''_'' 不允许后跟方括号

compiler.err.enum.as.identifier=从发行版 5 开始, ''enum'' 为关键字, 不能用作标识符

compiler.err.assert.as.identifier=从发行版 1.4 开始, ''assert'' 为关键字, 不能用作标识符

# TODO 308: make a better error message
compiler.err.this.as.identifier=从发行版 8 开始，''this'' 只能作为接收方类型的参数名，\n该参数必须为第一个参数，并且不能是 lambda 参数

compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class=接收方参数不适用于顶层类的构造器

# 0: fragment, 1: symbol, 2: annotated-type
compiler.err.type.annotation.inadmissible={0} 不应出现在此处\n（要对限定类型进行批注，请编写 {1}.{2}）

# 0: annotation
compiler.misc.type.annotation.1=类型批注 {0} 为

# 0: list of annotation
compiler.misc.type.annotation=类型批注 {0} 为

# 0: type, 1: type
compiler.err.incorrect.receiver.name=接收方名称与封闭类类型不匹配\n需要: {0}\n找到:    {1}

# 0: type, 1: type
compiler.err.incorrect.receiver.type=接收方类型与封闭类类型不匹配\n需要: {0}\n找到:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.type=接收方类型与外部封闭类类型不匹配\n需要: {0}\n找到:    {1}

# 0: type, 1: type
compiler.err.incorrect.constructor.receiver.name=接收方名称与外部封闭类类型不匹配\n需要: {0}\n找到:    {1}

compiler.err.no.annotations.on.dot.class=类文字类型中不允许使用任何批注

########################################
# Diagnostics for verbose resolution
# used by Resolve (debug only)
########################################

# 0: number, 1: symbol, 2: unused
compiler.misc.applicable.method.found=找到第 {0} 个适用方法: {1}

# 0: number, 1: symbol, 2: message segment
compiler.misc.applicable.method.found.1=找到第 {0} 个适用方法: {1}\n({2})

# 0: number, 1: symbol, 2: message segment
compiler.misc.not.applicable.method.found=找到第 {0} 个不适用的方法: {1}\n({2})

# 0: type
compiler.misc.partial.inst.sig=部分实例化为: {0}

# 0: name, 1: symbol, 2: number, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi=将类型 {1} 的方法 {0} 解析为候选项 {2}\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:

# 0: name, 1: symbol, 2: unused, 3: string (method resolution phase), 4: list of type or message segment, 5: list of type or message segment
compiler.note.verbose.resolve.multi.1=类型 {1} 的方法 {0} 解析错误\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:

# 0: symbol, 1: type, 2: type
compiler.note.deferred.method.inst=方法 {0} 的延迟实例化\n实例化签名: {1}\n目标类型: {2}

########################################
# Diagnostics for lambda deduplication
# used by LambdaToMethod (debug only)
########################################

# 0: symbol
compiler.note.verbose.l2m.deduplicate=正在对 lambda 函数实现方法 {0} 进行重复数据删除

########################################
# Diagnostics for method reference search
# results used by Resolve (debug only)
########################################

# 0: fragment, 1: string, 2: number
compiler.note.method.ref.search.results.multi={1} 的 {0} 搜索结果，有 {2} 个\n最明确的适用候选项：

# 0: number, 1: fragment, 2: symbol
compiler.misc.applicable.method.found.2=找到的第 {0} 个适用方法：{1} {2}

# 0: number, 1: fragment, 2: symbol, 3: message segment
compiler.misc.applicable.method.found.3=找到的第 {0} 个适用方法：{1} {2}\n({3})

compiler.misc.static=静态

compiler.misc.non.static=非静态

compiler.misc.bound=绑定

compiler.misc.unbound=未绑定

########################################
# Diagnostics for where clause implementation
# used by the RichDiagnosticFormatter.
########################################

compiler.misc.type.null=<空值>

# X#n (where n is an int id) is disambiguated tvar name
# 0: name, 1: number
compiler.misc.type.var={0}#{1}

# CAP#n (where n is an int id) is an abbreviation for 'captured type'
# 0: number
compiler.misc.captured.type=CAP#{0}

# <INT#n> (where n is an int id) is an abbreviation for 'intersection type'
# 0: number
compiler.misc.intersection.type=INT#{0}

# where clause for captured type: contains upper ('extends {1}') and lower
# ('super {2}') bound along with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: type, 3: type
compiler.misc.where.captured={0}从{3}的捕获扩展{1} 超 {2}

# compact where clause for captured type: contains upper ('extends {1}') along
# with the wildcard that generated this captured type ({3})
# 0: type, 1: type, 2: unused, 3: type
compiler.misc.where.captured.1={0}从{3}的捕获扩展{1}

# where clause for type variable: contains upper bound(s) ('extends {1}') along with
# the kindname ({2}) and location ({3}) in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar={0}扩展已在{2} {3}中声明的{1}

# compact where clause for type variable: contains the kindname ({2}) and location ({3})
# in which the typevar has been declared
# 0: type, 1: list of type, 2: symbol kind, 3: symbol
compiler.misc.where.typevar.1={0}已在{2} {3}中声明

# where clause for fresh type variable: contains upper bound(s) ('extends {1}').
# Since a fresh type-variable is synthetic - there's no location/kindname here.
# 0: type, 1: list of type
compiler.misc.where.fresh.typevar={0}扩展{1}

# where clause for type variable: contains all the upper bound(s) ('extends {1}')
# of this intersection type
# 0: type, 1: list of type
compiler.misc.where.intersection={0}扩展{1}

### Where clause headers ###
compiler.misc.where.description.captured=其中, {0}是新类型变量:

# 0: set of type
compiler.misc.where.description.typevar=其中, {0}是类型变量:

# 0: set of type
compiler.misc.where.description.intersection=其中, {0}是交叉类型:

# 0: set of type
compiler.misc.where.description.captured.1=其中, {0}是新类型变量:

# 0: set of type
compiler.misc.where.description.typevar.1=其中, {0}是类型变量:

# 0: set of type
compiler.misc.where.description.intersection.1=其中, {0}是交叉类型:

###
# errors related to doc comments

compiler.err.dc.bad.entity=HTML 实体错误

compiler.err.dc.bad.inline.tag=内嵌标记的用法不正确

compiler.err.dc.identifier.expected=需要标识符

compiler.err.dc.invalid.html=HTML 无效

compiler.err.dc.malformed.html=格式错误的 HTML

compiler.err.dc.missing.semicolon=缺少分号

compiler.err.dc.no.content=无内容

compiler.err.dc.no.tag.name=''@'' 后面没有标记名称

compiler.err.dc.no.url=无 URL

compiler.err.dc.no.title=无标题

compiler.err.dc.gt.expected=需要 ''>''

compiler.err.dc.ref.bad.parens=括号之后出现意外的文本

compiler.err.dc.ref.syntax.error=引用中出现语法错误

compiler.err.dc.ref.unexpected.input=意外的文本

compiler.err.dc.unexpected.content=意外的内容

compiler.err.dc.unterminated.inline.tag=未终止的内嵌标记

compiler.err.dc.unterminated.signature=未终止的签名

compiler.err.dc.unterminated.string=未终止的字符串

compiler.err.dc.ref.annotations.not.allowed=不允许使用批注

###
# errors related to modules

compiler.err.expected.module=预期 ''module''

# 0: symbol
compiler.err.module.not.found=找不到模块: {0}

# 0: symbol
# lint: module
compiler.warn.module.not.found=找不到模块: {0}

# 0: name
compiler.err.import.module.not.found=找不到导入的模块：{0}

# 0: symbol
compiler.err.import.module.does.not.read.unnamed=未命名模块未读取：{0}

# 0: symbol, 1: symbol
compiler.err.import.module.does.not.read=模块 {0} 未读取：{1}

compiler.err.too.many.modules=找到太多的模块声明

compiler.err.module.not.found.on.module.source.path=在模块源路径中找不到模块

compiler.err.not.in.module.on.module.source.path=不在模块源路径上的模块中

# 0: symbol
compiler.err.duplicate.module=重复的模块: {0}

# 0: symbol
compiler.err.duplicate.requires=重复的 requires 指令: {0}

# 0: symbol
compiler.err.conflicting.exports=重复或冲突的导出操作: {0}

# 0: symbol
compiler.err.conflicting.opens=重复或冲突的打开操作: {0}

# 0: symbol
compiler.err.conflicting.exports.to.module=重复或冲突的导出到模块操作: {0}

# 0: symbol
compiler.err.conflicting.opens.to.module=重复或冲突的打开到模块操作: {0}

compiler.err.no.opens.unless.strong=只允许在强模块中使用 ''opens''

# 0: symbol
compiler.err.repeated.provides.for.service=服务 {0} 有多个 ''provides''

# 0: symbol, 1: symbol
compiler.err.duplicate.provides=重复的 provides 指令: 服务 {0}, 实现 {1}

# 0: symbol
compiler.err.duplicate.uses=重复的 uses 指令: {0}

# 0: symbol
compiler.err.service.implementation.is.abstract=服务实现是抽象类: {0}

compiler.err.service.implementation.must.be.subtype.of.service.interface=服务实现类型必须是服务接口类型的子类型, 或者具有名为 "provider" 的, 返回服务实现的公共静态无参数方法

compiler.err.service.implementation.provider.return.must.be.subtype.of.service.interface="provider" 方法返回类型必须是服务接口类型的子类型

# 0: symbol
compiler.err.service.implementation.is.inner=服务实现是内部类: {0}

# 0: symbol
compiler.err.service.definition.is.enum=服务定义是枚举: {0}

# 0: symbol
compiler.err.service.implementation.doesnt.have.a.no.args.constructor=服务实现没有默认的构造器: {0}

# 0: symbol
compiler.err.service.implementation.no.args.constructor.not.public=服务实现的无参数构造器不是公共构造器: {0}

# 0: symbol
compiler.err.package.empty.or.not.found=程序包为空或不存在: {0}

# 0: symbol
# lint: opens
compiler.warn.package.empty.or.not.found=程序包为空或不存在: {0}

compiler.err.no.output.dir=未指定类输出目录

compiler.err.unnamed.pkg.not.allowed.named.modules=命名模块中不允许未命名程序包

# 0: name, 1: name
compiler.err.module.name.mismatch=模块名称 {0} 与预期名称 {1} 不匹配

# 0: name, 1: name
compiler.misc.module.name.mismatch=模块名称 {0} 与预期名称 {1} 不匹配

# 0: name
compiler.err.module.non.zero.opens=打开的模块 {0} 具有非零 opens_count

# 0: name
compiler.misc.module.non.zero.opens=打开的模块 {0} 具有非零 opens_count

compiler.err.module.decl.sb.in.module-info.java=模块声明应该在名为 module-info.java 的文件中

# 0: set of string
compiler.err.too.many.patched.modules=太多打补丁的模块 ({0}), 请使用 --module-source-path

# 0: name, 1: name
compiler.err.file.patched.and.msp=可从 --patch-module 和 --module-source-path 访问文件, 但该文件在每个路径中属于不同的模块: {0}, {1}

compiler.err.processorpath.no.processormodulepath=-processorpath 与 --processor-module-path 的组合非法

# 0: symbol
compiler.err.package.in.other.module=程序包已存在于另一个模块中: {0}

# 0: symbol, 1: name, 2: symbol, 3: symbol
compiler.err.package.clash.from.requires=模块 {0} 同时从 {2} 和 {3} 读取程序包 {1}

# 0: name, 1: symbol, 2: symbol
compiler.err.package.clash.from.requires.in.unnamed=未命名的模块同时从 {1} 和 {2} 读取程序包 {0}

# 0: string
compiler.err.module.not.found.in.module.source.path=在模块源路径中找不到模块 {0}

compiler.err.output.dir.must.be.specified.with.dash.m.option=如果使用 -m 选项, 则必须指定类输出目录

compiler.err.modulesourcepath.must.be.specified.with.dash.m.option=如果使用 -m 选项, 则必须指定模块源路径

# 0: symbol
compiler.err.service.implementation.not.in.right.module=必须在与 provides 指令相同的模块中定义服务实现

# 0: symbol
compiler.err.cyclic.requires=涉及 {0} 的循环被依赖对象

# 0: fragment, 1: name
compiler.err.duplicate.module.on.path={1} 中的 {0} 上存在\n重复的模块

# 0: option name, 1: string
compiler.warn.bad.name.for.option={0} 选项的值中有错误的名称: ''{1}''

# 0: option name, 1: string
compiler.err.bad.name.for.option={0} 选项的值中有错误的名称: ''{1}''

# 0: option name, 1: symbol
# lint: options
compiler.warn.module.for.option.not.found=找不到 {0} 选项中的模块名称: {1}

compiler.err.addmods.all.module.path.invalid=--add-modules ALL-MODULE-PATH 只能在编译未命名模块或在自动模块的上下文中编译时使用

# 0: symbol
compiler.err.add.exports.with.release=不允许在使用 --release 时从系统模块 {0} 导出程序包:

# 0: symbol
compiler.err.add.reads.with.release=不允许在使用 --release 时为系统模块 {0} 添加读取维边:

# lint: options
compiler.warn.addopens.ignored=--add-opens 在编译时没有任何效果

compiler.misc.locn.module_source_path=模块源路径

compiler.misc.locn.upgrade_module_path=升级模块路径

compiler.misc.locn.system_modules=系统模块

compiler.misc.locn.module_path=应用程序模块路径

compiler.misc.cant.resolve.modules=无法解析模块

compiler.misc.bad.requires.flag="requires java.base" 的标记无效：{0}

# 0: string
compiler.err.invalid.module.specifier=不允许模块说明符: {0}

# 0: symbol
compiler.warn.service.provided.but.not.exported.or.used=已提供服务接口, 但未导出或使用服务接口

# 0: kind name, 1: symbol, 2: symbol
# lint: exports
compiler.warn.leaks.not.accessible=模块 {2} 中的 {0} {1} 对需要该模块的客户机不可访问
# 0: kind name, 1: symbol, 2: symbol
# lint: exports
compiler.warn.leaks.not.accessible.unexported=未导出模块 {2} 中的 {0} {1}
# 0: kind name, 1: symbol, 2: symbol
# lint: exports
compiler.warn.leaks.not.accessible.not.required.transitive=未使用 ''requires transitive'' 间接导出模块 {2} 中的 {0} {1}
# 0: kind name, 1: symbol, 2: symbol
# lint: exports
compiler.warn.leaks.not.accessible.unexported.qualified=模块 {2} 中的 {0} {1} 可能对需要该模块的所有客户机都不可见

###
# errors related to options

# 0: string, 1: string
compiler.err.illegal.argument.for.option={0} 的参数非法: {1}

compiler.err.match.binding.exists=尝试重新定义现有的匹配绑定，这是非法的

compiler.err.switch.case.unexpected.statement=case 中存在意外语句，应为表达式、块或抛出语句

compiler.err.switch.mixing.case.types=在 switch 中使用了不同 case 类型

###
# errors related to sealed classes

# permits clause
# 0: fragment
compiler.err.invalid.permits.clause=无效的 permits 子句\n({0})

# 0: string
compiler.misc.class.is.not.sealed=必须密封 {0}

# 0: type
compiler.misc.is.a.type.variable=不得包含类型变量：{0}

# 0: type
compiler.misc.is.duplicated=不得包含重复项：{0}

# 0: type
compiler.misc.doesnt.extend.sealed=类 {0} 必须扩展密封类

# 0: kind name, 1: type
compiler.misc.doesnt.implement.sealed={0} {1} 必须扩展密封接口

compiler.misc.must.not.be.same.class=permits 子句中存在非法自引用

# 0: type
compiler.misc.must.not.be.supertype=对超类型 {0} 的引用非法

# other sealed types related errors

compiler.err.sealed.class.must.have.subclasses=密封类必须具有子类

# errors in subclasses of sealed classes
# 0: symbol
compiler.err.cant.inherit.from.sealed=类不得扩展密封类：{0}（因为它未列在其 ''permits'' 子句中）

# 0: symbol
compiler.err.class.in.unnamed.module.cant.extend.sealed.in.diff.package=未命名模块中的类 {0} 无法扩展其他程序包中的密封类

# 0: symbol, 1: symbol
compiler.err.class.in.module.cant.extend.sealed.in.diff.module=模块 {1} 中的类 {0} 无法扩展其他模块中的密封类

# 0: symbol
compiler.err.non.sealed.with.no.sealed.supertype=此处不允许使用非密封修饰符\n（类 {0} 不具有任何密封的超类型）

compiler.err.non.sealed.sealed.or.final.expected=需要密封、非密封或最终修饰符

compiler.err.non.sealed.or.sealed.expected=需要密封或非密封修饰符

compiler.err.sealed.or.non.sealed.local.classes.not.allowed=不允许使用密封或非密封本地类

# 0: fragment
compiler.err.local.classes.cant.extend.sealed={0} 类不得扩展密封类
compiler.misc.anonymous=匿名

compiler.misc.local=本地

###
# errors related to records

# record components
compiler.err.record.cant.declare.field.modifiers=记录组件不能具有修饰符

# 0: symbol
compiler.err.illegal.record.component.name=记录组件名称 {0} 非法

compiler.err.record.component.and.old.array.syntax=记录组件中不允许使用传统数组记号

# accessor methods
# 0: symbol, 1: fragment
compiler.err.invalid.accessor.method.in.record=记录 {0} 中的存取方法无效\n({1})

compiler.misc.method.must.be.public=存取方法必须是公共的

# 0: symbol, 1: symbol
compiler.misc.accessor.return.type.doesnt.match=存取方法 {0} 的返回类型必须与记录组件 {1} 的类型相匹配

compiler.misc.accessor.method.cant.throw.exception=对于存取方法不允许使用 throws 子句

compiler.misc.accessor.method.must.not.be.generic=存取方法不能为泛型方法

compiler.misc.accessor.method.must.not.be.static=存取方法不能为静态方法

# canonical constructors
# 0: fragment, 1: name, 2: fragment
compiler.err.invalid.canonical.constructor.in.record=记录 {1} 中的 {0} 构造器无效\n({2})

compiler.misc.canonical=规范

compiler.misc.compact=精简

# 0: fragment
compiler.misc.throws.clause.not.allowed.for.canonical.constructor=对于 {0} 构造器，不允许使用 throws 子句

compiler.misc.canonical.with.name.mismatch=规范构造器中的参数名称无效

compiler.misc.canonical.cant.have.return.statement=精简构造器不得包含返回语句

compiler.misc.canonical.must.not.declare.type.variables=规范构造器不得声明类型变量

compiler.misc.type.must.be.identical.to.corresponding.record.component.type=类型和元数必须与相应记录组件的类型和元数相匹配
compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=规范构造器不得包含显式构造器调用

# 0: set of flag or string
compiler.misc.canonical.must.not.have.stronger.access=正在尝试分配更强的访问权限；以前为 {0}

# other
compiler.err.record.cannot.declare.instance.fields=字段声明必须为静态\n（考虑将字段替换为记录组件）

# 0: symbol
compiler.err.invalid.supertype.record=类无法直接扩展 {0}

# 0: symbol
compiler.err.non.canonical.constructor.invoke.another.constructor=构造器不是规范的，因此它必须调用类 {0} 的另一个构造器

compiler.err.instance.initializer.not.allowed.in.records=记录中不允许使用实例初始化程序

compiler.err.static.declaration.not.allowed.in.inner.classes=内部类中不允许使用静态声明

compiler.err.record.patterns.annotations.not.allowed=记录模式不允许使用批注

############################################
# messages previously at javac.properties

compiler.err.empty.A.argument=-A 需要一个参数; 使用 ''-Akey'' 或 ''-Akey=value''

# 0: string
compiler.err.invalid.A.key=批注处理程序选项 ''{0}'' 中的关键字不是以点分隔的标识符序列

# 0: string
compiler.err.invalid.flag=无效的标记: {0}

compiler.err.profile.bootclasspath.conflict=配置文件和引导类路径选项不能同时使用

# 0: string
compiler.err.invalid.profile=无效的配置文件：{0}

# 0: string
compiler.err.invalid.target=无效的目标发行版：{0}

# 0: option name, 1: target
compiler.err.option.not.allowed.with.target=目标 {1} 不允许选项 {0}

# 0: string
compiler.err.option.too.many=选项 {0} 只能指定一次

compiler.err.no.source.files=无源文件

compiler.err.no.source.files.classes=无源文件或类名

# 0: string
compiler.err.req.arg={0} 需要参数

# 0: string
compiler.err.invalid.source=无效的源发行版：{0}

# 0: string, 1: string
compiler.err.error.writing.file=写入 {0} 时出错；{1}

compiler.err.sourcepath.modulesourcepath.conflict=无法同时指定 --source-path 与 --module-source-path

# 0: string, 1: string
compiler.err.source.target.conflict=指定的目标发行版 {1} 对于指定的源发行版 {0} 来说太旧\n当编译要在 JDK {1} 上运行的代码时，建议使用 --release {1}

# 0: string, 1: string
compiler.err.target.default.source.conflict=指定的目标发行版 {1} 对于默认源发行版 {0} 来说太旧\n当编译要在 JDK {1} 上运行的代码时，建议使用 --release {1}

# 0: profile, 1: target
compiler.warn.profile.target.conflict=配置文件{0}对于目标发行版 {1} 无效

# 0: string
compiler.err.file.not.directory=不是目录：{0}

# 0: object
compiler.err.file.not.file=不是文件：{0}

compiler.err.two.class.loaders.1=javac 在多个类加载器之间拆分: 请检查配置

# 0: url, 1: url
compiler.err.two.class.loaders.2=javac 在多个类加载器之间拆分:\n一个类来自文件: {0}\n而 javac 来自 {1}

# 0: string, 1: string
compiler.err.bad.value.for.option={0} 选项的值错误: ''{1}''

# 0: string
compiler.err.no.value.for.option={0} 选项没有值

# 0: string
compiler.err.repeated.value.for.patch.module=为模块 {0} 多次指定了 --patch-module

# 0: string
compiler.err.repeated.value.for.module.source.path=为模块 {0} 多次指定了 --module-source-path

compiler.err.multiple.values.for.module.source.path=使用模式参数多次指定了 --module-source-path

# 0: string
compiler.err.unmatched.quote=环境变量 {0} 中的引号不成对

# 0: option name
compiler.err.release.bootclasspath.conflict=选项 {0} 不能与 --release 一起使用

# 0: string
compiler.err.unsupported.release.version=不支持发行版本 {0}

# 0: string
compiler.err.file.not.found=找不到文件: {0}

# 0: string, 1: source
compiler.err.preview.not.latest=源发行版 {0} 与 --enable-preview 一起使用时无效\n（仅发行版 {1} 支持预览语言功能）

compiler.err.preview.without.source.or.release=--enable-preview 必须与 -source 或 --release 一起使用

# 0: symbol
compiler.err.deconstruction.pattern.only.records=解构模式只能应用于记录，{0} 不是记录

compiler.err.deconstruction.pattern.var.not.allowed=解构模式只能应用于记录，不允许使用 var

# 0: list of type, 1: list of type
compiler.err.incorrect.number.of.nested.patterns=嵌套模式数不正确\n需要：{0}\n已找到：{1}

# 0: kind name, 1: symbol
# lint: preview
# flags: aggregate
compiler.warn.declared.using.preview={0} {1} 是使用预览功能声明的，可能会在未来发行版中删除。

# lint: identity
compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class=尝试在基于值的类的实例上同步

# lint: identity
compiler.warn.attempt.to.use.value.based.where.identity.expected=使用基于值的类，其操作需要可靠的身份

# 0: type
compiler.err.enclosing.class.type.non.denotable=封闭类类型：{0}\n是不可指示的类型，尝试转换为可指示的类型
