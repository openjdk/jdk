#
# Copyright (c) 2000, 2025, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

NEWLINE=\n
STAR=*******************************************
STARNN=*******************************************\n\n
# keytool: Help part
.OPTION.=\u0020[OPTION]...
Options.=オプション:
option.1.set.twice=%sオプションが複数回指定されています。最後のもの以外はすべて無視されます。
multiple.commands.1.2=1つのコマンドのみ許可されます: %1$sと%2$sの両方が指定されました。
Use.keytool.help.for.all.available.commands=このヘルプ・メッセージを表示するには"keytool -?、-hまたは--help"を使用します
Key.and.Certificate.Management.Tool=キーおよび証明書管理ツール
Commands.=コマンド:
Use.keytool.command.name.help.for.usage.of.command.name=command_nameの使用方法については、"keytool -command_name --help"を使用します。\n事前構成済のオプション・ファイルを指定するには、-conf <url>オプションを使用します。
# keytool: help: commands
Generates.a.certificate.request=証明書リクエストを生成します
Changes.an.entry.s.alias=エントリの別名を変更します
Deletes.an.entry=エントリを削除します
Exports.certificate=証明書をエクスポートします
Generates.a.key.pair=キー・ペアを生成します
Generates.a.secret.key=秘密キーを生成します
Generates.certificate.from.a.certificate.request=証明書リクエストから証明書を生成します
Generates.CRL=CRLを生成します
Generated.keyAlgName.secret.key={0}秘密キーを生成しました
Generated.keysize.bit.keyAlgName.secret.key={0}ビット{1}秘密キーを生成しました
key.algorithm.weak=%1$sは%2$sアルゴリズムを使用しており、これはセキュリティ・リスクとみなされます。
key.size.weak=%1$sは%2$sを使用しており、これはセキュリティ・リスクとみなされます。
Imports.entries.from.a.JDK.1.1.x.style.identity.database=JDK 1.1.x-styleアイデンティティ・データベースからエントリをインポートします
Imports.a.certificate.or.a.certificate.chain=証明書または証明書チェーンをインポートします
Imports.a.password=パスワードをインポートします
Imports.one.or.all.entries.from.another.keystore=別のキーストアから1つまたはすべてのエントリをインポートします
Clones.a.key.entry=キー・エントリのクローンを作成します
Changes.the.key.password.of.an.entry=エントリのキー・パスワードを変更します
Lists.entries.in.a.keystore=キーストア内のエントリをリストします
Prints.the.content.of.a.certificate=証明書の内容を出力します
Prints.the.content.of.a.certificate.request=証明書リクエストの内容を出力します
Prints.the.content.of.a.CRL.file=CRLファイルの内容を出力します
Generates.a.self.signed.certificate=自己署名型証明書を生成します
Changes.the.store.password.of.a.keystore=キーストアのストア・パスワードを変更します
showinfo.command.help=セキュリティ関連情報を表示します
Prints.the.program.version=プログラム・バージョンを出力します
# keytool: help: options
alias.name.of.the.entry.to.process=処理するエントリの別名
groupname.option.help=グループ名。たとえば、楕円曲線名です。
destination.alias=出力先の別名
destination.key.password=出力先キーのパスワード
destination.keystore.name=出力先キーストア名
destination.keystore.password.protected=出力先キーストアの保護対象パスワード
destination.keystore.provider.name=出力先キーストア・プロバイダ名
destination.keystore.password=出力先キーストアのパスワード
destination.keystore.type=出力先キーストアのタイプ
distinguished.name=識別名
X.509.extension=X.509拡張
output.file.name=出力ファイル名
input.file.name=入力ファイル名
key.algorithm.name=キー・アルゴリズム名
key.password=キーのパスワード
key.bit.size=キーのビット・サイズ
keystore.name=キーストア名
access.the.cacerts.keystore=cacertsキーストアにアクセスする
warning.cacerts.option=警告: cacertsキーストアにアクセスするには-cacertsオプションを使用してください
new.password=新規パスワード
do.not.prompt=プロンプトを表示しない
password.through.protected.mechanism=保護メカニズムによるパスワード
tls.option.help=TLS構成情報を表示します
# The following 2 values should span 2 lines, the first for the
# option itself, the second for its -providerArg value.
addprovider.option=名前でセキュリティ・プロバイダを追加する(SunPKCS11など)\n-addproviderの引数を構成する
provider.class.option=完全修飾クラス名でセキュリティ・プロバイダを追加する\n-providerclassの引数を構成する

provider.name=プロバイダ名
provider.classpath=プロバイダ・クラスパス
output.in.RFC.style=RFCスタイルの出力
signature.algorithm.name=署名アルゴリズム名
signer.alias=署名者の別名
signer.key.password=署名者のキーのパスワード
source.alias=ソース別名
source.key.password=ソース・キーのパスワード
source.keystore.name=ソース・キーストア名
source.keystore.password.protected=ソース・キーストアの保護対象パスワード
source.keystore.provider.name=ソース・キーストア・プロバイダ名
source.keystore.password=ソース・キーストアのパスワード
source.keystore.type=ソース・キーストアのタイプ
SSL.server.host.and.port=SSLサーバーのホストとポート
signed.jar.file=署名付きJARファイル
certificate.validity.start.date.time=証明書の有効開始日時
keystore.password=キーストアのパスワード
keystore.type=キーストアのタイプ
trust.certificates.from.cacerts=cacertsからの証明書を信頼する
verbose.output=詳細出力
validity.number.of.days=妥当性日数
Serial.ID.of.cert.to.revoke=失効する証明書のシリアルID
# keytool: Running part
keytool.error.=keytoolエラー:\u0020
Illegal.option.=不正なオプション: \u0020
Illegal.value.=不正な値:\u0020
Unknown.password.type.=不明なパスワード・タイプ:\u0020
Cannot.find.environment.variable.=環境変数が見つかりません:\u0020
Cannot.find.file.=ファイルが見つかりません:\u0020
Command.option.flag.needs.an.argument.=コマンド・オプション{0}には引数が必要です。
Warning.Different.store.and.key.passwords.not.supported.for.PKCS12.KeyStores.Ignoring.user.specified.command.value.=警告: PKCS12キーストアでは、ストアのパスワードとキーのパスワードが異なる状況はサポートされません。ユーザーが指定した{0}の値は無視します。
the.keystore.or.storetype.option.cannot.be.used.with.the.cacerts.option=-keystoreまたは-storetypeオプションは、-cacertsオプションとともに使用できません
.keystore.must.be.NONE.if.storetype.is.{0}=-storetypeが{0}の場合、-keystoreはNONEである必要があります
Too.many.retries.program.terminated=再試行が多すぎます。プログラムが終了しました
.storepasswd.and.keypasswd.commands.not.supported.if.storetype.is.{0}=-storetypeが{0}の場合、-storepasswdコマンドおよび-keypasswdコマンドはサポートされません
.keypasswd.commands.not.supported.if.storetype.is.PKCS12=-storetypeがPKCS12の場合、-keypasswdコマンドはサポートされません
.keypass.and.new.can.not.be.specified.if.storetype.is.{0}=-storetypeが{0}の場合、-keypassと-newは指定できません
if.protected.is.specified.then.storepass.keypass.and.new.must.not.be.specified=-protectedが指定されている場合、-storepass、-keypassおよび-newは指定できません
if.srcprotected.is.specified.then.srcstorepass.and.srckeypass.must.not.be.specified=-srcprotectedが指定されている場合、-srcstorepassおよび-srckeypassは指定できません
if.keystore.is.not.password.protected.then.storepass.keypass.and.new.must.not.be.specified=キーストアがパスワードで保護されていない場合、-storepass、-keypassおよび-newは指定できません
if.source.keystore.is.not.password.protected.then.srcstorepass.and.srckeypass.must.not.be.specified=ソース・キーストアがパスワードで保護されていない場合、-srcstorepassおよび-srckeypassは指定できません
Illegal.startdate.value=startdate値が無効です
Validity.must.be.greater.than.zero=妥当性はゼロより大きい必要があります
provclass.not.a.provider=%sはプロバイダではありません
provider.name.not.found=プロバイダ名"%s"が見つかりません
provider.class.not.found=プロバイダ"%s"が見つかりません
Usage.error.no.command.provided=使用エラー: コマンドが指定されていません
Source.keystore.file.exists.but.is.empty.=ソース・キーストア・ファイルは、存在しますが空です:\u0020
Please.specify.srckeystore=-srckeystoreを指定してください
Must.not.specify.both.v.and.rfc.with.list.command='list'コマンドに-vと-rfcの両方を指定することはできません
Key.password.must.be.at.least.6.characters=キーのパスワードは6文字以上である必要があります
New.password.must.be.at.least.6.characters=新規パスワードは6文字以上である必要があります
Keystore.file.exists.but.is.empty.=キーストア・ファイルは存在しますが、空です:\u0020
Keystore.file.does.not.exist.=キーストア・ファイルは存在しません:\u0020
Must.specify.destination.alias=出力先の別名を指定する必要があります
Must.specify.alias=別名を指定する必要があります
Keystore.password.must.be.at.least.6.characters=キーストアのパスワードは6文字以上である必要があります
Enter.the.password.to.be.stored.=保存するパスワードを入力してください: \u0020
Enter.keystore.password.=キーストアのパスワードを入力してください: \u0020
Enter.source.keystore.password.=ソース・キーストアのパスワードを入力してください: \u0020
Enter.destination.keystore.password.=出力先キーストアのパスワードを入力してください: \u0020
Keystore.password.is.too.short.must.be.at.least.6.characters=キーストアのパスワードが短すぎます - 6文字以上にしてください
Unknown.Entry.Type=不明なエントリ・タイプ
Entry.for.alias.alias.successfully.imported.=別名{0}のエントリのインポートに成功しました。
Entry.for.alias.alias.not.imported.=別名{0}のエントリはインポートされませんでした。
Problem.importing.entry.for.alias.alias.exception.Entry.for.alias.alias.not.imported.=別名{0}のエントリのインポート中に問題が発生しました: {1}。\n別名{0}のエントリはインポートされませんでした。
Import.command.completed.ok.entries.successfully.imported.fail.entries.failed.or.cancelled=インポート・コマンドが完了しました: {0}件のエントリのインポートが成功しました。{1}件のエントリのインポートが失敗したか取り消されました
Warning.Overwriting.existing.alias.alias.in.destination.keystore=警告: 出力先キーストア内の既存の別名{0}を上書きしています
Existing.entry.alias.alias.exists.overwrite.no.=既存のエントリの別名{0}が存在しています。上書きしますか。[いいえ]: \u0020
Too.many.failures.try.later=障害が多すぎます - 後で実行してください
Certification.request.stored.in.file.filename.=認証リクエストがファイル<{0}>に保存されました
Submit.this.to.your.CA=これをCAに提出してください
if.alias.not.specified.destalias.and.srckeypass.must.not.be.specified=別名を指定しない場合、出力先キーストアの別名およびソース・キーストアのパスワードは指定できません
The.destination.pkcs12.keystore.has.different.storepass.and.keypass.Please.retry.with.destkeypass.specified.=出力先pkcs12キーストアに、異なるstorepassおよびkeypassがあります。-destkeypassを指定して再試行してください。
Certificate.stored.in.file.filename.=証明書がファイル<{0}>に保存されました
Certificate.reply.was.installed.in.keystore=証明書応答がキーストアにインストールされました
Certificate.reply.was.not.installed.in.keystore=証明書応答がキーストアにインストールされませんでした
Certificate.was.added.to.keystore=証明書がキーストアに追加されました
Certificate.was.not.added.to.keystore=証明書がキーストアに追加されませんでした
.Storing.ksfname.=[{0}を格納中]
alias.has.no.public.key.certificate.={0}には公開キー(証明書)がありません
Cannot.derive.signature.algorithm=署名アルゴリズムを取得できません
Alias.alias.does.not.exist=別名<{0}>は存在しません
Alias.alias.has.no.certificate=別名<{0}>には証明書がありません
groupname.keysize.coexist=-groupnameと-keysizeの両方を指定できません
deprecate.keysize.for.ec=-keysizeの指定によるECキーの生成は非推奨です。かわりに"-groupname %s"を使用してください。
Key.pair.not.generated.alias.alias.already.exists=キー・ペアは生成されませんでした。別名<{0}>はすでに存在します
size.bit.alg=%1$dビット%2$s
Generating.full.keyAlgName.key.pair.and.self.signed.certificate.sigAlgName.with.a.validity.of.days.for={0}キー・ペアおよび自己署名証明書({1})を{2}日の有効性で生成しています\n\t対象: {3}
Generating.full.keyAlgName.key.pair.and.a.certificate.sigAlgName.issued.by.signerAlias.with.a.validity.of.days.for={0}キー・ペアと<{2}>によって発行された証明書({1})を{3}日間の有効性で生成しています\n\t対象: {4}
Enter.key.password.for.alias.=<{0}>のキー・パスワードを入力してください
.RETURN.if.same.as.keystore.password.=\t(キーストアのパスワードと同じ場合はRETURNを押してください): \u0020
Key.password.is.too.short.must.be.at.least.6.characters=キーのパスワードが短すぎます - 6文字以上を指定してください
Too.many.failures.key.not.added.to.keystore=障害が多すぎます - キーはキーストアに追加されませんでした
Destination.alias.dest.already.exists=出力先の別名<{0}>はすでに存在します
Password.is.too.short.must.be.at.least.6.characters=パスワードが短すぎます - 6文字以上を指定してください
Too.many.failures.Key.entry.not.cloned=障害が多すぎます。キー・エントリのクローンは作成されませんでした
key.password.for.alias.=<{0}>のキーのパスワード
No.entries.from.identity.database.added=アイデンティティ・データベースから追加されたエントリはありません
Alias.name.alias=別名: {0}
Creation.date.keyStore.getCreationDate.alias.=作成日: {0,date}
alias.keyStore.getCreationDate.alias.={0},{1,date},\u0020
alias.={0},\u0020
Entry.type.type.=エントリ・タイプ: {0}
Certificate.chain.length.=証明書チェーンの長さ:\u0020
Certificate.i.1.=証明書[{0,number,integer}]:
Certificate.fingerprint.SHA.256.=証明書のフィンガプリント(SHA-256):\u0020
Keystore.type.=キーストアのタイプ:\u0020
Keystore.provider.=キーストア・プロバイダ:\u0020
Your.keystore.contains.keyStore.size.entry=キーストアには{0,number,integer}エントリが含まれます
Your.keystore.contains.keyStore.size.entries=キーストアには{0,number,integer}エントリが含まれます
Failed.to.parse.input=入力の構文解析に失敗しました
Empty.input=入力がありません
Not.X.509.certificate=X.509証明書ではありません
alias.has.no.public.key={0}には公開キーがありません
alias.has.no.X.509.certificate={0}にはX.509証明書がありません
New.certificate.self.signed.=新しい証明書(自己署名型):
Reply.has.no.certificates=応答には証明書がありません
Certificate.not.imported.alias.alias.already.exists=証明書はインポートされませんでした。別名<{0}>はすでに存在します
Input.not.an.X.509.certificate=入力はX.509証明書ではありません
Certificate.already.exists.in.keystore.under.alias.trustalias.=証明書は、別名<{0}>のキーストアにすでに存在します
Do.you.still.want.to.add.it.no.=追加しますか。[いいえ]: \u0020
Certificate.already.exists.in.system.wide.CA.keystore.under.alias.trustalias.=証明書は、別名<{0}>のシステム規模のCAキーストア内にすでに存在します
Do.you.still.want.to.add.it.to.your.own.keystore.no.=キーストアに追加しますか。 [いいえ]: \u0020
Trust.this.certificate.no.=この証明書を信頼しますか。 [いいえ]: \u0020
New.prompt.=新規{0}:\u0020
Passwords.must.differ=パスワードは異なっている必要があります
Re.enter.new.prompt.=新規{0}を再入力してください:\u0020
Re.enter.password.=パスワードを再入力してください:\u0020
Re.enter.new.password.=新規パスワードを再入力してください:\u0020
They.don.t.match.Try.again=一致しません。もう一度実行してください
Enter.prompt.alias.name.={0}の別名を入力してください: \u0020
Enter.new.alias.name.RETURN.to.cancel.import.for.this.entry.=新しい別名を入力してください\t(このエントリのインポートを取り消す場合はRETURNを押してください): \u0020
Enter.alias.name.=別名を入力してください: \u0020
.RETURN.if.same.as.for.otherAlias.=\t(<{0}>と同じ場合はRETURNを押してください)
enter.dname.components=識別名を入力します。サブコンポーネントを空のままにする場合はドット(.)を1つ入力し、中カッコ内のデフォルト値を使用する場合は[ENTER]を押します。
What.is.your.first.and.last.name.=姓名は何ですか。
What.is.the.name.of.your.organizational.unit.=組織単位名は何ですか。
What.is.the.name.of.your.organization.=組織名は何ですか。
What.is.the.name.of.your.City.or.Locality.=都市名または地域名は何ですか。
What.is.the.name.of.your.State.or.Province.=都道府県名または州名は何ですか。
What.is.the.two.letter.country.code.for.this.unit.=この単位に該当する2文字の国コードは何ですか。
no.field.in.dname=少なくとも1つのフィールドを指定する必要があります。再度入力してください。
Is.name.correct.={0}でよろしいですか。
no=いいえ
yes=はい
y=y
.defaultValue.=\u0020 [{0}]: \u0020
Alias.alias.has.no.key=別名<{0}>にはキーがありません
Alias.alias.references.an.entry.type.that.is.not.a.private.key.entry.The.keyclone.command.only.supports.cloning.of.private.key=別名<{0}>が参照しているエントリ・タイプは秘密キー・エントリではありません。-keycloneコマンドは秘密キー・エントリのクローン作成のみをサポートします

.WARNING.WARNING.WARNING.=*****************  WARNING WARNING WARNING  *****************
Signer.d.=署名者番号%d:
Certificate.d.=証明書#%d:
Timestamp.=タイムスタンプ:
Certificate.owner.=証明書の所有者:\u0020
Not.a.signed.jar.file=署名付きJARファイルではありません
No.certificate.from.the.SSL.server=SSLサーバーからの証明書がありません

.The.integrity.of.the.information.stored.in.your.keystore.=*キーストアに保存された情報の整合性は*\n*検証されていません。整合性を検証するには*\n*キーストアのパスワードを入力する必要があります。*
.The.integrity.of.the.information.stored.in.the.srckeystore.=*ソース・キーストアに保存された情報の整合性は*\n*検証されていません。整合性を検証するには*\n*ソース・キーストアのパスワードを入力する必要があります。*

Certificate.reply.does.not.contain.public.key.for.alias.=証明書応答には、<{0}>の公開キーは含まれません
Incomplete.certificate.chain.in.reply=応答した証明書チェーンは不完全です
Top.level.certificate.in.reply.=応答したトップレベルの証明書:\n
.is.not.trusted.=... は信頼されていません。\u0020
Install.reply.anyway.no.=応答をインストールしますか。[いいえ]: \u0020
Public.keys.in.reply.and.keystore.don.t.match=応答した公開キーとキーストアが一致しません
Certificate.reply.and.certificate.in.keystore.are.identical=証明書応答とキーストア内の証明書が同じです
Failed.to.establish.chain.from.reply=応答から連鎖を確立できませんでした
n=n
Wrong.answer.try.again=応答が間違っています。もう一度実行してください
Secret.key.not.generated.alias.alias.already.exists=秘密キーは生成されませんでした。別名<{0}>はすでに存在します
Please.provide.keysize.for.secret.key.generation=秘密キーの生成時には -keysizeを指定してください

warning.not.verified.make.sure.keystore.is.correct=警告: 検証されていません。-keystoreが正しいことを確認してください。
warning.not.verified.make.sure.keystore.is.correct.or.specify.trustcacerts=警告: 検証されていません。-keystoreが正しいことを確認するか、-trustcacertsを指定してください。

Extensions.=拡張:\u0020
.Empty.value.=(空の値)
Extension.Request.=拡張リクエスト:
Unknown.keyUsage.type.=不明なkeyUsageタイプ:\u0020
Unknown.extendedkeyUsage.type.=不明なextendedkeyUsageタイプ:\u0020
Unknown.AccessDescription.type.=不明なAccessDescriptionタイプ:\u0020
Unrecognized.GeneralName.type.=認識されないGeneralNameタイプ:\u0020
This.extension.cannot.be.marked.as.critical.=この拡張はクリティカルとしてマーク付けできません。\u0020
Odd.number.of.hex.digits.found.=奇数の16進数が見つかりました:\u0020
Unknown.extension.type.=不明な拡張タイプ:\u0020
command.{0}.is.ambiguous.=コマンド{0}はあいまいです:
# 8171319: keytool should print out warnings when reading or
# generating cert/cert req using weak algorithms
the.certificate.request=証明書リクエスト
the.issuer=発行者
the.generated.secretkey=生成された秘密キー
the.generated.certificate=生成された証明書
the.generated.crl=生成されたCRL
the.generated.certificate.request=生成された証明書リクエスト
the.certificate=証明書
the.crl=CRL
the.tsa.certificate=TSA証明書
the.input=入力
reply=応答
one.in.many=%1$s #%2$d / %3$d
one.in.many1=%1$s #%2$d
one.in.many2=署名者の%1$s #%2$d
one.in.many3=署名者の%1$s #%2$d #%3$d
alias.in.cacerts=cacerts内の発行者<%s>
alias.in.keystore=発行者<%s>
with.weak=%s (弱)
with.disabled=%s (無効)
key.bit=%sキー
key.bit.weak=%sキー(弱い)
key.bit.disabled=%sキー(無効)
.PATTERN.printX509Cert.with.weak=所有者: {0}\n発行者: {1}\nシリアル番号: {2}\n有効期間の開始日: {3}終了日: {4}\n証明書のフィンガプリント:\n\t SHA1: {5}\n\t SHA256: {6}\n署名アルゴリズム名: {7}\nサブジェクト公開キー・アルゴリズム: {8}\nバージョン: {9}
PKCS.10.with.weak=PKCS #10証明書リクエスト(バージョン1.0)\nサブジェクト: %1$s\nフォーマット: %2$s\n公開キー: %3$s\n署名アルゴリズム: %4$s\n
verified.by.s.in.s.weak=%2$s内の%1$sにより%3$sで検証されました
whose.sigalg.disabled=%1$sは%2$s署名アルゴリズムを使用しており、これはセキュリティ・リスクとみなされ、無効化されています。
whose.sigalg.usagesignedjar=%1$sは%2$s署名アルゴリズムを使用しており、これはセキュリティ・リスクとみなされます。%3$sの後でJARに署名するために使用することはできません。
Unable.to.parse.denyAfter.string.in.exception.message=例外メッセージのdenyAfter日付文字列を解析できません
whose.sigalg.weak=%1$sは%2$s署名アルゴリズムを使用しており、これはセキュリティ・リスクとみなされます。
whose.key.disabled=%1$sは%2$sを使用しており、これはセキュリティ・リスクとみなされ、無効化されています。
whose.key.weak=%1$sは%2$sを使用しており、これはセキュリティ・リスクとみなされます。今後の更新では無効になります。
jks.storetype.warning=%1$sキーストアは独自の形式を使用しています。"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12"を使用する業界標準の形式であるPKCS12に移行することをお薦めします。
migrate.keystore.warning="%1$s"が%4$sに移行されました。%2$sキーストアは"%3$s"としてバックアップされます。
backup.keystore.warning=元のキーストア"%1$s"は"%3$s"としてバックアップされます...
importing.keystore.status=キーストア%1$sを%2$sにインポートしています...
keyalg.option.missing.error=-keyalgオプションを指定する必要があります。
showinfo.no.option=-showinfoのオプションがありません。"keytool -showinfo -tls"を試してください。
