#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file contains error and warning messages related to XML Schema
# The messages are arranged in key and value tuples in a ListResourceBundle.

        BadMessageKey = Die zum Meldungsschlüssel gehörige Fehlermeldung kann nicht gefunden werden.
        FormatFailed = Beim Formatieren der folgenden Meldung ist ein interner Fehler aufgetreten:\n

# For internal use

        Internal-Error = Interner Fehler: {0}.
        dt-whitespace = Leerstellen-Facet-Wert ist nicht für Vereinigungsmenge simpleType ''{0}'' verfügbar
        GrammarConflict = Eine vom Grammatikpool des Benutzers zurückgegebene Grammatik steht im Konflikt mit einer anderen Grammatik.

# Identity constraints

        AbsentKeyValue = cvc-identity-constraint.4.2.1.a: Element "{0}" hat keinen Wert für den Schlüssel "{1}".
        DuplicateField = Doppelte Übereinstimmung in Geltungsbereich für Feld ''{0}''.
        DuplicateKey = cvc-identity-constraint.4.2.2: Doppelter Schlüsselwert [{0}] für Identity Constraint "{2}" des Elements "{1}"deklariert.
        DuplicateUnique = cvc-identity-constraint.4.1: Doppelter eindeutiger Wert [{0}] für Identity Constraint "{2}"des Elements "{1}" deklariert.
        FieldMultipleMatch = cvc-identity-constraint.3: Feld "{0}" von Identity Constraint "{1}" entspricht mehreren Werten im Geltungsbereich seines Selektors. Felder müssen eindeutigen Werten entsprechen.
        FixedDiffersFromActual = Content dieses Elements entspricht nicht dem Wert des 'fixed'-Attributs in der Elementdeklaration im Schema.
        KeyMatchesNillable = cvc-identity-constraint.4.2.3: Element "{0}" hat den Schlüssel "{1}", der einem Element entspricht, bei dem "nillable" auf "true" gesetzt wurde.
        KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: Nicht genügend Werte angegeben für <key name="{1}"> Identity Constraint für Element "{0}".
        KeyNotFound = cvc-identity-constraint.4.3: Schlüssel "{0}" mit Wert "{1}" nicht gefunden für Identity Constraint des Elements "{2}".
        KeyRefOutOfScope = Identity Constraint-Fehler: Identity Constraint ''{0}'' hat eine keyref, die zu einem Key- oder Unique-Constraint außerhalb des Geltungsbereichs verweist.
        KeyRefReferNotFound = Schlüsselreferenzdeklaration ''{0}'' verweist auf einen unbekannten Schlüssel mit dem Namen ''{1}''.
        UnknownField = Interner Identity Constraint-Fehler. Unbekanntes Feld "{0}" für Identity Constraint "{2}", das für Element "{1}" angegeben wurde.

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.

#validation (3.X.4)

        cvc-attribute.3 = cvc-attribute.3: Wert ''{2}'' des Attributs ''{1}'' bei Element ''{0}'' hat keinen gültigen Typ ''{3}''.
        cvc-attribute.4 = cvc-attribute.4: Wert ''{2}'' des Attributs ''{1}'' bei Element ''{0}'' hat keinen gültigen festen '{'value constraint'}'. Attribute muss den Wert ''{3}'' haben.
        cvc-complex-type.2.1 = cvc-complex-type.2.1: Element ''{0}'' darf kein Zeichen- oder Elementinformationselement [untergeordnete Elemente] haben, da der Contenttyp des Typs leer ist.
        cvc-complex-type.2.2 = cvc-complex-type.2.2: Element ''{0}'' darf kein Element [untergeordnete Elemente] haben, und der Wert muss gültig sein.
        cvc-complex-type.2.3 = cvc-complex-type.2.3: Element ''{0}'' darf keine Zeichen [untergeordnete Elemente] haben, da der Contenttyp des Typs ''element-only'' ist.
        cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: Ungültiger Content wurde beginnend mit Element ''{0}'' gefunden. ''{1}'' wird erwartet.
        cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: Content des Elements ''{0}'' ist nicht vollständig. ''{1}'' wird erwartet.
        cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: Übereinstimmungsplatzhalter ist streng, aber es kann keine Deklaration für Element ''{0}'' gefunden werden.
        cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: Ungültiger Content wurde beginnend mit Element ''{0}'' gefunden. An dieser Stelle wird kein untergeordnetes Element erwartet.
        cvc-complex-type.2.4.d.1 = cvc-complex-type.2.4.d: Ungültiger Content wurde beginnend mit Element ''{0}'' gefunden. An dieser Stelle wird kein untergeordnetes Element ''{1}'' erwartet.
        cvc-complex-type.2.4.e = cvc-complex-type.2.4.e: "{0}" darf maximal "{2}"-mal in der aktuellen Abfolge auftreten. Dieser Grenzwert wurde überschritten. An dieser Stelle wird eines von "{1}" erwartet.
        cvc-complex-type.2.4.f = cvc-complex-type.2.4.e: "{0}" darf maximal "{1}"-mal in der aktuellen Abfolge auftreten. Dieser Grenzwert wurde überschritten. An dieser Stelle wird kein untergeordnetes Element erwartet.
        cvc-complex-type.2.4.g = cvc-complex-type.2.4.g: Ungültigen Inhalt gefunden, der mit Element "{0}" beginnt. "{1}" soll erwartungsgemäß mindestens "{2}"-mal in der aktuellen Abfolge auftreten. Eine weitere Instanz ist erforderlich, um diesen Constraint zu erfüllen.
        cvc-complex-type.2.4.h = cvc-complex-type.2.4.h: Ungültigen Inhalt gefunden, der mit Element "{0}" beginnt. "{1}" soll erwartungsgemäß mindestens "{2}"-mal in der aktuellen Abfolge auftreten. "{3}" weitere Instanzen sind erforderlich, um diesen Constraint zu erfüllen.
        cvc-complex-type.2.4.i = cvc-complex-type.2.4.i: Der Inhalt von Element "{0}" ist nicht vollständig. "{1}" soll erwartungsgemäß mindestens "{2}"-mal auftreten. Eine weitere Instanz ist erforderlich, um diesen Constraint zu erfüllen.
        cvc-complex-type.2.4.j = cvc-complex-type.2.4.j: Der Inhalt von Element "{0}" ist nicht vollständig. "{1}" soll erwartungsgemäß mindestens "{2}"-mal auftreten. "{3}" weitere Instanzen sind erforderlich, um diesen Constraint zu erfüllen.
        cvc-complex-type.3.1 = cvc-complex-type.3.1: Wert ''{2}'' des Attributs ''{1}'' des Elements ''{0}'' ist ungültig in Bezug auf die entsprechende Attributverwendung. Attribut ''{1}'' hat den festen Wert ''{3}''.
        cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: Element ''{0}'' hat keinen Attributplatzhalter für Attribut ''{1}''.
        cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: Attribut ''{1}'' darf nicht in Element ''{0}'' vorkommen.
        cvc-complex-type.4 = cvc-complex-type.4: Attribut ''{1}'' muss in Element ''{0}'' vorkommen.
        cvc-complex-type.4_ns = cvc-complex-type.4: Attribut "{1}" von Namespace "{2}" muss in Element "{0}" vorkommen.
        cvc-complex-type.5.1 = cvc-complex-type.5.1: In Element ''{0}'' ist Attribut ''{1}'' ein Platzhalter. Es ist aber bereits ein Platzhalter ''{2}'' vorhanden. Nur ein Platzhalter ist zulässig.
        cvc-complex-type.5.2 = cvc-complex-type.5.2: In Element ''{0}'' ist Attribut ''{1}'' ein Platzhalter. Es ist aber bereits ein Attribut ''{2}'' vorhanden, das von einer ID unter den '{'attribute uses'}' abgeleitet wurde.
        cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: ''{0}'' ist kein gültiger Wert für ''{1}''.
        cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: ''{0}'' ist kein gültiger Wert des Listentyps ''{1}''.
        cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: ''{0}'' ist kein gültiger Wert des Vereinigungsmengentyps ''{1}''.
        cvc-elt.1.a = cvc-elt.1.a: Deklaration des Elements "{0}" kann nicht gefunden werden.
        cvc-elt.1.b = cvc-elt.1.b: Der Name des Elements stimmt nicht mit dem Namen der Elementdeklaration überein. Gefunden: "{0}". Erwartet: "{1}".
        cvc-elt.2 = cvc-elt.2: Wert von '{'abstract'}' in der Elementdeklaration für ''{0}'' muss ''false'' sein.
        cvc-elt.3.1 = cvc-elt.3.1: Attribut ''{1}'' darf nicht in Element ''{0}'' vorkommen, da die die Eigenschaft '{'nillable'}' von ''{0}'' ''false'' ist.
        cvc-elt.3.2.1 = cvc-elt.3.2.1: Element ''{0}'' darf keine Zeichen- oder Elementinformationen [untergeordnete Elemente] haben, da ''{1}'' angegeben wurde.
        cvc-elt.3.2.2 = cvc-elt.3.2.2: Es darf kein fester '{'value constraint'}' für Element ''{0}'' vorhanden sein, da ''{1}'' angegeben wurde.
        cvc-elt.4.1 = cvc-elt.4.1: Wert ''{2}'' des Attributs ''{1}'' von Element ''{0}'' ist kein gültiger QName.
        cvc-elt.4.2 = cvc-elt.4.2: ''{1}'' kann nicht als Typdefinition für Element ''{0}'' aufgelöst werden.
        cvc-elt.4.3 = cvc-elt.4.3: Typ ''{1}'' wurde nicht auf gültige Weise von der Typdefinition ''{2}'' des Elements ''{0}'' abgeleitet.
        cvc-elt.5.1.1 = cvc-elt.5.1.1: '{'value constraint'}' ''{2}'' des Elements ''{0}'' ist kein gültiger Standardwert für Typ ''{1}''.
        cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: Element ''{0}'' darf keine Elementinformationselemente [untergeordnete Elemente] haben.
        cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: Wert ''{1}'' des Elements ''{0}'' stimmt nicht mit dem festen '{'value constraint'}'-Wert ''{2}'' überein.
        cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: Wert ''{1}'' des Elements ''{0}'' stimmt nicht mit dem '{'value constraint'}'-Wert ''{2}'' überein.
        cvc-enumeration-valid = cvc-enumeration-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf Enumeration ''{1}''. Er muss ein Wert aus der Enumeration sein.
        cvc-fractionDigits-valid = cvc-fractionDigits-valid: Wert ''{0}'' enthält {1} Bruchziffern, die Anzahl an Bruchziffern wurde aber auf {2} beschränkt.
        cvc-id.1 = cvc-id.1: Kein ID/IDREF-Binding für IDREF ''{0}'' vorhanden.
        cvc-id.2 = cvc-id.2: ID-Wert ''{0}'' kommt mehrmals vor.
        cvc-id.3 = cvc-id.3: Ein Feld von Identity Constraint ''{0}'' entsprach Element ''{1}''. Dieses Element hat aber keinen Simple Type.
        cvc-length-valid = cvc-length-valid: Wert ''{0}'' mit Länge = ''{1}'' ist nicht Facet-gültig in Bezug auf die Länge ''{2}'' für Typ ''{3}''.
        cvc-maxExclusive-valid = cvc-maxExclusive-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf maxExclusive ''{1}'' für Typ ''{2}''.
        cvc-maxInclusive-valid = cvc-maxInclusive-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf maxInclusive ''{1}'' für Typ ''{2}''.
        cvc-maxLength-valid = cvc-maxLength-valid: Wert ''{0}'' mit Länge = ''{1}'' ist nicht Facet-gültig in Bezug auf maxLength ''{2}'' für Typ ''{3}''.
        cvc-minExclusive-valid = cvc-minExclusive-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf minExclusive ''{1}'' für Typ ''{2}''.
        cvc-minInclusive-valid = cvc-minInclusive-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf minInclusive ''{1}'' für Typ ''{2}''.
        cvc-minLength-valid = cvc-minLength-valid: Wert ''{0}'' mit Länge = ''{1}'' ist nicht Facet-gültig in Bezug auf minLength ''{2}'' für Typ ''{3}''.
        cvc-pattern-valid = cvc-pattern-valid: Wert ''{0}'' ist nicht Facet-gültig in Bezug auf Muster ''{1}'' für Typ ''{2}''.
        cvc-totalDigits-valid = cvc-totalDigits-valid: Wert ''{0}'' enthält {1} Gesamtziffern, die Anzahl an Gesamtziffern wurde aber auf {2} beschränkt.
        cvc-type.1 = cvc-type.1: Die Typdefinition "{0}" wurde nicht gefunden.
        cvc-type.2 = cvc-type.2: Typdefinition kann nicht abstrakt für Element {0} sein.
        cvc-type.3.1.1 = cvc-type.3.1.1: Element ''{0}'' ist Simple Type und kann daher keine Attribute haben, mit Ausnahme der Attribute, deren Namespace-Name mit ''http://www.w3.org/2001/XMLSchema-instance'' identisch ist und deren [lokaler Name] ''type'', ''nil'', ''schemaLocation'' oder ''noNamespaceSchemaLocation'' lautet. Es wurde allerdings das Attribut ''{1}'' gefunden.
        cvc-type.3.1.2 = cvc-type.3.1.2: Element ''{0}'' ist Simple Type und darf daher keine Elementinformationselemente [untergeordnete Elemente] haben.
        cvc-type.3.1.3 = cvc-type.3.1.3: Wert ''{1}'' des Elements ''{0}'' ist ungültig.

#schema valid (3.X.3)

        schema_reference.access = schema_reference: Schemadokument ''{0}'' konnte nicht gelesen werden, weil der ''{1}''-Zugriff wegen der von der Eigenschaft accessExternalSchema festgelegten Einschränkung nicht zulässig ist.
        schema_reference.4 = schema_reference.4: Schemadokument ''{0}'' konnte nicht gelesen werden, da 1) das Dokument nicht gefunden werden konnte; 2) das Dokument nicht gelesen werden konnte; 3) das Root-Element des Dokuments nicht <xsd:schema> ist.
        src-annotation = src-annotation: <annotation>-Elemente können nur <appinfo>- und <documentation>-Elemente enthalten, aber es wurde ''{0}'' gefunden.
        src-attribute.1 = src-attribute.1: Die Eigenschaften ''default'' und ''fixed'' können nicht beide in der Attributdeklaration ''{0}'' vorhanden sein. Verwenden Sie nur eine dieser Eigenschaften.
        src-attribute.2 = src-attribute.2: : Eigenschaft ''default'' ist im Attribut ''{0}'' vorhanden. Daher muss der Wert von ''use'' ''optional'' lauten.
        src-attribute.3.1 = src-attribute.3.1: 'ref' oder 'name' muss in einer lokalen Attributdeklaration vorhanden sein.
        src-attribute.3.2 = src-attribute.3.2: Content muss mit (annotation?) für die Attributreferenz ''{0}'' übereinstimmen.
        src-attribute.4 = src-attribute.4: Attribut ''{0}'' hat sowohl das Attribut ''type'' als auch ein anonymes untergeordnetes Element ''simpleType''. Nur eins davon ist für Attribute zulässig.
        src-attribute_group.2 = src-attribute_group.2: Schnittmenge von Platzhaltern kann nicht für Attributgruppe ''{0}'' ausgedrückt werden.
        src-attribute_group.3 = src-attribute_group.3: Zyklische Definitionen für Attributgruppe ''{0}'' ermittelt. Das rekursive Folgen von Attributgruppenreferenzen führt schließlich zu sich selbst zurück.
        src-ct.1 = src-ct.1: Darstellungsfehler bei Complex Type-Definition für Typ ''{0}''. Wenn <complexContent> verwendet wird, muss der Basistyp ein complexType sein. ''{1}'' ist ein simpleType.
        src-ct.2.1 = src-ct.2.1: Darstellungsfehler bei Complex Type-Definition für Typ ''{0}''. Wenn <simpleContent> verwendet wird, muss der Basistyp ein complexType sein, dessen Contenttyp ''simple'' ist, oder, wenn eine Einschränkung angegeben wurde, ein ''complex''-Typ mit gemischtem Content und einem Partikel, das geleert werden kann, oder, wenn eine Erweiterung angegeben wurde, ein ''simple''-Typ. ''{1}'' erfüllt keine dieser Bedingungen.
        src-ct.2.2 = src-ct.2.2: Darstellungsfehler bei Complex Type-Definition für Typ ''{0}''. Wenn ein complexType mit simpleContent einen complexType mit gemischtem Content und einem Partikel, das geleert werden kann, einschränkt, muss ein <simpleType> in den untergeordneten Elementen von <restriction> enthalten sein.
        src-ct.4 = src-ct.4: Darstellungsfehler bei Complex Type-Definition für Typ ''{0}''. Die Schnittmenge der Platzhalter kann nicht ausgedrückt werden.
        src-ct.5 = src-ct.5: Darstellungsfehler bei Complex Type-Definition für Typ ''{0}''. Die Vereinigungsmenge der Platzhalter kann nicht ausgedrückt werden.
        src-element.1 = src-element.1: Die Eigenschaften ''default'' und ''fixed'' können nicht beide in der Elementdeklaration ''{0}'' vorhanden sein. Verwenden Sie nur eine dieser Eigenschaften.
        src-element.2.1 = src-element.2.1: : 'ref' oder 'name' muss in einer lokalen Elementdeklaration vorhanden sein.
        src-element.2.2 = src-element.2.2: Da ''{0}'' das Attribut ''ref'' enthält, muss der Content (annotation?) entsprechen. Es wurde allerdings ''{1}'' gefunden.
        src-element.3 = src-element.3: Element ''{0}'' hat sowohl das Attribut ''type'' als auch ein untergeordnetes Element ''anonymous type''. Nur eins davon ist für Elemente zulässig.
        src-import.1.1 = src-import.1.1: Namespace-Attribut ''{0}'' eines <import>-Elementinformationselements darf nicht mit dem targetNamespace des Schemas identisch sein, in dem es vorhanden ist.
        src-import.1.2 = src-import.1.2: Wenn das Namespace-Attribut nicht bei einem <import>-Elementinformationselement vorhanden ist, muss das einschließende Schema einen targetNamespace haben.
        src-import.2 = src-import.2: Das Root-Element des Dokuments ''{0}'' muss den Namespace-Namen ''http://www.w3.org/2001/XMLSchema'' und den lokalen Namen ''schema'' haben.
        src-import.3.1 = src-import.3.1: Namespace-Attribut ''{0}'' eines <import>-Elementinformationselements muss mit dem targetNamespace-Attribut ''{1}'' des importierten Dokuments identisch sein.
        src-import.3.2 = src-import.3.2: Es wurde ein <import>-Elementinformationselement ohne Namespace-Attribut gefunden. Daher kann das importierte Dokument kein targetNamespace-Attribut haben. targetNamespace ''{1}'' wurde aber im importierten Dokument gefunden.
        src-include.1 = src-include.1: Das Root-Element des Dokuments ''{0}'' muss den Namespace-Namen ''http://www.w3.org/2001/XMLSchema'' und den lokalen Namen ''schema'' haben.
        src-include.2.1 = src-include.2.1: targetNamespace des referenzierten Schemas, derzeit ''{1}'', muss mit dem im umfassenden Schema, derzeit ''{0}'', identisch sein.
        src-redefine.2 = src-redefine.2: Das Root-Element des Dokuments ''{0}'' muss den Namespace-Namen ''http://www.w3.org/2001/XMLSchema'' und den lokalen Namen ''schema'' haben.
        src-redefine.3.1 = src-redefine.3.1: targetNamespace des referenzierten Schemas, derzeit ''{1}'', muss mit dem im neu definierenden Schema, derzeit ''{0}'', identisch sein.
        src-redefine.5.a.a = src-redefine.5.a.a: Keine untergeordneten Nicht-Annotationselemente von <simpleType> gefunden. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen müssen <restriction>-Nachkommen mit 'base'-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.a.b = src-redefine.5.a.b: ''{0}'' ist kein gültiges untergeordnetes Element. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen müssen <restriction>-Nachkommen mit ''base''-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.a.c = src-redefine.5.a.c: ''{0}'' hat kein ''base''-Attribut, das auf das neu definierte Element ''{1}'' verweist. Untergeordnete <simpleType>-Elemente von <redefine>-Elementen müssen <restriction>-Nachkommen mit ''base''-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.a = src-redefine.5.b.a: Keine untergeordneten Nicht-Annotationselemente von <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen müssen <extension>- oder <restriction>-Nachkommen mit 'base'-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.b = src-redefine.5.b.b: Keine untergeordneten Nicht-Annotationselemente der zweiten Generation von <complexType> gefunden. Untergeordnete <complexType>-Elemente von <redefine>-Elementen müssen <extension>- oder <restriction>-Nachkommen mit 'base'-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.c = src-redefine.5.b.c: ''{0}'' ist kein gültiges untergeordnetes Element der zweiten Generation. Untergeordnete <complexType>-Elemente von <redefine>-Elementen müssen <extension>- oder <restriction>-Nachkommen mit ''base''-Attributen haben, die auf sich selbst verweisen.
        src-redefine.5.b.d = src-redefine.5.b.d: ''{0}'' hat kein ''base''-Attribut, das auf das neu definierte Element ''{1}'' verweist. Untergeordnete <complexType>-Elemente von <redefine>-Elementen müssen <extension>- oder <restriction>-Nachkommen mit ''base''-Attributen haben, die auf sich selbst verweisen.
        src-redefine.6.1.1 = src-redefine.6.1.1: Wenn ein untergeordnetes Gruppenelement eines <redefine>-Elements eine Gruppe enthält, die auf sich selbst verweist, muss genau 1 vorhanden sein. Hier sind ''{0}'' vorhanden.
        src-redefine.6.1.2 = src-redefine.6.1.2: Bei Gruppe ''{0}'', die eine Referenz zu einer Gruppe enthält, die neu definiert wird, muss ''minOccurs'' = ''maxOccurs'' = 1 gelten.
        src-redefine.6.2.1 = src-redefine.6.2.1: Keine Gruppe im neu definierten Schema hat einen Namen, der ''{0}'' entspricht.
        src-redefine.6.2.2 = src-redefine.6.2.2: Gruppe ''{0}'' schränkt die Gruppe, die neu definiert wird, nicht ordnungsgemäß ein. Verletzter Constraint: ''{1}''.
        src-redefine.7.1 = src-redefine.7.1: Wenn ein untergeordnetes attributeGroup-Element eines <redefine>-Elements eine attributeGroup enthält, die auf sich selbst verweist, muss genau 1 vorhanden sein. Hier sind {0} vorhanden.
        src-redefine.7.2.1 = src-redefine.7.2.1: Keine attributeGroup im neu definierten Schema hat einen Namen, der ''{0}'' entspricht.
        src-redefine.7.2.2 = src-redefine.7.2.2: attributeGroup ''{0}'' schränkt die attributeGroup, die neu definiert wird, nicht ordnungsgemäß ein. Verletzter Constraint: ''{1}''.
        src-resolve = src-resolve: Name ''{0}'' kann nicht als ''{1}''-Komponente aufgelöst werden.
        src-resolve.4.1 = src-resolve.4.1: Fehler beim Auflösen von Komponente ''{2}''. Es wurde ermittelt, dass ''{2}'' keinen Namespace hat, aber Komponenten ohne Ziel-Namespace können nicht aus Schemadokument ''{0}'' referenziert werden. Wenn ''{2}'' einen Namespace haben soll, muss möglicherweise ein Präfix angegeben werden. Wenn ''{2}'' keinen Namespace haben soll, muss ein ''import'' ohne ''namespace''-Attribut zu ''{0}'' hinzugefügt werden.
        src-resolve.4.2 = src-resolve.4.2: Fehler beim Auflösen von Komponente ''{2}''. Es wurde ermittelt, dass ''{2}'' in Namespace ''{1}'' vorhanden ist, aber Komponenten aus diesem Namespace können nicht aus Schemadokument ''{0}'' referenziert werden. Wenn dies der falsche Namespace ist, muss möglicherweise das Präfix von ''{2}'' geändert werden. Wenn dies der richtige Namespace ist, muss ein entsprechendes ''import''-Tag zu ''{0}'' hinzugefügt werden.
        src-simple-type.2.a = src-simple-type.2.a: Es wurde ein <restriction>-Element gefunden, das sowohl ein 'base'-[Attribut] als auch ein <simpleType>-Element in seinen [untergeordneten Elementen] enthält. Nur eines davon ist zulässig.
        src-simple-type.2.b = src-simple-type.2.b: Es wurde ein <restriction>-Element gefunden, das weder ein 'base'-[Attribut] noch ein <simpleType>-Element in seinen [untergeordneten Elementen] enthält. Eines davon ist erforderlich.
        src-simple-type.3.a = src-simple-type.3.a: Es wurde ein <list>-Element gefunden, das sowohl ein 'itemType'-[Attribut] als auch ein <simpleType>-Element in seinen [untergeordneten Elementen] enthält. Nur eines davon ist zulässig.
        src-simple-type.3.b = src-simple-type.3.b: Es wurde ein <list>-Element gefunden, das weder ein 'itemType'-[Attribut] noch ein <simpleType>-Element in seinen [untergeordneten Elementen] enthält. Eines davon ist erforderlich.
        src-single-facet-value = src-single-facet-value: Facet ''{0}'' ist mehrmals definiert.
        src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: Ein <union>-Element muss entweder ein nicht leeres memberTypes-[Attribut] oder mindestens ein <simpleType>-Element in seinen [untergeordneten Elementen] enthalten.

#constraint valid (3.X.6)

        ag-props-correct.2 = ag-props-correct.2: Fehler bei Attributgruppe ''{0}''. Es wurden doppelte Attributverwendungen mit demselben Namen und Ziel-Namespace angegeben. Name der doppelten Attributverwendung lautet ''{1}''.
        ag-props-correct.3 = ag-props-correct.3: Fehler bei Attributgruppe ''{0}''. Zwei Attributdeklarationen (''{1}'' und ''{2}'') haben Typen, die aus ID abgeleitet wurden.
        a-props-correct.2 = a-props-correct.2: Ungültiger Werte-Constraint-Wert ''{1}'' in Attribut ''{0}''.
        a-props-correct.3 = a-props-correct.3: Bei Attribut ''{0}'' kann ''fixed'' oder ''default'' nicht verwendet werden, da die '{'type definition'}' des Attributs ''ID'' ist oder aus ID abgeleitet wurde.
        au-props-correct.2 = au-props-correct.2: In der Attributdeklaration von ''{0}'' wurde der feste Wert ''{1}'' angegeben. Wenn also die Attributverwendung, die auf ''{0}'' verweist, auch einen '{'value constraint'}' hat, muss sie fest sein, und der Wert muss ''{1}'' lauten.
        cos-all-limited.1.2 = cos-all-limited.1.2: Eine 'all'-Modellgruppe muss in einem Partikel mit '{'min occurs'}' = '{'max occurs'}' = 1 vorkommen, und dieses Partikel muss zu einem Paar gehören, das den '{'content type'}' einer Complex Type-Definition darstellt.
        cos-all-limited.2 = cos-all-limited.2: '{'max occurs'}' eines Elements in einer ''all''-Modellgruppe muss 0 oder 1 sein. Der Wert ''{0}'' für Element ''{1}'' ist ungültig.
        cos-applicable-facets = cos-applicable-facets: Facet ''{0}'' ist nicht zulässig für Typ {1}.
        cos-ct-extends.1.1 = cos-ct-extends.1.1: Typ ''{0}'' wurde durch die Erweiterung von Typ ''{1}'' abgeleitet. Das Attribut ''final'' von ''{1}'' lässt die Ableitung durch Erweiterung aber nicht zu.
        cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: Der Contenttyp eines abgeleiteten Typs und der seiner Basis müssen beide ''mixed'' oder ''element-only'' sein. Typ ''{0}'' ist ''element only'', aber sein Basistyp nicht.
        cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: Der Contenttyp eines abgeleiteten Typs und der seiner Basis müssen beide ''mixed'' oder ''element-only'' sein. Typ ''{0}'' ist ''mixed'', aber sein Basistyp nicht.
        cos-element-consistent = cos-element-consistent: Fehler bei Typ ''{0}''. Mehrere Elemente mit Namen ''{1}'' und unterschiedlichen Typen kommen in der Modellgruppe vor.
        cos-list-of-atomic = cos-list-of-atomic: In der Definition von Listentyp ''{0}'' ist Typ ''{1}'' ein ungültiger Listenelementtyp, da er nicht atomar ist (''{1}'' ist entweder ein Listentyp oder ein Vereinigungsmengentyp, der eine Liste enthält).
        cos-nonambig = cos-nonambig: {0} und {1} (oder Elemente aus ihrer Substitutionsgruppe) verletzen ''Unique Particle Attribution''. Bei der Validierung für dieses Schema würde eine Mehrdeutigkeit für diese beiden Partikel erstellt.
        cos-particle-restrict.a = cos-particle-restrict.a: Abgeleitetes Partikel ist leer, und die Basis kann nicht geleert werden.
        cos-particle-restrict.b = cos-particle-restrict.b: Basispartikel ist leer, aber das abgeleitete Partikel ist nicht leer.
        cos-particle-restrict.2 = cos-particle-restrict.2: Unzulässige Partikeleinschränkung: ''{0}''.
        cos-st-restricts.1.1 = cos-st-restricts.1.1: Typ ''{1}'' ist atomar. Daher muss die zugehörige '{'base type definition'}' ''{0}'' eine atomare Simple Type-Definition oder ein integrierter primitiver Datentyp sein.
        cos-st-restricts.2.1 = cos-st-restricts.2.1: In der Definition von Listentyp ''{0}'' ist Typ ''{1}'' ein ungültiger Elementtyp, da er entweder ein Listentyp oder ein Vereinigungsmengentyp ist, der eine Liste enthält.
        cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: Komponente '{'final'}' der '{'item type definition'}' ''{0}'' enthält ''list''. Dies bedeutet, dass ''{0}'' nicht als Elementtyp für Listentyp ''{1}'' verwendet werden kann.
        cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: Komponente '{'final'}' der '{'member type definitions'}' ''{0}'' enthält ''union''. Dies bedeutet, dass ''{0}'' nicht als Mitgliedstyp für Vereinigungsmengentyp ''{1}'' verwendet werden kann.
        cos-valid-default.2.1 = cos-valid-default.2.1: Element ''{0}'' hat einen Werte-Constraint und muss ein Misch- oder ein einfaches Contentmodell haben.
        cos-valid-default.2.2.2 = cos-valid-default.2.2.2: Da Element ''{0}'' einen '{'value constraint'}' hat und seine Typdefinition einen gemischten '{'content type'}' hat, muss das Partikel des '{'content type'}' geleert werden können.
        c-props-correct.2 = c-props-correct.2: Kardinalität von Feldern für keyref ''{0}'' und Schlüssel ''{1}'' muss sich gegenseitig entsprechen.
        ct-props-correct.3 = ct-props-correct.3: Zyklische Definitionen für Complex Type ''{0}'' ermittelt. Dies bedeutet, dass ''{0}'' in der eigenen Typhierarchie enthalten ist. Dies ist ein Fehler.
        ct-props-correct.4 = ct-props-correct.4: Fehler bei Typ ''{0}''. Es wurden doppelte Attributverwendungen mit demselben Namen und Ziel-Namespace angegeben. Name der doppelten Attributverwendung lautet ''{1}''.
        ct-props-correct.5 = ct-props-correct.5: Fehler bei Typ ''{0}''. Zwei Attributdeklarationen (''{1}'' und ''{2}'') haben Typen, die aus ID abgeleitet wurden.
        derivation-ok-restriction.1 = derivation-ok-restriction.1: Typ ''{0}'' wurde durch die Einschränkung von Typ ''{1}'' abgeleitet. ''{1}'' hat aber eine '{'final'}'-Eigenschaft, die die Ableitung durch Einschränkung nicht zulässt.
        derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat den ''use''-Wert ''{2}'', der nicht mit dem Wert von ''required'' in einer übereinstimmenden Attributverwendung im Basistyp konsistent ist.
        derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.1.2: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat den Typ ''{2}'', der nicht auf gültige Weise von ''{3}'' abgeleitet wurde, dem Typ der übereinstimmenden Attributverwendung im Basistyp.
        derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat einen effektiven Werte-Constraint, der nicht fest ist, und der effektive Werte-Constraint der übereinstimmenden Attributverwendung im Basistyp ist fest.
        derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat einen effektiven festen Werte-Constraint mit dem Wert ''{2}''. Dies ist nicht mit dem Wert ''{3}'' für den festen effektiven Werte-Constraint der übereinstimmenden Attributverwendung im Basistyp konsistent.
        derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat keine übereinstimmende Attributverwendung in der Basis, und der Basistyp hat kein Platzhalterattribut.
        derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: Fehler bei Typ ''{0}''. Attributverwendung ''{1}'' in diesem Typ hat keine übereinstimmende Attributverwendung in der Basis, und der Platzhalter im Basistyp lässt den Namespace ''{2}'' dieser Attributverwendung nicht zu.
        derivation-ok-restriction.3 = derivation-ok-restriction.3: Fehler bei Typ ''{0}''. Bei Attributverwendung ''{1}'' im Basistyp ist REQUIRED ''true'', aber es ist keine übereinstimmende Attributverwendung im abgeleiteten Typ vorhanden.
        derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: Fehler bei Typ ''{0}''. Ableitung hat einen Attributplatzhalter, aber die Basis hat keinen.
        derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: Fehler bei Typ ''{0}''. Platzhalter in der Ableitung ist keine gültige Platzhalter-Teilmenge des Platzhalters in der Basis.
        derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: Fehler bei Typ ''{0}''. Prozesscontent des Platzhalters in der Ableitung ({1}) ist schwächer als der Content in der Basis ({2}).
        derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: Fehler bei Typ ''{0}''. Einfacher Contenttyp dieses Typs ''{1}'' ist keine gültige Einschränkung des einfachen Contenttyps der Basis ''{2}''.
        derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: Fehler bei Typ ''{0}''. Contenttyp dieses Typs ist leer, aber der Contenttyps der Basis ''{1}'' ist nicht leer oder kann nicht geleert werden.
        derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: Fehler bei Typ ''{0}''. Contenttyp dieses Typs ist ''mixed'', aber der Contenttyps der Basis ''{1}'' nicht.
        derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: Fehler bei Typ ''{0}''. Partikel des Typs ist keine gültige Einschränkung des Partikels der Basis.
        enumeration-required-notation = enumeration-required-notation: NOTATION-Typ ''{0}'', der von {2} ''{1}'' verwendet wird, muss einen Enumerations-Facet-Wert haben, der die von diesem Typ verwendeten Notationselemente angibt.
        enumeration-valid-restriction = enumeration-valid-restriction: Enumerationswert ''{0}'' ist nicht im Wertebereich des Basistyps {1} vorhanden.
        e-props-correct.2 = e-props-correct.2: Ungültiger Werte-Constraint-Wert ''{1}'' in Element ''{0}''.
        e-props-correct.4 = e-props-correct.4: '{'type definition'}' von Element ''{0}'' wurde nicht auf gültige Weise von der '{'type definition'}' von substitutionHead ''{1}'' abgeleitet, oder die '{'substitution group exclusions'}'-Eigenschaft von ''{1}'' lässt diese Ableitung nicht zu.
        e-props-correct.5 = e-props-correct.5: '{'value constraint'}' darf nicht bei Element ''{0}'' vorhanden sein, da die '{'type definition'}' des Elements oder der '{'content type'}' der '{'type definition'}' ID ist oder von ID abgeleitet wurde.
        e-props-correct.6 = e-props-correct.6: Zyklische Substitutionsgruppe für Element ''{0}'' ermittelt.
        fractionDigits-valid-restriction = fractionDigits-valid-restriction: In der Definition von {2} ist der Wert ''{0}'' für Facet ''fractionDigits'' ungültig, da er <= dem Wert für ''fractionDigits'' sein muss, der in einem der Vorgängertypen auf ''{1}'' gesetzt wurde.
        fractionDigits-totalDigits = fractionDigits-totalDigits: In der Definition von {2} ist der Wert ''{0}'' für Facet ''fractionDigits'' ungültig, da der Wert <= dem Wert für ''totalDigits'' sein muss, der ''{1}'' ist.
        length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: Bei Typ {0} gilt es als Fehler, wenn der Wert von length ''{1}'' kleiner als der Wert von minLength ''{2}'' ist.
        length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: Bei Typ {0} gilt es als Fehler, wenn die Basis kein minLength-Facet hat, wenn die aktuelle Einschränkung das minLength-Facet und die aktuelle Einschränkung oder Basis das length-Facet hat.
        length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: Bei Typ {0} gilt es als Fehler, wenn die aktuelle minLength ''{1}'' nicht mit der Basis-minLength ''{2}'' identisch ist.
        length-minLength-maxLength.2.1 = length-minLength-maxLength.2.1: Bei Typ {0} gilt es als Fehler, wenn der Wert von length ''{1}'' größer als der Wert von maxLength ''{2}'' ist.
        length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: Bei Typ {0} gilt es als Fehler, wenn die Basis kein maxLength-Facet hat, wenn die aktuelle Einschränkung das maxLength-Facet und die aktuelle Einschränkung oder Basis das length-Facet hat.
        length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: Bei Typ {0} gilt es als Fehler, wenn die aktuelle maxLength ''{1}'' nicht mit der Basis-maxLength ''{2}'' identisch ist.
        length-valid-restriction = length-valid-restriction: Fehler bei Typ ''{2}''. Der Wert von length = ''{0}'' muss mit dem Wert des Basistyps ''{1}'' identisch sein.
        maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: Fehler bei Typ ''{2}''. maxExclusive-Wert =''{0}'' muss <= maxExclusive des Basistyps ''{1}'' sein.
        maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: Fehler bei Typ ''{2}''. maxExclusive-Wert =''{0}'' muss <= maxInclusive des Basistyps ''{1}'' sein.
        maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: Fehler bei Typ ''{2}''. maxExclusive-Wert =''{0}'' muss > minInclusive des Basistyps ''{1}'' sein.
        maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.4: Fehler bei Typ ''{2}''. maxExclusive-Wert =''{0}'' muss > minExclusive des Basistyps ''{1}'' sein.
        maxInclusive-maxExclusive = maxInclusive-maxExclusive: Es gilt als Fehler, wenn sowohl maxInclusive als auch maxExclusive für denselben Datentyp angegeben werden. In {2} gilt: maxInclusive = ''{0}'' und maxExclusive = ''{1}''.
        maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: Fehler bei Typ ''{2}''. maxInclusive-Wert =''{0}'' muss <= maxInclusive des Basistyps ''{1}'' sein.
        maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: Fehler bei Typ ''{2}''. maxInclusive-Wert =''{0}'' muss < maxExclusive des Basistyps ''{1}'' sein.
        maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: Fehler bei Typ ''{2}''. maxInclusive-Wert =''{0}'' muss >= maxInclusive des Basistyps ''{1}'' sein.
        maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: Fehler bei Typ ''{2}''. maxInclusive-Wert =''{0}'' muss > minExclusive des Basistyps ''{1}'' sein.
        maxLength-valid-restriction = maxLength-valid-restriction: In der Definition von {2} muss maxLength-Wert = ''{0}'' <= dem Wert des Basistyps ''{1}'' sein.
        mg-props-correct.2 = mg-props-correct.2: Zyklische Definitionen für Gruppe ''{0}'' ermittelt. Rekursives Folgen der '{'term'}'-Werte der Partikel führt zu einem Partikel, dessen '{'term'}' die Gruppe selbst ist.
        minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: In der Definition von {2} muss minExclusive-Wert = ''{0}'' <= maxExclusive-Wert = ''{1}'' sein.
        minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: In der Definition von {2} muss minExclusive-Wert = ''{0}'' < maxInclusive-Wert = ''{1}'' sein.
        minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: Fehler bei Typ ''{2}''. minExclusive-Wert =''{0}'' muss >= minExclusive des Basistyps ''{1}'' sein.
        minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: Fehler bei Typ ''{2}''. minExclusive-Wert =''{0}'' muss <= maxInclusive des Basistyps ''{1}'' sein.
        minExclusive-valid-restriction.3 = minExclusive-valid-restriction.3: Fehler bei Typ ''{2}''. minExclusive-Wert =''{0}'' muss >= minInclusive des Basistyps ''{1}'' sein.
        minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: Fehler bei Typ ''{2}''. minExclusive-Wert =''{0}'' muss < maxExclusive des Basistyps ''{1}'' sein.
        minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: In der Definition von {2} muss minInclusive-Wert = ''{0}'' <= maxInclusive-Wert = ''{1}'' sein.
        minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: In der Definition von {2} muss minInclusive-Wert = ''{0}'' < maxExclusive-Wert = ''{1}'' sein.
        minInclusive-minExclusive = minInclusive-minExclusive: Es gilt als Fehler, wenn sowohl minInclusive als auch minExclusive für denselben Datentyp angegeben werden. In {2} gilt: minInclusive = ''{0}'' und minExclusive = ''{1}''.
        minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: Fehler bei Typ ''{2}''. minInclusive-Wert =''{0}'' muss >= minInclusive des Basistyps ''{1}'' sein.
        minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: Fehler bei Typ ''{2}''. minInclusive-Wert =''{0}'' muss <= maxInclusive des Basistyps ''{1}'' sein.
        minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: Fehler bei Typ ''{2}''. minInclusive-Wert =''{0}'' muss > minExclusive des Basistyps ''{1}'' sein.
        minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: Fehler bei Typ ''{2}''. minInclusive-Wert =''{0}'' muss < maxExclusive des Basistyps ''{1}'' sein.
        minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: In der Definition von {2} muss der Wert von minLength = ''{0}'' < dem Wert von maxLength = ''{1}'' sein.
        minLength-valid-restriction = minLength-valid-restriction: In der Definition von {2} muss minLength = ''{0}'' >= dem Wert des Basistyps ''{1}'' sein.
        no-xmlns = no-xmlns: {name} einer Attributdeklaration darf nicht mit 'xmlns' übereinstimmen.
        no-xsi = no-xsi: '{'target namespace'}' einer Attributdeklaration darf nicht mit ''{0}'' übereinstimmen.
        p-props-correct.2.1 = p-props-correct.2.1: In der Deklaration von ''{0}'' ist der Wert von ''minOccurs'' ''{1}'', er darf aber nicht größer als der Wert von ''maxOccurs'' sein, der ''{2}'' lautet.
        rcase-MapAndSum.1 = rcase-MapAndSum.1: Es ist keine vollständige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-MapAndSum.2 = rcase-MapAndSum.2: Vorkommensbereich der Gruppe ({0},{1}) ist keine gültige Einschränkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: Elemente haben Namen und Ziel-Namespaces, die nicht identisch sind: Element ''{0}'' in Namespace ''{1}'' und Element ''{2}'' in Namespace ''{3}''.
        rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: Fehler beim Partikel, dessen '{'term'}' die Elementdeklaration ''{0}'' ist. '{'nillable'}' ist bei der Elementdeklaration ''true'', aber das entsprechende Partikel im Basistyp hat eine Elementdeklaration, bei der '{'nillable'}' ''false'' ist.
        rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3: Fehler beim Partikel, dessen "{''term''}" die Elementdeklaration "{0}" ist. Der Vorkommensbereich ({1},{2}) ist keine gültige Einschränkung des Bereichs ({3},{4}) des entsprechenden Partikels im Basistyp.
        rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: Element ''{0}'' ist nicht fest, aber das entsprechende Element im Basistyp ist fest mit Wert ''{1}''.
        rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: Element ''{0}'' ist fest mit dem Wert ''{1}'', aber das entsprechende Element im Basistyp ist fest mit Wert ''{2}''.
        rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: Identity Constraints für Element ''{0}'' sind keine Teilmenge der Constraints in der Basis.
        rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: Die unzulässigen Substitutionen für Element ''{0}'' sind keine Obermenge der Substitutionen in der Basis.
        rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: Typ des Elements ''{0}'' ''{1}'' wurde nicht vom Typ des Basiselements ''{2}'' abgeleitet.
        rcase-NSCompat.1 = rcase-NSCompat.1: Element ''{0}'' hat den Namespace ''{1}''. Dies wird vom Platzhalter in der Basis nicht zugelassen.
        rcase-NSCompat.2 = rcase-NSCompat.2: Fehler beim Partikel, dessen "{''term''}" die Elementdeklaration "{0}" ist. Der Vorkommensbereich ({1},{2}) ist keine gültige Einschränkung des Bereichs ({3},{4}) des entsprechenden Partikels im Basistyp.
        rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: Es ist keine vollständige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: Vorkommensbereich der Gruppe ({0},{1}) ist keine gültige Einschränkung des Bereichs des Basisplatzhalters ({2},{3}).
        rcase-NSSubset.1 = rcase-NSSubset.1: Platzhalter ist keine Teilmenge des entsprechenden Platzhalters in der Basis.
        rcase-NSSubset.2 = rcase-NSSubset.2: Vorkommensbereich des Platzhalters ({0},{1}) ist keine gültige Einschränkung des Bereichs in der Basis ({2},{3}).
        rcase-NSSubset.3 = rcase-NSSubset.3: Prozesscontent des Platzhalters (''{0}'') ist schwächer als der in der Basis ''{1}''.
        rcase-Recurse.1 = rcase-Recurse.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine gültige Einschränkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-Recurse.2 = rcase-Recurse.2: Es ist keine vollständige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-RecurseLax.1 = rcase-RecurseLax.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine gültige Einschränkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-RecurseLax.2 = rcase-RecurseLax.2: Es ist keine vollständige Funktionszuordnung zwischen den Partikeln vorhanden.
        rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: Vorkommensbereich der Gruppe ({0},{1}) ist keine gültige Einschränkung des Vorkommensbereichs der Basisgruppe ({2},{3}).
        rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: Es ist keine vollständige Funktionszuordnung zwischen den Partikeln vorhanden.
#        We're using sch-props-correct.2 instead of the old src-redefine.1
#        src-redefine.1 = src-redefine.1: The component ''{0}'' is begin redefined, but its corresponding component isn't in the schema document being redefined (with namespace ''{2}''), but in a different document, with namespace ''{1}''.
        sch-props-correct.2 = sch-props-correct.2: Ein Schema kann nicht zwei globale Komponenten mit demselben Namen enthalten. Dieses Schema enthält zwei Vorkommen von ''{0}''.
        st-props-correct.2 = st-props-correct.2: Zyklische Definitionen wurden für Simple Type ''{0}'' ermittelt. Dies bedeutet, dass ''{0}'' in der eigenen Typhierarchie enthalten ist. Dies ist ein Fehler.
        st-props-correct.3 = st-props-correct.3: Fehler bei Typ ''{0}''. Der Wert von '{'final'}' der '{'base type definition'}' ''{1}'' lässt keine Ableitung durch Einschränkung zu.
        totalDigits-valid-restriction = totalDigits-valid-restriction: In der Definition von {2} ist der Wert ''{0}'' für Facet ''totalDigits'' ungültig, da er <= dem Wert für ''totalDigits'' sein muss, der in einem der Vorgängertypen auf ''{1}'' gesetzt wurde.
        whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: In der Definition von {0} ist der Wert ''{1}'' für Facet ''whitespace'' ungültig, da der Wert für ''whitespace'' in einem der Vorgängertypen auf ''collapse'' gesetzt wurde.
        whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: In der Definition von {0} ist der Wert ''preserve'' für Facet ''whitespace'' ungültig, da der Wert für ''whitespace'' in einem der Vorgängertypen auf ''replace'' gesetzt wurde.

#schema for Schemas

        s4s-att-invalid-value = s4s-att-invalid-value: Ungültiger Attributwert für ''{1}'' in Element ''{0}''. Aufgezeichneter Grund: {2}
        s4s-att-must-appear = s4s-att-must-appear: Attribut ''{1}'' muss in Element ''{0}'' vorkommen.
        s4s-att-not-allowed = s4s-att-not-allowed: Attribut ''{1}'' darf nicht in Element ''{0}'' vorkommen.
        s4s-elt-invalid = s4s-elt-invalid: Element ''{0}'' ist kein gültiges Element in einem Schemadokument.
        s4s-elt-must-match.1 = s4s-elt-must-match.1: Content von ''{0}'' muss {1} entsprechen. Beim Start bei {2} ist ein Problem aufgetreten.
        s4s-elt-must-match.2 = s4s-elt-must-match.2: Content von ''{0}'' muss {1} entsprechen. Nicht genügend Elemente gefunden.
        # the "invalid-content" messages provide less information than the "must-match" counterparts above. They're used for complex types when providing a "match" would be an information dump
        s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: Content von ''{0}'' ist ungültig. Element ''{1}'' ist ungültig, nicht an der erwarteten Stelle oder kommt zu oft vor.
        s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: Content von ''{0}'' ist ungültig. Element ''{1}'' darf nicht leer sein.
        s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: Elemente mit dem Typ ''{0}'' können nicht nach Deklarationen als untergeordnete Elemente eines <schema>-Elements vorkommen.
        s4s-elt-schema-ns = s4s-elt-schema-ns: Namespace des Elements ''{0}'' muss aus dem Schema-Namespace ''http://www.w3.org/2001/XMLSchema'' stammen.
        s4s-elt-character = s4s-elt-character: In anderen Schemaelementen als ''xs:appinfo'' und ''xs:documentation'' sind nur Leerstellen zulässig. ''{0}'' gefunden.

# codes not defined by the spec

        c-fields-xpaths = c-fields-xpaths: Feldwert = ''{0}'' ist ungültig.
        c-general-xpath = c-general-xpath: Ausdruck ''{0}'' ist ungültig in Bezug auf die vom XML-Schema unterstützte XPath-Teilmenge.
        c-general-xpath-ns = c-general-xpath-ns: Namespace-Präfix in XPath-Ausdruck ''{0}'' war an einen Namespace gebunden.
        c-selector-xpath = c-selector-xpath: Selektor-Wert = ''{0}'' ist ungültig. Selektor-XPaths können keine Attribute enthalten.
        EmptyTargetNamespace = EmptyTargetNamespace: In Schemadokument ''{0}'' kann der Wert des ''targetNamespace''-Attributs keine leere Zeichenfolge sein.
        FacetValueFromBase = FacetValueFromBase: In der Deklaration von Typ ''{0}'' muss der Wert ''{1}'' von Facet ''{2}'' aus dem Wertebereich des Basistyps ''{3}'' stammen.
        FixedFacetValue = FixedFacetValue: In der Definition von {3} ist der Wert ''{1}'' für Facet ''{0}'' ungültig, da der Wert für ''{0}'' in einem der Vorgängertypen auf ''{2}'' gesetzt wurde und ''{''fixed'}''' = true ist.
        InvalidRegex = InvalidRegex: Musterwert "{0}" ist kein gültiger regulärer Ausdruck. Der gemeldete Fehler war: "{1}".
        MaxOccurLimit = Aktuelle Konfiguration des Parsers lässt nicht zu, dass ein Inhaltsmodell so erweitert wird, dass ein komplexer Typ mehr als {0} Knoten enthält.
        PublicSystemOnNotation = PublicSystemOnNotation: Mindestens eines der Elemente 'public' und 'system' muss im Element 'notation' vorkommen.
        SchemaLocation = SchemaLocation: schemaLocation-Wert = ''{0}'' muss eine gerade Anzahl an URIs haben.
        TargetNamespace.1 = TargetNamespace.1: Namespace ''{0}'' wird erwartet, aber der Ziel-Namespace des Schemadokuments ist ''{1}''.
        TargetNamespace.2 = TargetNamespace.2: Kein Namespace wird erwartet, aber das Schemadokument hat den Ziel-Namespace ''{1}''.
        UndeclaredEntity = UndeclaredEntity: Entity ''{0}'' ist nicht deklariert.
        UndeclaredPrefix = UndeclaredPrefix: ''{0}'' kann nicht als QName aufgelöst werden: Präfix ''{1}'' ist nicht deklariert.
        FacetsContradict = FacetsContradict: Für simpleType-Definition "{2}" widerspricht der Enumerationswert "{0}" dem Wert von Facet "{1}".

# JAXP 1.2 schema source property errors

        jaxp12-schema-source-type.1 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Wert des Typs "{0}" haben. Mögliche unterstützte Werttypen sind String, File, InputStream, InputSource oder ein Array dieser Typen.
        jaxp12-schema-source-type.2 = Die Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" darf keinen Arraywert des Typs "{0}" haben. Mögliche unterstützte Arraytypen sind Object, String, File, InputStream, InputSource.
        jaxp12-schema-source-ns = Bei Verwendung eines Arrays von Objects als Wert der Eigenschaft "http://java.sun.com/xml/jaxp/properties/schemaSource" dürfen keine zwei Schemas denselben Ziel-Namespace verwenden.
