#
# Copyright (c) 2013, 2023, Oracle and/or its affiliates. All rights reserved.
#
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file contains error and warning messages related to XML
# The messages are arranged in key and value tuples in a ListResourceBundle.
#
# @version

        BadMessageKey = 找不到与消息关键字对应的错误消息。
        FormatFailed = 设置以下消息的格式时出现内部错误:\n

# Document messages
        PrematureEOF=文件提前结束。
# 2.1 Well-Formed XML Documents
        RootElementRequired = 根元素应该位于格式正确的文档中。
# 2.2 Characters

        InvalidCharInCDSect = 在 CDATA 节中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInContent = 在文档的元素内容中找到无效的 XML 字符 (Unicode: 0x{0})。
        TwoColonsInQName = 在元素内容或属性名中找到无效的第二个 ':'。
        ColonNotLegalWithNS = 当启用名称空间时, 不允许在名称 ''{0}'' 中使用冒号。
        InvalidCharInMisc = 在元素内容结尾后的标记中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInProlog = 在文档前言中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInXMLDecl = 在 XML 声明中找到无效的 XML 字符 (Unicode: 0x{0})。
# 2.4 Character Data and Markup
        CDEndInContent = 除非使用字符序列 "]]>" 来标记 CDATA 节的结尾, 否则该字符序列不能出现在内容中。
# 2.7 CDATA Sections
        CDSectUnterminated = CDATA 节必须以 "]]>" 结尾。
# 2.8 Prolog and Document Type Declaration
        XMLDeclMustBeFirst = XML 声明只能出现在文档的最开头处。
        EqRequiredInXMLDecl = 在 XML 声明中, "{0}" 后面必须跟有 '' = '' 字符。
        QuoteRequiredInXMLDecl = XML 声明中 "{0}" 后面跟随的值必须是用引号括起来的字符串。
        XMLDeclUnterminated = XML 声明必须以 "?>" 结尾。
        VersionInfoRequired = XML 声明中需要此版本。
        SpaceRequiredBeforeVersionInXMLDecl = 在 XML 声明中的版本伪属性前面必须有空格。
        SpaceRequiredBeforeEncodingInXMLDecl = 在 XML 声明中的编码伪属性前面必须有空格。
        SpaceRequiredBeforeStandalone = 在 XML 声明中的编码伪属性前面必须有空格。
        MarkupNotRecognizedInProlog = 文档中根元素前面的标记必须格式正确。
        MarkupNotRecognizedInMisc = 文档中根元素后面的标记必须格式正确。
        AlreadySeenDoctype = 已经看到 doctype。
        DoctypeNotAllowed = 将功能 "http://apache.org/xml/features/disallow-doctype-decl" 设置为“真”时, 不允许使用 DOCTYPE。
        ContentIllegalInProlog = 前言中不允许有内容。
        ReferenceIllegalInProlog = 前言中不允许有引用。
# Trailing Misc
        ContentIllegalInTrailingMisc=尾随节中不允许有内容。
        ReferenceIllegalInTrailingMisc=尾随节中不允许有引用。

# 2.9 Standalone Document Declaration
        SDDeclInvalid = 独立文档声明值必须为 "是" 或 "否", 不能为 "{0}"。
        SDDeclNameInvalid = XML 声明中的独立名称可能拼写有误。
# 2.12 Language Identification
        XMLLangInvalid = xml:lang 属性值 "{0}" 是无效的语言标识符。
# 3. Logical Structures
        ETagRequired = 元素类型 "{0}" 必须由匹配的结束标记 "</{0}>" 终止。
# 3.1 Start-Tags, End-Tags, and Empty-Element Tags
        ElementUnterminated = 元素类型 "{0}" 必须后跟属性规范 ">" 或 "/>"。
        EqRequiredInAttribute = 与元素类型 "{0}" 相关联的属性名 "{1}" 必须后跟 '' = '' 字符。
        OpenQuoteExpected = 与元素类型 "{0}" 相关联的属性 "{1}" 应有左引号。
        CloseQuoteExpected = 与元素类型 "{0}" 相关联的属性 "{1}" 应有右引号。
        AttributeNotUnique = 已经为元素 "{0}" 指定属性 "{1}"。
        AttributeNSNotUnique = 已经为元素 "{0}" 指定绑定到名称空间 "{2}" 的属性 "{1}"。
        ETagUnterminated = 元素类型 "{0}" 的结束标记必须以 ''>'' 分隔符结束。
        MarkupNotRecognizedInContent = 元素内容必须由格式正确的字符数据或标记组成。
        DoctypeIllegalInContent = 内容中不允许有 DOCTYPE。
# 4.1 Character and Entity References
        ReferenceUnterminated = 引用必须以 ';' 分隔符终止。
# 4.3.2 Well-Formed Parsed Entities
        ReferenceNotInOneEntity = 引用必须完全包含在同一个已解析实体内。
        ElementEntityMismatch = 元素 "{0}" 必须从头至尾包含在同一个实体内。
        MarkupEntityMismatch=XML 文档结构必须从头至尾包含在同一个实体内。

# Messages common to Document and DTD
# 2.2 Characters
        InvalidCharInAttValue = 在 "{1}" 属性值中找到无效的 XML 字符 (Unicode: 0x{2}), 并且元素为 "{0}"。
        InvalidCharInComment = 在注释中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInPI = 在处理指令中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInInternalSubset = 在 DTD 的内部子集中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInTextDecl = 在文本声明中找到无效的 XML 字符 (Unicode: 0x{0})。
# 2.3 Common Syntactic Constructs
        QuoteRequiredInAttValue = "{1}" 属性值必须以单引号字符或双引号字符开头。
        LessthanInAttValue = 与元素类型 "{0}" 相关联的 "{1}" 属性值不能包含 ''<'' 字符。
        AttributeValueUnterminated = "{1}" 属性值必须以匹配的引号字符结尾。
# 2.5 Comments
        InvalidCommentStart = 注释必须以 "<!--" 开头。
        DashDashInComment = 注释中不允许出现字符串 "--"。
        CommentUnterminated = 注释必须以 "-->" 结尾。
        COMMENT_NOT_IN_ONE_ENTITY = 注释没有包含在同一个实体内。
# 2.6 Processing Instructions
        PITargetRequired = 处理指令必须以目标名称开头。
        SpaceRequiredInPI = 在处理指令目标和数据之间需要有空格。
        PIUnterminated = 处理指令必须以 "?>" 结尾。
        ReservedPITarget = 不允许有匹配 "[xX][mM][lL]" 的处理指令目标。
        PI_NOT_IN_ONE_ENTITY = 处理指令没有包含在同一个实体内。
# 2.8 Prolog and Document Type Declaration
        VersionInfoInvalid = 版本 "{0}" 无效。
        VersionNotSupported = 不支持 XML 版本 "{0}", 只支持 XML 1.0。
        VersionNotSupported11 = 不支持 XML 版本 "{0}", 只支持 XML 1.0 和 XML 1.1。
        VersionMismatch= 实体不能包含较高版本的另一个实体。
# 4.1 Character and Entity References
        DigitRequiredInCharRef = 在字符引用中, 十进制表示方法必须紧跟在 "&#" 后面。
        HexdigitRequiredInCharRef = 在字符引用中, 十六进制表示方法必须紧跟在 "&#x" 后面。
        SemicolonRequiredInCharRef = 字符引用必须以 ';' 分隔符结尾。
        InvalidCharRef = 字符引用 "&#{0}" 是无效的 XML 字符。
        NameRequiredInReference = 在实体引用中, 实体名称必须紧跟在 '&' 后面。
        SemicolonRequiredInReference = 对实体 "{0}" 的引用必须以 '';'' 分隔符结尾。
# 4.3.1 The Text Declaration
        TextDeclMustBeFirst = 文本声明只能出现在已解析的外部实体的最开头处。
        EqRequiredInTextDecl = 在文本声明中, "{0}" 后面必须跟有 '' = '' 字符。
        QuoteRequiredInTextDecl = 文本声明中 "{0}" 后面跟随的值必须是用引号括起来的字符串。
        CloseQuoteMissingInTextDecl = 文本声明中 "{0}" 后面跟随的值缺少右引号。
        SpaceRequiredBeforeVersionInTextDecl = 在文本声明中的版本伪属性前面必须有空格。
        SpaceRequiredBeforeEncodingInTextDecl = 在文本声明中的编码伪属性前面必须有空格。
        TextDeclUnterminated = 文本声明必须以 "?>" 结尾。
        EncodingDeclRequired = 文本声明中需要编码声明。
        NoMorePseudoAttributes = 不允许使用更多的伪属性。
        MorePseudoAttributes = 应该有更多的伪属性。
        PseudoAttrNameExpected = 应该有伪属性名。
# 4.3.2 Well-Formed Parsed Entities
        CommentNotInOneEntity = 注释必须完全包含在同一个已解析实体内。
        PINotInOneEntity = 处理指令必须完全包含在同一个已解析实体内。
# 4.3.3 Character Encoding in Entities
        EncodingDeclInvalid = 编码名称 "{0}" 无效。
        EncodingByteOrderUnsupported = 不支持编码 "{0}" 的给定字节顺序。
        InvalidByte = {1} 字节的 UTF-8 序列的字节 {0} 无效。
        ExpectedByte = 应为 {1} 字节的 UTF-8 序列的字节 {0}。
        InvalidHighSurrogate = UTF-8 序列中的高代理位不能超过 0x10, 但找到 0x{0}。
        OperationNotSupported = {1}读进程不支持操作 "{0}"。
        InvalidASCII = 字节 "{0}" 不是 (7 位) ASCII 字符集的成员。
        CharConversionFailure = 确定属于某个编码的实体不能包含在该编码中非法的序列。

# DTD Messages
# 2.2 Characters
        InvalidCharInEntityValue = 在文字实体值中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInExternalSubset = 在 DTD 的外部子集中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInIgnoreSect = 在排除的条件节中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInPublicID = 在公共标识符中找到无效的 XML 字符 (Unicode: 0x{0})。
        InvalidCharInSystemID = 在系统标识符中找到无效的 XML 字符 (Unicode: 0x{0})。
# 2.3 Common Syntactic Constructs
        SpaceRequiredAfterSYSTEM = 在 DOCTYPE 声明中的关键字 SYSTEM 后面需要有空格。
        QuoteRequiredInSystemID = 系统标识符必须以单引号字符或双引号字符开头。
        SystemIDUnterminated = 系统标识符必须以匹配的引号字符结尾。
        SpaceRequiredAfterPUBLIC = 在 DOCTYPE 声明中的关键字 PUBLIC 后面需要有空格。
        QuoteRequiredInPublicID = 公共标识符必须以单引号字符或双引号字符开头。
        PublicIDUnterminated = 公共标识符必须以匹配的引号字符结尾。
        PubidCharIllegal = 公共标识符中不允许使用该字符 (Unicode: 0x{0})。
        SpaceRequiredBetweenPublicAndSystem = 在 publicId 和 systemId 之间需要有空格。
# 2.8 Prolog and Document Type Declaration
        MSG_SPACE_REQUIRED_BEFORE_ROOT_ELEMENT_TYPE_IN_DOCTYPEDECL = 在文档类型声明中的 "<!DOCTYPE" 后面需要有空格。
        MSG_ROOT_ELEMENT_TYPE_REQUIRED = 在文档类型声明中, 根元素类型必须出现在 "<!DOCTYPE" 后面。
        DoctypedeclUnterminated = 根元素类型 "{0}" 的文档类型声明必须以 ''>'' 结尾。
        DoctypedeclNotClosed = 根元素类型 "{0}" 的文档类型声明必须以 '']'' 结尾。
        PEReferenceWithinMarkup = 参数实体引用 "%{0};" 不能出现在 DTD 的内部子集中的标记内。
        MSG_MARKUP_NOT_RECOGNIZED_IN_DTD = 文档类型声明包含或指向的标记声明必须格式正确。
# 2.10 White Space Handling
        MSG_XML_SPACE_DECLARATION_ILLEGAL = "xml:space" 的属性声明必须指定为枚举类型, 它的可能值只有 "default" 和 "preserve"。
# 3.2 Element Type Declarations
        MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ELEMENTDECL = 在元素类型声明中的 "<!ELEMENT" 后面需要有空格。
        MSG_ELEMENT_TYPE_REQUIRED_IN_ELEMENTDECL = 元素类型声明中需要有元素类型。
        MSG_SPACE_REQUIRED_BEFORE_CONTENTSPEC_IN_ELEMENTDECL = 在元素类型声明中的元素类型 "{0}" 后面需要有空格。
        MSG_CONTENTSPEC_REQUIRED_IN_ELEMENTDECL = 在元素类型声明中的元素类型 "{0}" 后面需要有约束条件。
        ElementDeclUnterminated = 元素类型 "{0}" 的声明必须以 ''>'' 结尾。
# 3.2.1 Element Content
        MSG_OPEN_PAREN_OR_ELEMENT_TYPE_REQUIRED_IN_CHILDREN = 在元素类型 "{0}" 的声明中需要有 ''('' 字符或元素类型。
        MSG_CLOSE_PAREN_REQUIRED_IN_CHILDREN = 在元素类型 "{0}" 的声明中需要有 '')''。
# 3.2.2 Mixed Content
        MSG_ELEMENT_TYPE_REQUIRED_IN_MIXED_CONTENT = 在元素类型 "{0}" 的声明中需要有元素类型。
        MSG_CLOSE_PAREN_REQUIRED_IN_MIXED = 在元素类型 "{0}" 的声明中需要有 '')''。
        MixedContentUnterminated = 当子元素类型受约束时, 混合内容模型 "{0}" 必须以 ")*" 结尾。
# 3.3 Attribute-List Declarations
        MSG_SPACE_REQUIRED_BEFORE_ELEMENT_TYPE_IN_ATTLISTDECL = 在属性列表声明中的 "<!ATTLIST" 后面需要有空格。
        MSG_ELEMENT_TYPE_REQUIRED_IN_ATTLISTDECL = 属性列表声明中需要有元素类型。
        MSG_SPACE_REQUIRED_BEFORE_ATTRIBUTE_NAME_IN_ATTDEF = 在元素 "{0}" 的属性列表声明中的属性名前面需要有空格。
        AttNameRequiredInAttDef = 在元素 "{0}" 的属性列表声明中必须指定属性名。
        MSG_SPACE_REQUIRED_BEFORE_ATTTYPE_IN_ATTDEF = 在元素 "{0}" 的属性 "{1}" 的声明中, 在属性类型前面需要有空格。
        AttTypeRequiredInAttDef = 在元素 "{0}" 的属性 "{1}" 的声明中需要有属性类型。
        MSG_SPACE_REQUIRED_BEFORE_DEFAULTDECL_IN_ATTDEF = 在元素 "{0}" 的属性 "{1}" 的声明中, 在属性默认值前面需要有空格。
        MSG_DUPLICATE_ATTRIBUTE_DEFINITION = 为指定元素 "{0}" 的同一属性 "{1}" 提供了多个属性定义。
# 3.3.1 Attribute Types
        MSG_SPACE_REQUIRED_AFTER_NOTATION_IN_NOTATIONTYPE = 在 "{1}" 属性声明中, 空格必须出现在 "NOTATION" 后面。
        MSG_OPEN_PAREN_REQUIRED_IN_NOTATIONTYPE = 在 "{1}" 属性声明中, "NOTATION" 后面必须跟有 ''('' 字符。
        MSG_NAME_REQUIRED_IN_NOTATIONTYPE = 在 "{1}" 属性声明的记号类型列表中需要有记号名称。
        NotationTypeUnterminated = 在 "{1}" 属性声明中, 记号类型列表必须以 '')'' 结尾。
        MSG_NMTOKEN_REQUIRED_IN_ENUMERATION = 在 "{1}" 属性声明的枚举类型列表中需要有名称标记。
        EnumerationUnterminated = 在 "{1}" 属性声明中, 枚举类型列表必须以 '')'' 结尾。
        MSG_DISTINCT_TOKENS_IN_ENUMERATION = 在元素 "{0}" 的属性 "{2}" 的声明中, 枚举值 "{1}" 指定了多次。单个枚举属性声明中的 NMTOKENS 必须全部不相同。
        MSG_DISTINCT_NOTATION_IN_ENUMERATION = 在元素 "{0}" 的属性 "{2}" 的声明中, 枚举值 "{1}" 指定了多次。单个 NotationType 属性声明中的 NOTATION 名称必须全部不相同。
# 3.3.2 Attribute Defaults
        MSG_SPACE_REQUIRED_AFTER_FIXED_IN_DEFAULTDECL = 在 "{1}" 属性声明中, 空格必须出现在 "FIXED" 后面。
# 3.4 Conditional Sections
        IncludeSectUnterminated = 包含的条件节必须以 "]]>" 结尾。
        IgnoreSectUnterminated = 排除的条件节必须以 "]]>" 结尾。
# 4.1 Character and Entity References
        NameRequiredInPEReference = 在参数实体引用中, 实体名称必须紧跟在 '%' 后面。
        SemicolonRequiredInPEReference = 参数实体引用 "%{0};" 必须以 '';'' 分隔符结尾。
# 4.2 Entity Declarations
        MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_ENTITYDECL = 在实体声明中的 "<!ENTITY" 后面需要有空格。
        MSG_SPACE_REQUIRED_BEFORE_PERCENT_IN_PEDECL = 在参数实体声明中的 "<!ENTITY" 和 '%' 字符之间需要有空格。
        MSG_SPACE_REQUIRED_BEFORE_ENTITY_NAME_IN_PEDECL = 在参数实体声明中的 '%' 和实体名称之间需要有空格。
        MSG_ENTITY_NAME_REQUIRED_IN_ENTITYDECL = 实体声明中需要有实体名称。
        MSG_SPACE_REQUIRED_AFTER_ENTITY_NAME_IN_ENTITYDECL = 在实体声明中的实体名称 "{0}" 和定义之间需要有空格。
        MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_UNPARSED_ENTITYDECL = 在实体 "{0}" 的声明中的 "NDATA" 和记号名称之间需要有空格。
        MSG_SPACE_REQUIRED_BEFORE_NDATA_IN_UNPARSED_ENTITYDECL = 在实体 "{0}" 的声明中的 "NDATA" 前面需要有空格。
        MSG_NOTATION_NAME_REQUIRED_FOR_UNPARSED_ENTITYDECL = 在实体 "{0}" 的声明中的 "NDATA" 后面需要有记号名称。
        EntityDeclUnterminated = 实体 "{0}" 的声明必须以 ''>'' 结尾。
        MSG_DUPLICATE_ENTITY_DEFINITION = 实体 "{0}" 声明了多次。
# 4.2.2 External Entities
        ExternalIDRequired = 外部实体声明必须以 "SYSTEM" 或 "PUBLIC" 开头。
        MSG_SPACE_REQUIRED_BEFORE_PUBIDLITERAL_IN_EXTERNALID = 在 "PUBLIC" 和公共标识符之间需要有空格。
        MSG_SPACE_REQUIRED_AFTER_PUBIDLITERAL_IN_EXTERNALID = 在公共标识符和系统标识符之间需要有空格。
        MSG_SPACE_REQUIRED_BEFORE_SYSTEMLITERAL_IN_EXTERNALID = 在 "SYSTEM" 和系统标识符之间需要有空格。
        MSG_URI_FRAGMENT_IN_SYSTEMID = 片段标识符不能指定为系统标识符 "{0}" 的一部分。
# 4.7 Notation Declarations
        MSG_SPACE_REQUIRED_BEFORE_NOTATION_NAME_IN_NOTATIONDECL = 在记号声明中的 "<!NOTATION" 后面需要有空格。
        MSG_NOTATION_NAME_REQUIRED_IN_NOTATIONDECL = 记号声明中需要有记号名称。
        MSG_SPACE_REQUIRED_AFTER_NOTATION_NAME_IN_NOTATIONDECL = 在记号声明中的记号名称 "{0}" 后面需要有空格。
        ExternalIDorPublicIDRequired = 记号 "{0}" 的声明必须包含系统标识符或公共标识符。
        NotationDeclUnterminated = 记号 "{0}" 的声明必须以 ''>'' 结尾。

# Validation messages
        DuplicateTypeInMixedContent = 在元素声明 "{0}" 的内容模型中已经指定了元素类型 "{1}"。
        ENTITIESInvalid = 类型为 ENTITIES 的属性值 "{1}" 必须是一个或多个未解析实体的名称。
        ENTITYInvalid = 类型为 ENTITY 的属性值 "{1}" 必须是未解析实体的名称。
        IDDefaultTypeInvalid = ID 属性 "{0}" 必须具有已声明的默认值 "#IMPLIED" 或 "#REQUIRED"。
        IDInvalid = 类型为 ID 的属性值 "{0}" 必须是名称。
        IDInvalidWithNamespaces = 启用名称空间时, 类型为 ID 的属性值 "{0}" 必须是 NCName。
        IDNotUnique = 类型为 ID 的属性值 "{0}" 在文档内必须是唯一的。
        IDREFInvalid = 类型为 IDREF 的属性值 "{0}" 必须是名称。
        IDREFInvalidWithNamespaces = 启用名称空间时, 类型为 IDREF 的属性值 "{0}" 必须是 NCName。
        IDREFSInvalid = 类型为 IDREFS 的属性值 "{0}" 必须是一个或多个名称。
        ILL_FORMED_PARAMETER_ENTITY_WHEN_USED_IN_DECL = 当实体引用用作完整声明时, 参数实体 "{0}" 的替换文本必须包含正确嵌套的声明。
        ImproperDeclarationNesting = 参数实体 "{0}" 的替换文本必须包含正确嵌套的声明。
        ImproperGroupNesting = 参数实体 "{0}" 的替换文本必须包含正确嵌套的括号对。
        INVALID_PE_IN_CONDITIONAL = 参数实体 "{0}" 的替换文本必须包含整个条件节, 或者仅包含 INCLUDE 或 IGNORE。
        MSG_ATTRIBUTE_NOT_DECLARED = 必须为元素类型 "{0}" 声明属性 "{1}"。
        MSG_ATTRIBUTE_VALUE_NOT_IN_LIST = 值为 "{1}" 的属性 "{0}" 必须具有列表 "{2}" 中的值。
        MSG_ATTVALUE_CHANGED_DURING_NORMALIZATION_WHEN_STANDALONE = 在独立文档中, 属性 "{0}" 的值 "{1}" 不能通过规范化进行更改 (更改为 "{2}")。
        MSG_CONTENT_INCOMPLETE = 元素类型为 "{0}" 的内容不完整, 它必须匹配 "{1}"。
        MSG_CONTENT_INVALID = 元素类型为 "{0}" 的内容必须匹配 "{1}"。
        MSG_CONTENT_INVALID_SPECIFIED = 元素类型为 "{0}" 的内容必须匹配 "{1}"。不允许使用类型为 "{2}" 的子级。
        MSG_DEFAULTED_ATTRIBUTE_NOT_SPECIFIED = 元素类型为 "{0}" 的属性 "{1}" 具有默认值, 并且必须在独立文档中指定。
        MSG_DUPLICATE_ATTDEF = 已经为元素类型 "{0}" 声明属性 "{1}"。
        MSG_ELEMENT_ALREADY_DECLARED = 元素类型 "{0}" 不能声明多次。
        MSG_ELEMENT_NOT_DECLARED = 必须声明元素类型 "{0}"。
        MSG_GRAMMAR_NOT_FOUND = 文档无效: 找不到语法。
        MSG_ELEMENT_WITH_ID_REQUIRED = 文档中必须包含标识符为 "{0}" 的元素。
        MSG_EXTERNAL_ENTITY_NOT_PERMITTED = 在独立文档中不允许引用外部实体 "{0}"。
        MSG_FIXED_ATTVALUE_INVALID = 值为 "{2}" 的属性 "{1}" 必须具有 "{3}" 的值。
        MSG_MORE_THAN_ONE_ID_ATTRIBUTE = 元素类型 "{0}" 已经具有类型为 ID 的属性 "{1}", 不允许使用类型为 ID 的另一个属性 "{2}"。
        MSG_MORE_THAN_ONE_NOTATION_ATTRIBUTE = 元素类型 "{0}" 已经具有类型为 NOTATION 的属性 "{1}", 不允许使用类型为 NOTATION 的另一个属性 "{2}"。
        MSG_NOTATION_NOT_DECLARED_FOR_NOTATIONTYPE_ATTRIBUTE = 在属性 "{0}" 的记号类型列表中引用记号 "{1}" 时, 必须声明该记号。
        MSG_NOTATION_NOT_DECLARED_FOR_UNPARSED_ENTITYDECL = 在 "{0}" 的未解析实体声明中引用记号 "{1}" 时, 必须声明该记号。
        MSG_REFERENCE_TO_EXTERNALLY_DECLARED_ENTITY_WHEN_STANDALONE = 在独立文档中不允许引用已解析的外部实体中声明的实体 "{0}"。
        MSG_REQUIRED_ATTRIBUTE_NOT_SPECIFIED = 需要属性 "{1}", 并且必须为元素类型 "{0}" 指定该属性。
        MSG_WHITE_SPACE_IN_ELEMENT_CONTENT_WHEN_STANDALONE = 对于在独立文档中具有元素内容的已解析的外部实体, 在该实体中声明的元素之间不能出现空格。
        NMTOKENInvalid = 类型为 NMTOKEN 的属性值 "{0}" 必须是名称标记。
        NMTOKENSInvalid = 类型为 NMTOKENS 的属性值 "{0}" 必须是一个或多个名称标记。
        NoNotationOnEmptyElement = 已声明为 EMPTY 的元素类型 "{0}" 不能声明类型为 NOTATION 的属性 "{1}"。
        RootElementTypeMustMatchDoctypedecl = 文档根元素 "{1}" 必须匹配 DOCTYPE 根 "{0}"。
        UndeclaredElementInContentSpec = 元素 "{0}" 的内容模型引用未声明的元素 "{1}"。
        UniqueNotationName = 记号 "{0}" 的声明不是唯一的。不能在多个记号声明中声明指定的名称。
        ENTITYFailedInitializeGrammar =  ENTITYDatatype 验证程序: 未能使用有效的语法引用调用初始化方法。\t
        ENTITYNotUnparsed = ENTITY "{0}" 不是未解析的。
        ENTITYNotValid = ENTITY "{0}" 无效。
        EmptyList = 类型为 ENTITIES, IDREFS 和 NMTOKENS 的值不能是空列表。

# Entity related messages
# 3.1 Start-Tags, End-Tags, and Empty-Element Tags
        ReferenceToExternalEntity = 属性值中不允许采用外部实体引用 "&{0};"。
        AccessExternalDTD = 外部 DTD: 无法读取外部 DTD ''{0}'', 因为 accessExternalDTD 属性设置的限制导致不允许 ''{1}'' 访问。
        AccessExternalEntity = 外部实体: 无法读取外部文档 ''{0}'', 因为 accessExternalDTD 属性设置的限制导致不允许 ''{1}'' 访问。

# 4.1 Character and Entity References
        EntityNotDeclared = 引用了实体 "{0}", 但未声明它。
        ReferenceToUnparsedEntity = 不允许使用未解析的实体引用 "&{0};"。
        RecursiveReference = 递归实体引用 "{0}"。(引用路径: {1}),
        RecursiveGeneralReference = 递归一般实体引用 "&{0};"。(引用路径: {1}),
        RecursivePEReference = 递归参数实体引用 "%{0};"。(引用路径: {1}),
# 4.3.3 Character Encoding in Entities
        EncodingNotSupported = 不支持编码 "{0}"。
        EncodingRequired = 如果已解析的实体未使用 UTF-8 或 UTF-16 进行编码, 则该实体必须包含编码声明。

# Namespaces support
# 4. Using Qualified Names
        IllegalQName = 元素或属性 "{0}" 不匹配 QName 生产：QName::=(NCName'':'')?NCName。
        ElementXMLNSPrefix = 元素 "{0}" 不能使用 "xmlns" 作为前缀。
        ElementPrefixUnbound = 元素 "{1}" 的前缀 "{0}" 未绑定。
        AttributePrefixUnbound = 与元素类型 "{0}" 相关联的属性 "{1}" 的前缀 "{2}" 未绑定。
        EmptyPrefixedAttName = 属性 "{0}" 的值无效。带前缀的名称空间绑定不能为空。
        PrefixDeclared = 未声明名称空间前缀 "{0}"。
        CantBindXMLNS = 前缀 "xmlns" 不能显式绑定到任何名称空间; "xmlns" 的名称空间也不能显式绑定到任何前缀。
        CantBindXML = 前缀 "xml" 不能绑定到除它的常用名称空间外的任何名称空间; "xml" 的名称空间也不能绑定到除 "xml" 外的任何前缀。
        MSG_ATT_DEFAULT_INVALID = 属性 "{0}" 的 defaultValue "{1}" 非法, 因为此属性类型具有词汇约束条件。

# REVISIT: These need messages
        MSG_SPACE_REQUIRED_AFTER_SYSTEMLITERAL_IN_EXTERNALID=MSG_SPACE_REQUIRED_AFTER_SYSTEMLITERAL_IN_EXTERNALID
        OpenQuoteMissingInDecl=OpenQuoteMissingInDecl
        InvalidCharInLiteral=InvalidCharInLiteral


# Implementation limits
        EntityExpansionLimit=JAXP00010001: 解析器在此文档中遇到多个 "{0}" 实体扩展; 这是 JDK 施加的限制。
        ElementAttributeLimit=JAXP00010002: 元素 "{0}" 具有多个 "{1}" 属性, "{1}" 是 JDK 施加的限制。
        MaxEntitySizeLimit=JAXP00010003: 实体 "{0}" 的长度为 "{1}", 超过了 "{3}" 设置的 "{2}" 限制。
        TotalEntitySizeLimit=JAXP00010004: 实体的累计大小为 "{0}", 超过了 "{2}" 设置的 "{1}" 限制。
        MaxXMLNameLimit=JAXP00010005: 实体 "{0}" 的长度为 "{1}", 超过了 "{3}" 设置的 "{2}" 限制。
        MaxElementDepthLimit=JAXP00010006: 元素 "{0}" 的深度 "{1}" 超过了 "{3}" 设置的限制 "{2}"。
        EntityReplacementLimit=JAXP00010007: 实体引用中的节点总数为 "{0}", 超过了 "{2}" 设置的限制 "{1}"。

# Catalog 09
# Technical term, do not translate: catalog
        CatalogException=JAXP00090001: 已对目录 "{0}" 启用 CatalogResolver, 但返回了 CatalogException。

# Implementation Property DTD
        JDK_DTD_DENY = JAXP00010008：当 DTD 属性设置为拒绝时，不允许使用 DOCTYPE。请参阅：java.xml/module-summary 中的属性 jdk.xml.dtd.support。
