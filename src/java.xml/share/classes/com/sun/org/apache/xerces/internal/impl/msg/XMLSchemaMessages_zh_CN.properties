#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file contains error and warning messages related to XML Schema
# The messages are arranged in key and value tuples in a ListResourceBundle.

        BadMessageKey = 找不到与消息关键字对应的错误消息。
        FormatFailed = 设置以下消息的格式时出现内部错误:\n

# For internal use

        Internal-Error = 内部错误: {0}。
        dt-whitespace = 空白面值不可用于联合 simpleType ''{0}''
        GrammarConflict = 用户的语法池返回的语法之一与另一个语法冲突。

# Identity constraints

        AbsentKeyValue = cvc-identity-constraint.4.2.1.a: 元素 "{0}" 不具有关键字 "{1}" 的值。
        DuplicateField = 字段 "{0}" 在作用域内有重复匹配。
        DuplicateKey = cvc-identity-constraint.4.2.2: 为元素 "{1}" 的身份约束条件 "{2}" 声明的关键字值 [{0}] 重复。
        DuplicateUnique = cvc-identity-constraint.4.1: 为元素 "{1}" 的身份约束条件 "{2}" 声明的唯一值 [{0}] 重复。
        FieldMultipleMatch = cvc-identity-constraint.3: 身份约束条件 "{1}" 的字段 "{0}" 与其选择器作用域内的多个值匹配; 字段必须与唯一值匹配。
        FixedDiffersFromActual = 此元素的内容与方案中元素声明的 "fixed" 属性的值不相同。
        KeyMatchesNillable = cvc-identity-constraint.4.2.3: 元素 "{0}" 具有的关键字 "{1}" 与 nillable 设置为“真”的元素匹配。
        KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: 对于为元素 "{0}" 指定的 <key name="{1}"> 身份约束条件, 没有为它指定足够的值。
        KeyNotFound = cvc-identity-constraint.4.3: 没有为元素 ''{2}'' 的身份约束条件找到值为 ''{1}'' 的关键字 ''{0}''。
        KeyRefOutOfScope = 身份约束条件错误: 身份约束条件 "{0}" 具有一个引用了作用域之外的关键字或唯一值的 keyref。
        KeyRefReferNotFound = 关键字引用声明 "{0}" 引用了名为 "{1}" 的未知关键字。
        UnknownField = 内部身份约束条件错误; 为元素 "{1}" 指定的身份约束条件 "{2}" 的字段 "{0}" 未知。

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.

#validation (3.X.4)

        cvc-attribute.3 = cvc-attribute.3: 在元素 ''{0}'' 中, 属性 ''{1}'' 的值 ''{2}'' 与其类型 ''{3}'' 不匹配。
        cvc-attribute.4 = cvc-attribute.4: 在元素 ''{0}'' 中, 属性 ''{1}'' 的值 ''{2}'' 与其固定的 '{'value constraint'}' 不匹配。该属性的值必须为 ''{3}''。
        cvc-complex-type.2.1 = cvc-complex-type.2.1: 元素 ''{0}'' 必须不含字符或元素信息项 [子级], 因为该类型的内容类型为空。
        cvc-complex-type.2.2 = cvc-complex-type.2.2: 元素 ''{0}'' 必须不含元素 [子级], 并且其值必须有效。
        cvc-complex-type.2.3 = cvc-complex-type.2.3: 元素 ''{0}'' 必须不含字符 [子级], 因为该类型的内容类型为“仅元素”。
        cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: 发现了以元素 ''{0}'' 开头的无效内容。应以 ''{1}'' 之一开头。
        cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: 元素 ''{0}'' 的内容不完整。应为 ''{1}'' 之一。
        cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 ''{0}'' 的声明。
        cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: 发现了以元素 ''{0}'' 开头的无效内容。此处不应含有子元素。
        cvc-complex-type.2.4.e = cvc-complex-type.2.4.e: ''{0}'' 在当前序列中最多可以出现 ''{2}'' 次。已超过此限制。此处预期为 ''{1}'' 之一。
        cvc-complex-type.2.4.f = cvc-complex-type.2.4.f: ''{0}'' 在当前序列中最多可以出现 ''{1}'' 次。已超过此限制。此处预期没有子元素。
        cvc-complex-type.2.4.g = cvc-complex-type.2.4.g: 发现了以元素 ''{0}'' 开头的无效内容。''{1}'' 预期在当前序列中最少出现 ''{2}'' 次。另外一个实例必须满足此约束条件。
        cvc-complex-type.2.4.h = cvc-complex-type.2.4.h: 发现了以元素 ''{0}'' 开头的无效内容。''{1}'' 预期在当前序列中最少出现 ''{2}'' 次。另外 ''{3}'' 个实例必须满足此约束条件。
        cvc-complex-type.2.4.i = cvc-complex-type.2.4.i: 元素 ''{0}'' 的内容不完整。''{1}'' 预期最少出现 ''{2}'' 次。另外一个实例必须满足此约束条件。
        cvc-complex-type.2.4.j = cvc-complex-type.2.4.j: 元素 ''{0}'' 的内容不完整。''{1}'' 预期最少出现 ''{2}'' 次。另外 ''{3}'' 个实例必须满足此约束条件。
        cvc-complex-type.3.1 = cvc-complex-type.3.1: 在元素 ''{0}'' 中, 属性 ''{1}'' 的值 ''{2}'' 与相应的属性用法不匹配。属性 ''{1}'' 具有固定值 ''{3}''。
        cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: 元素 ''{0}'' 没有属性 ''{1}'' 的属性通配符。
        cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: 元素 ''{0}'' 中不允许出现属性 ''{1}''。
        cvc-complex-type.4 = cvc-complex-type.4: 元素 ''{0}'' 中必须包含属性 ''{1}''。
        cvc-complex-type.4_ns = cvc-complex-type.4：元素 ''{0}'' 中必须包含属于名称空间 ''{2}'' 的属性 ''{1}''。
        cvc-complex-type.5.1 = cvc-complex-type.5.1: 在元素 ''{0}'' 中, 属性 ''{1}'' 是一个通用 ID。但已存在通用 ID ''{2}''。只能有一个通用 ID。
        cvc-complex-type.5.2 = cvc-complex-type.5.2: 在元素 ''{0}'' 中, 属性 ''{1}'' 是一个通用 ID。但已有一个属性 ''{2}'' 是从 '{'attribute uses'}' 中的 ID 派生的。
        cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: ''{0}'' 不是 ''{1}'' 的有效值。
        cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: ''{0}'' 不是列表类型 ''{1}'' 的有效值。
        cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: ''{0}'' 不是联合类型 ''{1}'' 的有效值。
        cvc-elt.1.a = cvc-elt.1.a: 找不到元素 ''{0}'' 的声明。
        cvc-elt.1.b = cvc-elt.1.b: 元素的名称与元素声明的名称不匹配。实际为 ''{0}''。预期为 ''{1}''。
        cvc-elt.2 = cvc-elt.2: ''{0}'' 的元素声明中 '{'abstract'}' 的值必须为“假”。
        cvc-elt.3.1 = cvc-elt.3.1: 元素 ''{0}'' 中不能包含属性 ''{1}'', 因为 ''{0}'' 的 '{'nillable'}' 属性为“假”。
        cvc-elt.3.2.1 = cvc-elt.3.2.1: 元素 ''{0}'' 必须不含字符或元素信息 [子级], 因为已指定 ''{1}''。
        cvc-elt.3.2.2 = cvc-elt.3.2.2: 元素 ''{0}'' 不能包含固定的 '{'value constraint'}', 因为已指定 ''{1}''。
        cvc-elt.4.1 = cvc-elt.4.1: 元素 ''{0}'' 的属性 ''{1}'' 的值 ''{2}'' 不是有效的限定名。
        cvc-elt.4.2 = cvc-elt.4.2: 无法将 ''{1}'' 解析为元素 ''{0}'' 的类型定义。
        cvc-elt.4.3 = cvc-elt.4.3: 类型 ''{1}'' 不是从元素 ''{0}'' 的类型定义 ''{2}'' 有效派生的。
        cvc-elt.5.1.1 = cvc-elt.5.1.1: 元素 ''{0}'' 的 '{'value constraint'}' ''{2}'' 不是类型 ''{1}'' 的有效默认值。
        cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: 元素 ''{0}'' 必须不含元素信息项 [子级]。
        cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: 元素 ''{0}'' 的值 ''{1}'' 与固定的 '{'value constraint'}' 值 ''{2}'' 不匹配。
        cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: 元素 ''{0}'' 的值 ''{1}'' 与 '{'value constraint'}' 值 ''{2}'' 不匹配。
        cvc-enumeration-valid = cvc-enumeration-valid: 对于枚举 ''{1}'', 值 ''{0}'' 不具有面有效性。它必须是来自枚举的值。
        cvc-fractionDigits-valid = cvc-fractionDigits-valid: 值 ''{0}'' 具有 {1} 位小数, 但小数位数已限制为 {2}。
        cvc-id.1 = cvc-id.1: IDREF ''{0}'' 没有 ID/IDREF 绑定。
        cvc-id.2 = cvc-id.2: ID 值 ''{0}'' 出现了多次。
        cvc-id.3 = cvc-id.3: 身份约束条件 ''{0}'' 的字段与元素 ''{1}'' 匹配, 但此元素没有简单类型。
        cvc-length-valid = cvc-length-valid: 对于类型为 ''{3}'' 的 length ''{2}'', length = ''{1}'' 的值 ''{0}'' 不具有面有效性。
        cvc-maxExclusive-valid = cvc-maxExclusive-valid: 对于类型为 ''{2}'' 的 maxExclusive ''{1}'', 值 ''{0}'' 不具有面有效性。
        cvc-maxInclusive-valid = cvc-maxInclusive-valid: 对于类型为 ''{2}'' 的 maxInclusive ''{1}'', 值 ''{0}'' 不具有面有效性。
        cvc-maxLength-valid = cvc-maxLength-valid: 对于类型为 ''{3}'' 的 maxLength ''{2}'', length = ''{1}'' 的值 ''{0}'' 不具有面有效性。
        cvc-minExclusive-valid = cvc-minExclusive-valid: 对于类型为 ''{2}'' 的 minExclusive ''{1}'', 值 ''{0}'' 不具有面有效性。
        cvc-minInclusive-valid = cvc-minInclusive-valid: 对于类型为 ''{2}'' 的 minInclusive ''{1}'', 值 ''{0}'' 不具有面有效性。
        cvc-minLength-valid = cvc-minLength-valid: 对于类型为 ''{3}'' 的 minLength ''{2}'', length = ''{1}'' 的值 ''{0}'' 不具有面有效性。
        cvc-pattern-valid = cvc-pattern-valid: 对于类型为 ''{2}'' 的模式 ''{1}'', 值 ''{0}'' 不具有面有效性。
        cvc-totalDigits-valid = cvc-totalDigits-valid: 值 ''{0}'' 总共有 {1} 位, 但总位数已限制为 {2}。
        cvc-type.1 = cvc-type.1: 找不到类型定义 ''{0}''。
        cvc-type.2 = cvc-type.2: 无法为元素 {0} 提取类型定义。
        cvc-type.3.1.1 = cvc-type.3.1.1: 元素 ''{0}'' 是简单类型, 因此必须不含属性 (除了那些名称空间名与 ''http://www.w3.org/2001/XMLSchema-instance'' 相同且 [本地名称] 为 ''type'', ''nil'', ''schemaLocation'' 或 ''noNamespaceSchemaLocation'' 的元素)。但是发现了属性 ''{1}''。
        cvc-type.3.1.2 = cvc-type.3.1.2: 元素 ''{0}'' 是简单类型, 因此它必须不含元素信息项 [子级]。
        cvc-type.3.1.3 = cvc-type.3.1.3: 元素 ''{0}'' 的值 ''{1}'' 无效。

#schema valid (3.X.3)

        schema_reference.access = schema_reference: 由于 accessExternalSchema 属性设置的限制而不允许 ''{1}'' 访问, 因此无法读取方案文档 ''{0}''。
        schema_reference.4 = schema_reference.4: 无法读取方案文档 ''{0}'', 原因为 1) 无法找到文档; 2) 无法读取文档; 3) 文档的根元素不是 <xsd:schema>。
        src-annotation = src-annotation: <annotation> 元素只能包含 <appinfo> 和 <documentation> 元素, 但发现了 ''{0}''。
        src-attribute.1 = src-attribute.1: 属性声明 ''{0}'' 中不能同时存在特性 ''default'' 和 ''fixed''。应只使用其中一个。
        src-attribute.2 = src-attribute.2: 属性 ''{0}'' 中存在特性 ''default'', 因此 ''use'' 的值必须为 ''optional''。
        src-attribute.3.1 = src-attribute.3.1: 本地属性声明中必须存在 'ref' 或 'name' 之一。
        src-attribute.3.2 = src-attribute.3.2: 属性引用 ''{0}'' 中的内容必须匹配 (批注?)。
        src-attribute.4 = src-attribute.4: 属性 ''{0}'' 同时具有 ''type'' 属性和匿名 ''simpleType'' 子级。一个属性只能具有这两者之一。
        src-attribute_group.2 = src-attribute_group.2: 无法表达属性组 ''{0}'' 的通配符交集。
        src-attribute_group.3 = src-attribute_group.3: 在属性组 ''{0}'' 中检测到循环定义。递归跟随属性组引用最终将引导回自身。
        src-ct.1 = src-ct.1: 类型 ''{0}'' 的复杂类型定义的表达形式错误。使用 <complexContent> 时, 基类型必须为 complexType。''{1}'' 是 simpleType。
        src-ct.2.1 = src-ct.2.1: 类型 ''{0}'' 的复杂类型定义的表达形式错误。使用 <simpleContent> 时, 基类型必须为 complexType, 其内容类型为“简单”, 或者为具有“混合”内容和可空粒子的复杂类型 (仅当指定了限制时), 或者为简单类型 (仅当指定了扩展时)。''{1}'' 不满足所有这些条件。
        src-ct.2.2 = src-ct.2.2: 类型 ''{0}'' 的复杂类型定义的表达形式错误。如果具有 simpleContent 的 complexType 限制具有“混合”内容和可空粒子的 complexType, 那么 <restriction> 的子级中必须存在 <simpleType>。
        src-ct.4 = src-ct.4: 类型 ''{0}'' 的复杂类型定义的表达形式错误。无法表达通配符的交集。
        src-ct.5 = src-ct.5: 类型 ''{0}'' 的复杂类型定义的表达形式错误。无法表达通配符的并集。
        src-element.1 = src-element.1: 元素声明 ''{0}'' 中不能同时存在属性 ''default'' 和 ''fixed''。应只使用其中一个。
        src-element.2.1 = src-element.2.1: 本地元素声明中必须存在 'ref' 或 'name'。
        src-element.2.2 = src-element.2.2: 由于 ''{0}'' 包含 ''ref'' 属性, 其内容必须匹配 (批注?)。但是, 发现了 ''{1}''。
        src-element.3 = src-element.3: 元素 ''{0}'' 同时具有 ''type'' 属性和 ''anonymous type'' 子级。元素中只允许具有其中一项。
        src-import.1.1 = src-import.1.1: <import> 元素信息项的名称空间属性 ''{0}'' 不能与方案中其拥有的 targetNamespace 相同。
        src-import.1.2 = src-import.1.2: 如果 <import> 元素信息项中不存在名称空间属性, 则封闭方案中必须具有 targetNamespace。
        src-import.2 = src-import.2: 文档 ''{0}'' 的根元素必须具有名称空间名 ''http://www.w3.org/2001/XMLSchema'' 和本地名称 ''schema''。
        src-import.3.1 = src-import.3.1: <import> 元素信息项的名称空间属性 ''{0}'' 必须与导入文档的 targetNamespace 属性 ''{1}'' 相同。
        src-import.3.2 = src-import.3.2: 发现了没有名称空间属性的 <import> 元素信息项, 因此导入文档必须不含 targetNamespace 属性。但是, 在导入文档中发现了 targetNamespace ''{1}''。
        src-include.1 = src-include.1: 文档 ''{0}'' 的根元素必须具有名称空间名 ''http://www.w3.org/2001/XMLSchema'' 和本地名称 ''schema''。
        src-include.2.1 = src-include.2.1: 引用的方案 (当前为 ''{1}'') 的 targetNamespace 必须与包含的方案 (当前为 ''{0}'') 的 targetNamespace 相同。
        src-redefine.2 = src-redefine.2: 文档 ''{0}'' 的根元素必须具有名称空间名 ''http://www.w3.org/2001/XMLSchema'' 和本地名称 ''schema''。
        src-redefine.3.1 = src-redefine.3.1: 引用的方案 (当前为 ''{1}'') 的 targetNamespace 必须与重新定义的方案 (当前为 ''{0}'') 的 targetNamespace 相同。
        src-redefine.5.a.a = src-redefine.5.a.a: 找不到 <simpleType> 的非批注子级。<redefine> 元素的 <simpleType> 子级必须具有 <restriction> 子项, 并带有引用其自身的 'base' 属性。
        src-redefine.5.a.b = src-redefine.5.a.b: ''{0}'' 不是有效的子元素。<redefine> 元素的 <simpleType> 子级必须具有 <restriction> 子项, 并带有引用其自身的 ''base'' 属性。
        src-redefine.5.a.c = src-redefine.5.a.c: ''{0}'' 不含引用重新定义的元素 ''{1}'' 的 ''base'' 属性。<redefine> 元素的 <simpleType> 子级必须具有 <restriction> 子项, 并带有引用其自身的 ''base'' 属性。
        src-redefine.5.b.a = src-redefine.5.b.a: 找不到 <complexType> 的非批注子级。<redefine> 元素的 <complexType> 子级必须具有 <extension> 或 <restriction> 子项, 并带有引用其自身的 'base' 属性。
        src-redefine.5.b.b = src-redefine.5.b.b: 找不到 <complexType> 的非批注子子级。<redefine> 元素的 <complexType> 子级必须具有 <extension> 或 <restriction> 子项, 并带有引用其自身的 'base' 属性。
        src-redefine.5.b.c = src-redefine.5.b.c: ''{0}'' 不是有效的子子级元素。<redefine> 元素的 <complexType> 子级必须具有 <extension> 或 <restriction> 子项, 并带有引用其自身的 ''base'' 属性。
        src-redefine.5.b.d = src-redefine.5.b.d: ''{0}'' 不含引用重新定义的元素 ''{1}'' 的 ''base'' 属性。<redefine> 元素的 <complexType> 子级必须具有 <extension> 或 <restriction> 子项, 并带有引用其自身的 ''base'' 属性。
        src-redefine.6.1.1 = src-redefine.6.1.1: 如果 <redefine> 元素的组子级包含引用其自身的组, 则它必须正好包含一个组; 此组具有 ''{0}''。
        src-redefine.6.1.2 = src-redefine.6.1.2: 组 ''{0}'' (包含对要重新定义的组的引用) 必须满足 ''minOccurs'' = ''maxOccurs'' = 1。
        src-redefine.6.2.1 = src-redefine.6.2.1: 重新定义的方案中无名称与 ''{0}'' 匹配的组。
        src-redefine.6.2.2 = src-redefine.6.2.2: 组 ''{0}'' 未正确限制其重新定义的组; 违反了约束条件: ''{1}''。
        src-redefine.7.1 = src-redefine.7.1: 如果 <redefine> 元素的 attributeGroup 子级包含引用其自身的 attributeGroup, 则它必须正好包含一个组; 此组具有 {0}。
        src-redefine.7.2.1 = src-redefine.7.2.1: 重新定义的方案中没有名称与 ''{0}'' 匹配的 attributeGroup。
        src-redefine.7.2.2 = src-redefine.7.2.2: AttributeGroup ''{0}'' 未正确限制其重新定义的 attributeGroup; 违反了约束条件: ''{1}''。
        src-resolve = src-resolve: 无法将名称 ''{0}'' 解析为 ''{1}'' 组件。
        src-resolve.4.1 = src-resolve.4.1: 解析组件 ''{2}'' 时出错。在该组件中检测到 ''{2}'' 没有名称空间, 但无法从方案文档 ''{0}'' 引用没有目标名称空间的组件。如果 ''{2}'' 需要具有名称空间, 则很可能需要提供前缀。如果 ''{2}'' 不需要具有名称空间, 则应将没有 "namespace" 属性的 ''import'' 添加到 ''{0}''。
        src-resolve.4.2 = src-resolve.4.2: 解析组件 ''{2}'' 时出错。在该组件中检测到 ''{2}'' 位于名称空间 ''{1}'' 中, 但无法从方案文档 ''{0}'' 引用此名称空间的组件。如果这是不正确的名称空间, 则很可能需要更改 ''{2}'' 的前缀。如果这是正确的名称空间, 则应将适当的 ''import'' 标记添加到 ''{0}''。
        src-simple-type.2.a = src-simple-type.2.a: 发现 <restriction> 元素的 [子级] 中同时具有基 [属性] 和 <simpleType> 元素。只允许具有一个。
        src-simple-type.2.b = src-simple-type.2.b: 发现 <restriction> 元素的 [子级] 中既没有基 [属性], 也没有 <simpleType> 元素。必须具有其中一个。
        src-simple-type.3.a = src-simple-type.3.a: 发现 <list> 元素的 [子级] 中同时具有 itemType [属性] 和 <simpleType> 元素。只允许具有一个。
        src-simple-type.3.b = src-simple-type.3.b: 发现 <list> 元素的 [子级] 中既没有 itemType [属性], 也没有 <simpleType> 元素。必须具有其中一个。
        src-single-facet-value = src-single-facet-value: 多次定义了面 ''{0}''。
        src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: <union> 元素的 [子级] 中必须具有非空 memberTypes [属性] 或至少一个 <simpleType> 元素。

#constraint valid (3.X.6)

        ag-props-correct.2 = ag-props-correct.2: 属性组 ''{0}'' 错误。指定了具有相同名称和目标名称空间的重复属性用法。重复属性用法的名称为 ''{1}''。
        ag-props-correct.3 = ag-props-correct.3: 属性组 ''{0}'' 错误。两个属性声明 ''{1}'' 和 ''{2}'' 具有的类型是从 ID 派生的。
        a-props-correct.2 = a-props-correct.2: 属性 ''{0}'' 中的值约束条件的值 ''{1}'' 无效。
        a-props-correct.3 = a-props-correct.3: 属性 ''{0}'' 不能使用 ''fixed'' 或 ''default'', 因为其 '{'type definition'}' 为 ID, 或者是从 ID 派生的。
        au-props-correct.2 = au-props-correct.2: 在 ''{0}'' 的属性声明中, 指定了固定值 ''{1}''。因此如果引用 ''{0}'' 的属性用法同时具有 '{'value constraint'}', 则它必须是固定的, 并且其值必须为 ''{1}''。
        cos-all-limited.1.2 = cos-all-limited.1.2: '{'min occurs'}' = '{'max occurs'}' = 1 的粒子中必须包含 'all' 模型组, 该粒子必须是组成复杂类型定义的 '{'content type'}' 对的一部分。
        cos-all-limited.2 = cos-all-limited.2: 在 ''all'' 模型组中元素的 '{'max occurs'}' 必须为 0 或 1。元素 ''{1}'' 的值 ''{0}'' 无效。
        cos-applicable-facets = cos-applicable-facets: 类型 {1} 不允许面 ''{0}''。
        cos-ct-extends.1.1 = cos-ct-extends.1.1: 类型 ''{0}'' 是从类型 ''{1}'' 的扩展派生的。但是, ''{1}'' 的 ''final'' 属性禁止由扩展派生。
        cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: 派生类型及其基类型的内容类型都必须为“混合”或“仅元素”。类型 ''{0}'' 为“仅元素”, 但其基类型不是。
        cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: 派生类型及其基类型的内容类型都必须为“混合”或“仅元素”。类型 ''{0}'' 为“混合”, 但其基类型不是。
        cos-element-consistent = cos-element-consistent: 类型 ''{0}'' 错误。模型组中存在名称为 ''{1}'' 且具有不同类型的多个元素。
        cos-list-of-atomic = cos-list-of-atomic: 在列表类型 ''{0}'' 的定义中, 类型 ''{1}'' 是无效的列表元素类型, 因为它不是原子 (''{1}'' 既不是列表类型, 也不是包含列表的联合类型)。
        cos-nonambig = cos-nonambig: {0} 和 {1} (或来自其替代组的元素) 违反了 "唯一粒子属性"。根据此方案进行验证期间, 这两个粒子会造成歧义。
        cos-particle-restrict.a = cos-particle-restrict.a: 派生的粒子为空, 而基粒子不可为空。
        cos-particle-restrict.b = cos-particle-restrict.b: 基粒子为空, 但派生粒子不为空。
        cos-particle-restrict.2 = cos-particle-restrict.2: 禁止粒子限制: ''{0}''。
        cos-st-restricts.1.1 = cos-st-restricts.1.1: 类型 ''{1}'' 为原子, 因此其 '{'base type definition'}' ''{0}'' 必须为原子简单类型定义或内置基元数据类型。
        cos-st-restricts.2.1 = cos-st-restricts.2.1: 在列表类型 ''{0}'' 的定义中, 类型 ''{1}'' 是无效的项类型, 因为它既不是列表类型, 也不是包含列表的联合类型。
        cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: '{'item type definition'}' 的 '{'final'}' 组件 ''{0}'' 包含 ''list''。这表示 ''{0}'' 不能用作列表类型 ''{1}'' 的项类型。
        cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: '{'member type definitions'}' ''{0}'' 的 '{'final'}' 组件包含 ''union''。这表示 ''{0}'' 不能用作联合类型 ''{1}'' 的成员类型。
        cos-valid-default.2.1 = cos-valid-default.2.1: 元素 ''{0}'' 具有值约束条件, 并且必须具有“混合”或“简单”内容模型。
        cos-valid-default.2.2.2 = cos-valid-default.2.2.2: 由于元素 ''{0}'' 具有 '{'value constraint'}', 并且其类型定义具有混合的 '{'content type'}', 则 '{'content type'}' 的粒子必须可为空。
        c-props-correct.2 = c-props-correct.2: 键引用 ''{0}'' 和键 ''{1}'' 中字段的基数必须相同。
        ct-props-correct.3 = ct-props-correct.3: 在复杂类型 ''{0}'' 中检测到循环定义。这表示 ''{0}'' 包含在其自身的类型分层结构中, 这是错误的。
        ct-props-correct.4 = ct-props-correct.4: 类型 ''{0}'' 错误。指定了具有相同名称和目标名称空间的重复属性用法。重复属性用法的名称为 ''{1}''。
        ct-props-correct.5 = ct-props-correct.5: 类型 ''{0}'' 错误。两个属性声明 ''{1}'' 和 ''{2}'' 具有从 ID 派生的类型。
        derivation-ok-restriction.1 = derivation-ok-restriction.1: 类型 ''{0}'' 由限制从类型 ''{1}'' 派生。但是, ''{1}'' 具有禁止由限制派生的 '{'final'}' 属性。
        derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 具有 ''{2}'' 的 ''use'' 值, 这与基类型中的匹配属性用法的 ''required'' 值不一致。
        derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.1.2: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 具有类型 ''{2}'', 它不是从基类型中的匹配属性用法的类型 ''{3}'' 有效派生的。
        derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 具有不固定的有效值约束条件, 而基类型中的匹配属性用法的有效值约束条件是固定的。
        derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 具有值为 ''{2}'' 的固定有效值约束条件, 这与基类型中的匹配属性用法的固定有效值约束条件的值 ''{3}'' 不一致。
        derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 在基类型中没有匹配的属性用法, 并且基类型没有通配符属性。
        derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: 类型 ''{0}'' 错误。此类型中的属性用法 ''{1}'' 在基类型中没有匹配的属性用法, 并且基类型中的通配符不允许此属性用法的名称空间 ''{2}''。
        derivation-ok-restriction.3 = derivation-ok-restriction.3: 类型 ''{0}'' 错误。基类型中的属性用法 ''{1}'' 的 REQUIRED 为“真”, 但在派生类型中没有匹配的属性用法。
        derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: 类型 ''{0}'' 错误。派生类型具有一个属性通配符, 但基类型不具有属性通配符。
        derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: 类型 ''{0}'' 错误。派生类型中的通配符不是基类型中通配符的有效通配符子集。
        derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: 类型 ''{0}'' 错误。派生类型 ({1}) 中通配符的流程内容弱于基类型 ({2}) 中通配符的流程内容。
        derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: 类型 ''{0}'' 错误。此类型的简单内容类型 ''{1}'' 不在基类型的简单内容类型 ''{2}'' 的有效限制之内。
        derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: 类型 ''{0}'' 错误。此类型的内容类型为空, 但基类型的内容类型 ''{1}'' 不为空或不能为空。
        derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: 类型 ''{0}'' 错误。此类型的内容类型为“混合”, 但基类型的内容类型 ''{1}'' 不为“混合”。
        derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: 类型 ''{0}'' 错误。此类型的粒子不在基类型的粒子的有效限制之内。
        enumeration-required-notation = enumeration-required-notation: {2} ''{1}'' 使用的 NOTATION 类型 ''{0}'' 必须具有枚举面值, 用于指定此类型使用的注释元素。
        enumeration-valid-restriction = enumeration-valid-restriction: 枚举值 ''{0}'' 不在基类型 {1} 的值空间中。
        e-props-correct.2 = e-props-correct.2: 元素 ''{0}'' 中的值约束条件的值 ''{1}'' 无效。
        e-props-correct.4 = e-props-correct.4: 元素 ''{0}'' 的 '{'type definition'}' 不是从 substitutionHead ''{1}'' 的 '{'type definition'}' 有效派生的, 或者 ''{1}'' 的 '{'substitution group exclusions'}' 属性不允许进行此派生。
        e-props-correct.5 = e-props-correct.5: 元素 ''{0}'' 中不能包含 '{'value constraint'}', 因为元素的 '{'type definition'}' 或 '{'type definition'}' 的 '{'content type'}' 为 ID, 或者是从 ID 派生的。
        e-props-correct.6 = e-props-correct.6: 在元素 ''{0}'' 中检测到循环替代组。
        fractionDigits-valid-restriction = fractionDigits-valid-restriction: 在 {2} 的定义中, 面 ''fractionDigits'' 的值 ''{0}'' 无效, 因为该值必须小于等于 ''fractionDigits'' 的值, 但在原级类型之一中已将其设置为 ''{1}''。
        fractionDigits-totalDigits = fractionDigits-totalDigits: 在 {2} 的定义中, 面 ''fractionDigits'' 的值 ''{0}'' 无效, 因为该值必须小于等于 ''totalDigits'' 的值 ''{1}''。
        length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: 对于类型 {0}, 长度 ''{1}'' 的值小于 minLength 的值 ''{2}'' 是错误的。
        length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: 对于类型 {0}, 如果当前限制具有 minLength 面并且当前限制或基类型具有 length 面, 则基类型没有 minLength 面是错误的。
        length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: 对于类型 {0}, 当前 minLength ''{1}'' 不等于基类型 minLength ''{2}'' 是错误的。
        length-minLength-maxLength.2.1 = length-minLength-maxLength.2.1: 对于类型 {0}, 长度 ''{1}'' 的值大于 maxLength ''{2}'' 的值是错误的。
        length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: 对于类型 {0}, 如果当前限制具有 maxLength 面并且当前限制或基类型具有 length 面, 则基类型没有 maxLength 面是错误的。
        length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: 对于类型 {0}, 当前 maxLength ''{1}'' 不等于基类型 maxLength ''{2}'' 是错误的。
        length-valid-restriction = length-valid-restriction: 类型 ''{2}'' 错误。长度的值 ''{0}'' 必须等于基类型 ''{1}'' 的长度值。
        maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: 类型 ''{2}'' 错误。maxExclusive 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxExclusive。
        maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: 类型 ''{2}'' 错误。maxExclusive 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxInclusive。
        maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: 类型 ''{2}'' 错误。maxExclusive 值 ''{0}'' 必须大于基类型 ''{1}'' 的 minInclusive。
        maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.4: 类型 ''{2}'' 错误。maxExclusive 值 ''{0}'' 必须大于基类型 ''{1}'' 的 minExclusive。
        maxInclusive-maxExclusive = maxInclusive-maxExclusive: 为同一个数据类型同时指定 maxInclusive 和 maxExclusive 是错误的。在 {2} 中, maxInclusive = ''{0}'' 并且 maxExclusive = ''{1}''。
        maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: 类型 ''{2}'' 错误。maxInclusive 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxInclusive。
        maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: 类型 ''{2}'' 错误。maxInclusive 值 ''{0}'' 必须小于基类型 ''{1}'' 的 maxExclusive。
        maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: 类型 ''{2}'' 错误。maxInclusive 值 ''{0}'' 必须大于等于基类型 ''{1}'' 的 minInclusive。
        maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: 类型 ''{2}'' 错误。maxInclusive 值 ''{0}'' 必须大于基类型 ''{1}'' 的 minExclusive。
        maxLength-valid-restriction = maxLength-valid-restriction: 在 {2} 的定义中, maxLength 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxLength。
        mg-props-correct.2 = mg-props-correct.2: 在组 ''{0}'' 中检测到循环定义。递归跟随粒子的 '{'term'}' 以下值会引导到其 '{'term'}' 是组自身的粒子。
        minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: 在 {2} 的定义中, minExclusive 值 ''{0}'' 必须小于等于 maxExclusive 值 ''{1}''。
        minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: 在 {2} 的定义中, minExclusive 值 ''{0}'' 必须小于 maxInclusive 值 ''{1}''。
        minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: 类型 ''{2}'' 错误。minExclusive 值 ''{0}'' 必须大于等于基类型 ''{1}'' 的 minExclusive。
        minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: 类型 ''{2}'' 错误。minExclusive 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxInclusive。
        minExclusive-valid-restriction.3 = minExclusive-valid-restriction.3: 类型 ''{2}'' 错误。minExclusive 值 ''{0}'' 必须大于等于基类型 ''{1}'' 的 minInclusive。
        minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: 类型 ''{2}'' 错误。minExclusive 值 ''{0}'' 必须小于基类型 ''{1}'' 的 maxExclusive。
        minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: 在 {2} 的定义中, minInclusive 值 ''{0}'' 必须小于等于 maxInclusive 值 ''{1}''。
        minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: 在 {2} 的定义中, minInclusive 值 ''{0}'' 必须小于 maxExclusive 值 ''{1}''。
        minInclusive-minExclusive = minInclusive-minExclusive: 为同一个数据类型同时指定 minInclusive 和 minExclusive 是错误的。在 {2} 中, minInclusive = ''{0}'' 并且 minExclusive = ''{1}''。
        minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: 类型 ''{2}'' 错误。minInclusive 值 ''{0}'' 必须大于等于基类型 ''{1}'' 的 minInclusive。
        minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: 类型 ''{2}'' 错误。minInclusive 值 ''{0}'' 必须小于等于基类型 ''{1}'' 的 maxInclusive。
        minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: 类型 ''{2}'' 错误。minInclusive 值 ''{0}'' 必须大于基类型 ''{1}'' 的 minExclusive。
        minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: 类型 ''{2}'' 错误。minInclusive 值 ''{0}'' 必须小于基类型 ''{1}'' 的 maxExclusive。
        minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: 在 {2} 的定义中, minLength 的值 ''{0}'' 必须小于 maxLength 的值 ''{1}''。
        minLength-valid-restriction = minLength-valid-restriction: 在 {2} 的定义中, minLength ''{0}'' 必须大于等于基类型的 minLength ''{1}''。
        no-xmlns = no-xmlns: 属性声明的 {name} 不能与 'xmlns' 匹配。
        no-xsi = no-xsi: 属性声明的 '{'target namespace'}' 不能与 ''{0}'' 匹配。
        p-props-correct.2.1 = p-props-correct.2.1: 在 ''{0}'' 的声明中, ''minOccurs'' 的值为 ''{1}'', 但该值不能大于 ''maxOccurs'' 的值 ''{2}''。
        rcase-MapAndSum.1 = rcase-MapAndSum.1: 粒子之间没有完整的功能映射。
        rcase-MapAndSum.2 = rcase-MapAndSum.2: 组的发生范围 ({0},{1}) 不在基组的发生范围 ({2},{3}) 的有效限制之内。
        rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: 元素的名称和目标名称空间不相同: 名称空间 ''{1}'' 中的元素为 ''{0}'', 名称空间 ''{3}'' 中的元素为 ''{2}''。
        rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: 其 '{'term'}' 为元素声明 ''{0}'' 的粒子错误。元素声明的 '{'nillable'}' 为“真”, 但基类型中对应的粒子具有 '{'nillable'}' 为“假”的元素声明。
        rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3：其 '{'term'}' 为元素声明 ''{0}'' 的粒子错误。该粒子的发生范围 ({1},{2}) 不在基类型中对应粒子的范围 ({3},{4}) 的有效限制之内。
        rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: 元素 ''{0}'' 不是固定的, 但基类型中的对应元素是固定的, 且值为 ''{1}''。
        rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: 元素 ''{0}'' 是固定的, 且值为 ''{1}'', 但基类型中的对应元素是固定的, 且值为 ''{2}''。
        rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: 元素 ''{0}'' 的身份约束条件不是基类型中那些身份约束条件的子集。
        rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: 元素 ''{0}'' 的不接受替代不是基元素中不接受替代的超集。
        rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: 元素 ''{0}'' 的类型 ''{1}'' 不是从基元素的类型 ''{2}'' 派生的。
        rcase-NSCompat.1 = rcase-NSCompat.1: 元素 ''{0}'' 具有名称空间 ''{1}'', 在基元素中, 通配符不允许具有此名称空间。
        rcase-NSCompat.2 = rcase-NSCompat.2：其 '{'term'}' 为元素声明 ''{0}'' 的粒子错误。该粒子的发生范围 ({1},{2}) 不在基类型中对应粒子的范围 ({3},{4}) 的有效限制之内。
        rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: 粒子之间没有完整的功能映射。
        rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: 组的发生范围 ({0},{1}) 不在基本通配符范围 ({2},{3}) 的有效限制之内。
        rcase-NSSubset.1 = rcase-NSSubset.1: 通配符不是基本通配符中对应通配符的子集。
        rcase-NSSubset.2 = rcase-NSSubset.2: 通配符的发生范围 ({0},{1}) 不在基本通配符中发生范围 ({2},{3}) 的有效限制之内。
        rcase-NSSubset.3 = rcase-NSSubset.3: 通配符的流程内容 ''{0}'' 弱于基本通配符中的流程内容 ''{1}''。
        rcase-Recurse.1 = rcase-Recurse.1: 组的发生范围 ({0},{1}) 不在基组的发生范围 ({2},{3}) 的有效限制之内。
        rcase-Recurse.2 = rcase-Recurse.2: 粒子之间没有完整的功能映射。
        rcase-RecurseLax.1 = rcase-RecurseLax.1: 组的发生范围 ({0},{1}) 不在基组的发生范围 ({2},{3}) 的有效限制之内。
        rcase-RecurseLax.2 = rcase-RecurseLax.2: 粒子之间没有完整的功能映射。
        rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: 组的发生范围 ({0},{1}) 不在基组的发生范围 ({2},{3}) 的有效限制之内。
        rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: 粒子之间没有完整的功能映射。
#        We're using sch-props-correct.2 instead of the old src-redefine.1
#        src-redefine.1 = src-redefine.1: The component ''{0}'' is begin redefined, but its corresponding component isn't in the schema document being redefined (with namespace ''{2}''), but in a different document, with namespace ''{1}''.
        sch-props-correct.2 = sch-props-correct.2: 方案不能包含具有相同名称的两个全局组件; 而此方案中包含两个 ''{0}''。
        st-props-correct.2 = st-props-correct.2: 在简单类型 ''{0}'' 中检测到循环定义。这表示 ''{0}'' 包含在其自身的类型分层结构中, 这是错误的。
        st-props-correct.3 = st-props-correct.3: 类型 ''{0}'' 错误。'{'base type definition'}' 的 '{'final'}' 的值 ''{1}'' 禁止由限制派生。
        totalDigits-valid-restriction = totalDigits-valid-restriction: 在 {2} 的定义中, 面 ''totalDigits'' 的值 ''{0}'' 无效, 因为该值必须小于等于 ''totalDigits'' 的值, 而在原级类型之一中已将其设置为 ''{1}''。
        whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: 在 {0} 的定义中, 面 ''whitespace'' 的值 ''{1}'' 无效, 因为 ''whitespace'' 的值已在原级类型之一中设置为 ''collapse''。
        whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: 在 {0} 的定义中, 面 ''whitespace'' 的值 ''preserve'' 无效, 因为 ''whitespace'' 的值已在原级类型之一中设置为 ''replace''。

#schema for Schemas

        s4s-att-invalid-value = s4s-att-invalid-value: 元素 ''{0}'' 中 ''{1}'' 的属性值无效。记录的原因: {2}
        s4s-att-must-appear = s4s-att-must-appear: 元素 ''{0}'' 中必须包含属性 ''{1}''。
        s4s-att-not-allowed = s4s-att-not-allowed: 元素 ''{0}'' 中不能包含属性 ''{1}''。
        s4s-elt-invalid = s4s-elt-invalid: 元素 ''{0}'' 不是方案文档中的有效元素。
        s4s-elt-must-match.1 = s4s-elt-must-match.1: ''{0}'' 的内容必须与 {1} 匹配。发现问题, 开始于: {2}。
        s4s-elt-must-match.2 = s4s-elt-must-match.2: ''{0}'' 的内容必须与 {1} 匹配。找不到足够的元素。
        # the "invalid-content" messages provide less information than the "must-match" counterparts above. They're used for complex types when providing a "match" would be an information dump
        s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: ''{0}'' 的内容无效。元素 ''{1}'' 无效, 所放位置错误或出现次数过多。
        s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: ''{0}'' 的内容无效。元素 ''{1}'' 不能为空。
        s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: 类型为 ''{0}'' 的元素不能在声明的后面作为 <schema> 元素的子级出现。
        s4s-elt-schema-ns = s4s-elt-schema-ns: 元素 ''{0}'' 的名称空间必须来自方案名称空间 ''http://www.w3.org/2001/XMLSchema''。
        s4s-elt-character = s4s-elt-character: 方案元素中不允许出现除 ''xs:appinfo'' 和 ''xs:documentation'' 之外的非空格字符。发现了 ''{0}''。

# codes not defined by the spec

        c-fields-xpaths = c-fields-xpaths: 字段值 ''{0}'' 无效。
        c-general-xpath = c-general-xpath: 表达式 ''{0}'' 与 XML 方案所支持的 XPath 子集不匹配。
        c-general-xpath-ns = c-general-xpath-ns: XPath 表达式 ''{0}'' 中的名称空间前缀未绑定到名称空间。
        c-selector-xpath = c-selector-xpath: 选择器值 ''{0}'' 无效; 选择器 xpath 不能包含属性。
        EmptyTargetNamespace = EmptyTargetNamespace: 在方案文档 ''{0}'' 中, ''targetNamespace'' 属性的值不能为空字符串。
        FacetValueFromBase = FacetValueFromBase: 在类型 ''{0}'' 的声明中, 面 ''{2}'' 的值 ''{1}'' 必须来自基类型的值空间 ''{3}''。
        FixedFacetValue = FixedFacetValue: 在 {3} 的定义中, 面 ''{0}'' 的值 ''{1}'' 无效, 因为 ''{0}'' 的值已在原级类型之一中设置为 ''{2}'', 并且 '{'fixed'}' = true。
        InvalidRegex = InvalidRegex：模式值 ''{0}'' 不是有效的正则表达式。报告的错误为：''{1}''。
        MaxOccurLimit = 解析器的当前配置不允许将复杂类型的内容模型扩展到包含 {0} 个以上节点。
        PublicSystemOnNotation = PublicSystemOnNotation: 元素 ''notation'' 中必须至少出现 ''public'' 和 ''system'' 中的一个。
        SchemaLocation = SchemaLocation: schemaLocation 值 ''{0}'' 必须具有偶数个 URI。
        TargetNamespace.1 = TargetNamespace.1: 应为名称空间 ''{0}'', 但方案文档的目标名称空间为 ''{1}''。
        TargetNamespace.2 = TargetNamespace.2: 不需要名称空间, 但此方案文档的目标名称空间为 ''{1}''。
        UndeclaredEntity = UndeclaredEntity: 未声明实体 ''{0}''。
        UndeclaredPrefix = UndeclaredPrefix: 无法将 ''{0}'' 解析为限定名: 未声明前缀 ''{1}''。
        FacetsContradict = FacetsContradict：对于 simpleType 定义 ''{2}''，枚举值 ''{0}'' 与 ''{1}'' 面的值冲突。

# JAXP 1.2 schema source property errors

        jaxp12-schema-source-type.1 = ''http://java.sun.com/xml/jaxp/properties/schemaSource'' 属性不能具有 ''{0}'' 类型的值。可支持的值类型包括 String, File, InputStream, InputSource 或这些类型的数组。
        jaxp12-schema-source-type.2 = ''http://java.sun.com/xml/jaxp/properties/schemaSource'' 属性不能具有 ''{0}'' 类型的数组值。可支持的数组类型包括 Object, String, File, InputStream 和 InputSource。
        jaxp12-schema-source-ns = 使用对象数组作为 'http://java.sun.com/xml/jaxp/properties/schemaSource' 属性的值时, 有两个方案共享相同的目标名称空间是非法的。
