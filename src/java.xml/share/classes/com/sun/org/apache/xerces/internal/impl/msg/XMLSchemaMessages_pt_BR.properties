#
# Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

# This file contains error and warning messages related to XML Schema
# The messages are arranged in key and value tuples in a ListResourceBundle.

        BadMessageKey = Não foi possível encontrar a mensagem de erro correspondente à chave da mensagem.
        FormatFailed = Ocorreu um erro interno ao formatar a mensagem a seguir:\n

# For internal use

        Internal-Error = Erro interno: {0}.
        dt-whitespace = O valor do aspecto do espaço em branco não está disponível para o simpleType ''{0}'' da união
        GrammarConflict = Uma das gramáticas retornadas do pool de gramática do usuário está em conflito com outra.

# Identity constraints

        AbsentKeyValue = cvc-identity-constraint.4.2.1.a: O Elemento "{0}" não tem valor para a chave "{1}".
        DuplicateField = Correspondência duplicada no escopo do campo "{0}".
        DuplicateKey = cvc-identity-constraint.4.2.2: Valor de chave duplicado [{0}] declarado para a restrição de identidade "{2}" do elemento "{1}".
        DuplicateUnique = cvc-identity-constraint.4.1: Valor exclusivo duplicado [{0}] declarado para a restrição de identidade "{2}" do elemento "{1}".
        FieldMultipleMatch = cvc-identity-constraint.3: O campo "{0}" da restrição de identidade "{1}" corresponde a mais de um valor no escopo de seu seletor; os campos devem corresponder a valores exclusivos.
        FixedDiffersFromActual = O conteúdo deste elemento não é equivalente ao valor do atributo "fixed" na declaração do elemento do esquema.
        KeyMatchesNillable = cvc-identity-constraint.4.2.3: O elemento "{0}" tem a chave "{1}" que corresponde a um elemento que tem o valor anulável definido como verdadeiro.
        KeyNotEnoughValues = cvc-identity-constraint.4.2.1.b: Valores insuficientes especificados para a restrição de identidade <key name="{1}"> especificada para o elemento "{0}".
        KeyNotFound = cvc-identity-constraint.4.3: A Chave ''{0}'' com o valor ''{1}'' não foi encontrada para a restrição de identidade do elemento ''{2}''.
        KeyRefOutOfScope = Erro de restrição de identidade: a restrição de identidade "{0}" tem uma keyref que se refere a uma chave exclusiva a qual está fora do escopo.
        KeyRefReferNotFound = A declaração de referência da chave "{0}" refere-se a uma chave com o nome "{1}".
        UnknownField = Erro interno de restrição de identidade; o campo desconhecido "{0}" para a restrição de identidade "{2}" foi especificado para o elemento "{1}".

# Ideally, we should only use the following error keys, not the ones under
# "Identity constraints". And we should cover all of the following errors.

#validation (3.X.4)

        cvc-attribute.3 = cvc-attribute.3: O valor ''{2}'' do atributo ''{1}'' no elemento ''{0}'' não é válido em relação ao seu tipo, ''{3}''.
        cvc-attribute.4 = cvc-attribute.4: O valor ''{2}'' do atributo ''{1}'' no elemento ''{0}'' não é válido em relação à sua '{'value constraint'}' fixa. O atributo deve ter um valor ''{3}''.
        cvc-complex-type.2.1 = cvc-complex-type.2.1: O elemento ''{0}'' não deve ter um caractere ou um item com informações do elemento [children] porque o tipo de conteúdo do tipo é vazio.
        cvc-complex-type.2.2 = cvc-complex-type.2.2: O elemento ''{0}'' não deve ter um elemento [children] e o valor deve ser válido.
        cvc-complex-type.2.3 = cvc-complex-type.2.3: O elemento ''{0}'' não pode ter um caractere [children] porque o tipo de conteúdo do tipo é somente elemento.
        cvc-complex-type.2.4.a = cvc-complex-type.2.4.a: Foi detectado um conteúdo inválido começando com o elemento ''{0}''. Era esperado um dos ''{1}''.
        cvc-complex-type.2.4.b = cvc-complex-type.2.4.b: O conteúdo do elemento ''{0}'' não está completo. Era esperado um dos ''{1}''.
        cvc-complex-type.2.4.c = cvc-complex-type.2.4.c: O curinga correspondente é restrito, mas nenhuma declaração pode ser encontrada para o elemento ''{0}''.
        cvc-complex-type.2.4.d = cvc-complex-type.2.4.d: Conteúdo inválido encontrado ao iniciar com o elemento ''{0}''. Nenhum elemento filho é esperado neste ponto.
        cvc-complex-type.2.4.d.1 = cvc-complex-type.2.4.d: Foi encontrado um conteúdo inválido começando com o elemento ''{0}''. Nenhum elemento filho "{1}" é esperado neste ponto.
        cvc-complex-type.2.4.e = cvc-complex-type.2.4.e: ''{0}'' pode ocorrer no máximo ''{2}'' vezes na sequência atual. Esse limite foi excedido. Nesse ponto, um de ''{1}'' é esperado.
        cvc-complex-type.2.4.f = cvc-complex-type.2.4.f: ''{0}'' pode ocorrer no máximo ''{1}'' vezes na sequência atual. Esse limite foi excedido. Nenhum elemento filho é esperado nesse ponto.
        cvc-complex-type.2.4.g = cvc-complex-type.2.4.g: Foi encontrado um conteúdo inválido que começa com o elemento ''{0}''. O esperado era que ''{1}'' ocorresse no mínimo ''{2}'' vezes na sequência atual. Uma instância a mais é necessária para satisfazer essa restrição.
        cvc-complex-type.2.4.h = cvc-complex-type.2.4.h: Foi encontrado um conteúdo inválido que começa com o elemento ''{0}''. O esperado era que ''{1}'' ocorresse no mínimo ''{2}'' vezes na sequência atual. ''{3}'' instâncias a mais são necessárias para satisfazer essa restrição.
        cvc-complex-type.2.4.i = cvc-complex-type.2.4.i: O conteúdo do elemento ''{0}'' não está completo. O esperado era que ''{1}'' ocorresse no mínimo ''{2}'' vezes. Uma instância a mais é necessária para satisfazer essa restrição.
        cvc-complex-type.2.4.j = cvc-complex-type.2.4.j: O conteúdo do elemento ''{0}'' não está completo. O esperado era que ''{1}'' ocorresse no mínimo ''{2}'' vezes. ''{3}'' instâncias a mais são necessárias para satisfazer essa restrição.
        cvc-complex-type.3.1 = cvc-complex-type.3.1: O valor ''{2}'' do atributo ''{1}'' do elemento ''{0}'' não é válido em relação ao uso do atributo correspondente. O atributo ''{1}'' tem um valor fixo de ''{3}''.
        cvc-complex-type.3.2.1 = cvc-complex-type.3.2.1: O elemento ''{0}'' não tem um curinga do atributo ''{1}''.
        cvc-complex-type.3.2.2 = cvc-complex-type.3.2.2: O atributo ''{1}'' não pode aparecer no elemento ''{0}''.
        cvc-complex-type.4 = cvc-complex-type.4: O atributo ''{1}'' deve aparecer no elemento ''{0}''.
        cvc-complex-type.5.1 = cvc-complex-type.5.1: No elemento ''{0}'', o atributo ''{1}'' é um ID Curinga, mas já existe um ID Curinga ''{2}''. Pode haver somente um.
        cvc-complex-type.5.2 = cvc-complex-type.5.2: No elemento, ''{0}'', o atributo ''{1}'' é um ID Curinga, mas já existe um atributo ''{2}'' obtido do ID entre os '{'attribute uses'}'.
        cvc-datatype-valid.1.2.1 = cvc-datatype-valid.1.2.1: ''{0}'' não é um valor válido para ''{1}''.
        cvc-datatype-valid.1.2.2 = cvc-datatype-valid.1.2.2: ''{0}'' não é um valor válido do tipo de lista ''{1}''.
        cvc-datatype-valid.1.2.3 = cvc-datatype-valid.1.2.3: ''{0}'' não é um valor válido do tipo de união ''{1}''.
        cvc-elt.1.a = cvc-elt.1.a: Não foi possível encontrar a declaração do elemento ''{0}''.
        cvc-elt.1.b = cvc-elt.1.b: O nome do elemento não corresponde ao nome da declaração do elemento. Foi visto ''{0}''. Era esperado ''{1}''.
        cvc-elt.2 = cvc-elt.2: O valor de "{"abstract"}" na declaração do elemento para ''{0}'' deve ser falso.
        cvc-elt.3.1 = cvc-elt.3.1: O atributo ''{1}'' não deve aparecer no elemento ''{0}'' porque a propriedade '{'nillable'}' de ''{0}'' é falsa.
        cvc-elt.3.2.1 = cvc-elt.3.2.1: O elemento ''{0}'' não pode ter informações de caractere ou de elemento [children] porque ''{1}'' foi especificado.
        cvc-elt.3.2.2 = cvc-elt.3.2.2: Não deve haver "{"value constraint"}" fixo para o elemento ''{0}'' porque ''{1}'' foi especificado.
        cvc-elt.4.1 = cvc-elt.4.1: O valor ''{2}'' do atributo ''{1}'' do elemento ''{0}'' não é um QName válido.
        cvc-elt.4.2 = cvc-elt.4.2: Não é possível resolver ''{1}'' para uma definição de tipo de elemento ''{0}''.
        cvc-elt.4.3 = cvc-elt.4.3: O tipo ''{1}'' não é obtido de forma válida da definição do tipo, ''{2}'', do elemento ''{0}''.
        cvc-elt.5.1.1 = cvc-elt.5.1.1: "{"value constraint"}" ''{2}'' do elemento ''{0}'' não é um valor padrão válido para o tipo ''{1}''.
        cvc-elt.5.2.2.1 = cvc-elt.5.2.2.1: O elemento ''{0}'' não deve ter item de informações do elemento [children].
        cvc-elt.5.2.2.2.1 = cvc-elt.5.2.2.2.1: O valor ''{1}'' do elemento ''{0}'' não corresponde ao valor fixo de '{'value constraint'}' ''{2}''.
        cvc-elt.5.2.2.2.2 = cvc-elt.5.2.2.2.2: O valor ''{1}'' do elemento ''{0}'' não corresponde ao valor de '{'value constraint'}' ''{2}'' .
        cvc-enumeration-valid = cvc-enumeration-valid: O valor ''{0}'' não tem um aspecto válido em relação à enumeração ''{1}''. Deve ser um valor da enumeração.
        cvc-fractionDigits-valid = cvc-fractionDigits-valid: O valor ''{0}'' tem {1} dígitos fracionários, mas o número de dígitos fracionários foi limitado a {2}.
        cvc-id.1 = cvc-id.1: Não há associação de ID/IDREF para IDREF ''{0}''.
        cvc-id.2 = cvc-id.2: Há várias ocorrências do valor do ID ''{0}''.
        cvc-id.3 = cvc-id.3: Um campo da restrição de identidade ''{0}'' correspondia ao elemento ''{1}'', mas este elemento não tem um tipo simples.
        cvc-length-valid = cvc-length-valid: O valor ''{0}'' com tamanho = ''{1}'' não tem um aspecto válido em relação ao tamanho ''{2}'' do tipo ''{3}''.
        cvc-maxExclusive-valid = cvc-maxExclusive-valid: O valor ''{0}'' não tem um aspecto válido em relação ao maxExclusive ''{1}'' do tipo ''{2}''.
        cvc-maxInclusive-valid = cvc-maxInclusive-valid: O valor ''{0}'' não tem um aspecto válido em relação ao maxInclusive ''{1}'' do tipo ''{2}''.
        cvc-maxLength-valid = cvc-maxLength-valid: O valor ''{0}'' com tamanho = ''{1}'' não tem um aspecto válido em relação ao maxLength ''{2}'' do tipo ''{3}''.
        cvc-minExclusive-valid = cvc-minExclusive-valid: O valor ''{0}'' não tem um aspecto válido em relação ao minExclusive ''{1}'' do tipo ''{2}''.
        cvc-minInclusive-valid = cvc-minInclusive-valid: O valor ''{0}'' não tem um aspecto válido em relação ao minInclusive ''{1}'' do tipo ''{2}''.
        cvc-minLength-valid = cvc-minLength-valid: O valor ''{0}'' com tamanho = ''{1}'' não tem um aspecto válido em relação ao minLength ''{2}'' do tipo ''{3}''.
        cvc-pattern-valid = cvc-pattern-valid: O valor ''{0}'' não tem um aspecto válido em relação ao padrão ''{1}'' do tipo ''{2}''.
        cvc-totalDigits-valid = cvc-totalDigits-valid: O valor ''{0}'' tem {1} dígitos do total, mas o número de dígitos do total foi limitado a {2}.
        cvc-type.1 = cvc-type.1: A definição ''{0}'' de tipo não foi encontrada.
        cvc-type.2 = cvc-type.2: A definição do tipo não pode ser abstrata para o elemento {0}.
        cvc-type.3.1.1 = cvc-type.3.1.1: O elemento ''{0}'' tem um tipo simples. Dessa forma, não pode haver atributos, exceto aqueles cujo nome do namespace é idêntico a ''http://www.w3.org/2001/XMLSchema-instance'' e cujo [local name] é um dos seguintes ''type'', ''nil'', ''schemaLocation'' ou ''noNamespaceSchemaLocation''. No entanto, o atributo ''{1}'' foi encontrado.
        cvc-type.3.1.2 = cvc-type.3.1.2: O elemento ''{0}'' tem um tipo simples. Dessa forma, não deve haver um item de informações do elemento [children].
        cvc-type.3.1.3 = cvc-type.3.1.3: O valor ''{1}'' do elemento ''{0}'' não é válido.

#schema valid (3.X.3)

        schema_reference.access = schema_reference: falha ao ler o documento de esquema ''{0}'' porque o acesso a ''{1}'' não é permitido em decorrência de uma restrição definida pela propriedade accessExternalSchema.
        schema_reference.4 = schema_reference.4: Falha ao ler o documento do esquema ''{0}'' porque 1) não foi possível encontrar o documento; 2) não foi possível ler o documento; 3) o elemento-raiz do documento não é <xsd:schema>.
        src-annotation = src-annotation: os elementos de <annotation> podem conter somente os elementos <appinfo> e <documentation>, mas foi encontrado ''{0}''.
        src-attribute.1 = src-attribute.1: As propriedades ''padrão'' e ''fixed'' não podem estar presentes na declaração do atributo ''{0}''. Use somente uma delas.
        src-attribute.2 = src-attribute.2: : A propriedade ''padrão'' está presente no atributo ''{0}''. Dessa forma, o valor de ''use'' deve ser ''optional''.
        src-attribute.3.1 = src-attribute.3.1: 'ref' ou 'name' deve estar presente na declaração do atributo de local.
        src-attribute.3.2 = src-attribute.3.2: O conteúdo deve corresponder a (annotation?) da referência do atributo ''{0}''.
        src-attribute.4 = src-attribute.4: O atributo ''{0}'' tem um atributo ''type'' e um ''simpleType'' filho anônimo. Somente um deles é permitido para um atributo.
        src-attribute_group.2 = src-attribute_group.2: A intersecção dos curingas não é expressível para o grupo de atributos ''{0}''.
        src-attribute_group.3 = src-attribute_group.3: Definições circulares detectadas para o grupo de atributos ''{0}''. Seguir as referências do grupo de atributos de forma recursiva acaba conduzindo a ele próprio.
        src-ct.1 = src-ct.1: Erro de Representação da Definição do Tipo Complexo para o tipo ''{0}''. Quando <complexContent> é usado, o tipo base deve ser um complexType. ''{1}'' é um simpleType.
        src-ct.2.1 = src-ct.2.1: Erro de Representação da Definição do Tipo Complexo do tipo ''{0}''. Quando <simpleContent> é usado, o tipo de base deve ser um complexType cujo tipo de conteúdo é simples ou, somente se a restrição for especificada, um tipo complexo com conteúdo misto e uma partícula esvaziável, ou, somente se a extensão for especificada, um tipo simples. ''{1}'' não satisfaz nenhuma dessas condições.
        src-ct.2.2 = src-ct.2.2: Erro de Representação de Definição do Tipo Complexo do tipo ''{0}''. Quando um complexType com simpleContent é restrito a um complexType com conteúdo misto e partícula esvaziável, então deve haver um <simpleType> entre os filhos de <restriction>.
        src-ct.4 = src-ct.4: Erro de Representação de Definição de Tipo Complexo do tipo ''{0}''. A intersecção de curingas não é expressível.
        src-ct.5 = src-ct.5: Erro de Representação da Definição do Tipo Complexo do tipo ''{0}''. A união de curingas não é expressível.
        src-element.1 = src-element.1: As propriedades ''padrão'' e ''fixed'' não podem estar presentes na declaração do elemento ''{0}''. Use somente uma delas.
        src-element.2.1 = src-attribute.2.1: 'ref' ou 'name' deve estar presente na declaração de elemento do local.
        src-element.2.2 = src-element.2.2: Como ''{0}'' contém o atributo ''ref'', seu conteúdo deve ser correspondente (annotation?). No entanto, ''{1}'' foi encontrado.
        src-element.3 = src-element.3: O elemento ''{0}'' tem um atributo ''type'' e um filho ''anonymous type''. Somente um deles é permitido para um elemento.
        src-import.1.1 = src-import.1.1: O atributo do namespace ''{0}'' de um item de informação do elemento <import> não deve ser igual ao targetNamespace do esquema existente nele.
        src-import.1.2 = src-import.1.2: Se o atributo do namespace não estiver presente em um item de informação do elemento <import>, então o esquema delimitador deve ter um targetNamespace.
        src-import.2 = src-import.2: O elemento-raiz do documento "{0}'' deve ter o nome do namespace ''http://www.w3.org/2001/XMLSchema'' e o nome do local ''schema''.
        src-import.3.1 = src-import.3.1: O atributo do namespace, ''{0}'', de um item de informação do elemento <import> deve ser idêntico ao atributo targetNamespace, ''{1}'', do documento importado.
        src-import.3.2 = src-import.3.2: Um item de informação do elemento <import> que não tinha atributo de namespace foi encontrado. Dessa forma, o documento importado não pode ter um atributo de targetNamespace. No entanto, o targetNamespace ''{1}'' foi encontrado no documento importado.
        src-include.1 = src-include.1: O elemento-raiz do documento "{0}'' deve ter o nome do namespace ''http://www.w3.org/2001/XMLSchema'' e o nome do local ''schema''.
        src-include.2.1 = src-include.2.1: O targetNamespace do esquema mencionado, atualmente ''{1}'', deve ser idêntico ao do esquema de inclusão, atualmente ''{0}''.
        src-redefine.2 = src-redefine.2: O elemento-raiz do documento "{0}'' deve ter o nome do namespace ''http://www.w3.org/2001/XMLSchema'' e o nome do local ''schema''.
        src-redefine.3.1 = src-redefine.3.1: O targetNamespace do esquema mencionado, atualmente ''{1}'', deve ser idêntico ao do esquema de redefinição, atualmente ''{0}''.
        src-redefine.5.a.a = src-redefine.5.a.a: Não foram encontrados filhos sem anotação de <simpleType>. Os filhos <simpleType> dos elementos <redefine> devem ter descendentes de <restriction> com atributos 'base' que fazem referência a eles próprios.
        src-redefine.5.a.b = src-redefine.5.a.b: ''{0}'' não é um elemento filho válido. Os filhos <simpleType> dos elementos <redefine> devem ter descendentes de <restriction> com atributos ''base'' que fazem referência a eles próprios.
        src-redefine.5.a.c = src-redefine.5.a.c: ''{0}'' não tem um atributo "base" que faz referência ao elemento ''{1}''. <simpleType> filhos dos elementos <redefine> devem ter descendentes de <restriction> com atributos ''base'' que fazem referência a eles próprios.
        src-redefine.5.b.a = src-redefine.5.b.a: Nenhum filho sem anotação de <complexType> foi encontrado. Os filhos de <complexType> dos elementos <redefine> devem ter os descendentes <extension> ou <restriction>, com atributos 'base' que fazem referência a eles próprios.
        src-redefine.5.b.b = src-redefine.5.b.b: Nenhum neto sem anotação de <complexType> foi encontrado. Os filhos de <complexType> dos elementos <redefine> devem ter os descendentes <extension> ou <restriction> com atributos 'base' que fazem referência a eles próprios.
        src-redefine.5.b.c = src-redefine.5.b.c: ''{0}'' não é um elemento do neto válido. Os filhos de <complexType> dos elementos <redefine> devem ter os descendentes <extension> ou <restriction> com atributos ''base'' que fazem referência a eles próprios.
        src-redefine.5.b.d = src-redefine.5.b.d: ''{0}'' não tem um atributo "base" que faz referência ao elemento redefinido ''{1}''. Os filhos de <complexType> dos elementos <redefine> devem ter descendentes de <extension> ou <restriction> com atributos ''base'' que fazem referência a eles próprios.
        src-redefine.6.1.1 = src-redefine.6.1.1: Se um filho do grupo de um elemento <redefine> contiver um grupo que faz referência a si próprio, ele deve ter exatamente 1; este tem ''{0}''.
        src-redefine.6.1.2 = src-redefine.6.1.2: O grupo ''{0}'' que contém um referência a um grupo que está sendo redefinido deve ter ''minOccurs'' = ''maxOccurs'' = 1.
        src-redefine.6.2.1 = src-redefine.6.2.1: Nenhum grupo no esquema redefinido tem uma correspondência de nome ''{0}''.
        src-redefine.6.2.2 = src-redefine.6.2.2: O grupo ''{0}'' não restringe adequadamente o grupo que ele redefine; restrição violada: ''{1}''.
        src-redefine.7.1 = src-redefine.7.1: Se um filho de attributeGroup de um elemento <redefine> contiver um attributeGroup que faz referência a ele próprio, ele deve ter exatamente 1; este tem {0}.
        src-redefine.7.2.1 = src-redefine.7.2.1: Nenhum attributeGroup no esquema redefinido tem uma correspondência de nome ''{0}''.
        src-redefine.7.2.2 = src-redefine.7.2.2: O AttributeGroup ''{0}'' não restringe adequadamente o attributeGroup que ele redefine; restrição violada: ''{1}''.
        src-resolve = src-resolve: Não é possível resolver o nome ''{0}'' para um componente ''{1}''.
        src-resolve.4.1 = src-resolve.4.1: Erro ao resolver o componente ''{2}''. Foi detectado que ''{2}'' não tem namespace, mas não é possível fazer referência aos componentes em namespace de destino usando o documento do esquema ''{0}''. Se ''{2}'' for destinado a um namespace, talvez seja necessário um prefixo. Se for determinado que ''{2}'' não tem namespace, então uma "importação" sem um atributo "namespace" deverá ser adicionada a "{0}".
        src-resolve.4.2 = src-resolve.4.2: Erro ao resolver o componente ''{2}''. Foi detectado que ''{2}'' está no namespace ''{1}'', mas não é possível fazer referência aos componentes em namespace de destino usando o documento do esquema ''{0}''. Se este for o namespace incorreto, talvez o prefixo de ''{2}'' precise ser alterado. Se este for o namespace correto, então a tag de "importação" apropriada deverá ser adicionada a ''{0}''.
        src-simple-type.2.a = src-simple-type.2.a: Foi encontrado um elemento <restriction> que tem um [attribute] base e um elemento <simpleType> entre seus [children]. Somente um é permitido.
        src-simple-type.2.b = src-simple-type.2.b: Foi encontrado um elemento <restriction> que não tem um [attribute] base nem um elemento <simpleType> entre seus [children]. É necessário um.
        src-simple-type.3.a = src-simple-type.3.a: Foi encontrado um elemento <list> que tem um itemType [attribute] e um elemento <simpleType> entre seus [children]. Somente um é permitido.
        src-simple-type.3.b = src-simple-type.3.b: Foi encontrado um elemento <list> que não tem um itemType [attribute] nem um elemento <simpleType> entre seus [children]. Um é necessário.
        src-single-facet-value = src-single-facet-value: O aspecto ''{0}'' foi definido mais de uma vez.
        src-union-memberTypes-or-simpleTypes = src-union-memberTypes-or-simpleTypes: Um elemento <union> deve ter um memberTypes [attribute] não vazio ou pelo menos um elemento <simpleType> entre seus [children].

#constraint valid (3.X.6)

        ag-props-correct.2 = ag-props-correct.2: Erro do grupo de atributos ''{0}''. Os usos do atributo duplicado com o mesmo nome e namespace de destino foram especificados. O nome de uso do atributo duplicado é ''{1}''.
        ag-props-correct.3 = ag-props-correct.3: Erro do grupo de atributos ''{0}''. Duas declarações de atributo ''{1}'' e ''{2}'' têm tipos que são obtidos do ID.
        a-props-correct.2 = a-props-correct.2: Valor de restrição inválido ''{1}'' no atributo ''{0}''.
        a-props-correct.3 = a-props-correct.3: O atributo ''{0}'' não pode usar ''fixed'' ou ''padrão'' porque o '{'type definition'}' do atributo é ID ou é obtida do ID.
        au-props-correct.2 = au-props-correct.2: Na declaração do atributo de ''{0}'', foi especificado um valor fixo de ''{1}''. Dessa forma, se o uso do atributo que faz referência a ''{0}'' também tiver uma '{'value constraint'}', ele deve ser corrigido e seu valor deve ser ''{1}''.
        cos-all-limited.1.2 = cos-all-limited.1.2: Um grupo de modelos 'all' deve ser exibido em uma partícula com '{'min occurs'}' = '{'max occurs'}' = 1 e essa partícula deve fazer parte de um par que constitui o '{'content type'}' de uma definição de tipo complexa.
        cos-all-limited.2 = cos-all-limited.2: O "{"max occurs"}" de um elemento em um grupo de modelos ''all'' deve ser 0 ou 1. O valor ''{0}'' do elemento ''{1}'' é inválido.
        cos-applicable-facets = cos-applicable-facets: O aspecto ''{0}'' não é permitido pelo tipo {1}.
        cos-ct-extends.1.1 = cos-ct-extends.1.1: O tipo ''{0}'' foi obtido através da extensão do tipo ''{1}''. No entanto, o atributo ''final'' de ''{1}'' proíbe a obtenção por meio da extensão.
        cos-ct-extends.1.4.3.2.2.1.a = cos-ct-extends.1.4.3.2.2.1.a: O tipo de conteúdo de um tipo derivado e o de sua base deve ser misto ou ambos devem ser de somente do elemento. O tipo ''{0}'' é somente do elemento, mas sua base não é.
        cos-ct-extends.1.4.3.2.2.1.b = cos-ct-extends.1.4.3.2.2.1.b: O tipo de conteúdo de um tipo derivado e sua base devem ser mistos ou ambos devem ser somente de elemento. O tipo ''{0}'' é misto, mas seu tipo de base não é.
        cos-element-consistent = cos-element-consistent: Erro do tipo ''{0}''. Vários elementos com o nome ''{1}'' com diferentes tipos aparecem no grupo de modelos.
        cos-list-of-atomic = cos-list-of-atomic: Na definição do tipo de lista ''{0}'', o tipo ''{1}'' é um tipo de elemento da lista inválido porque não é atômico (''{1}'' é um tipo de lista ou um tipo de união que contém uma lista).
        cos-nonambig = cos-nonambig: {0} e {1} (ou elementos de seu grupo de substituição) violam a "Unique Particle Attribution". Durante a validação deste esquema, a ambiguidade será criada para essas duas partículas.
        cos-particle-restrict.a = cos-particle-restrict.a: A partícula obtida está vazia e a base não pode ser esvaziada.
        cos-particle-restrict.b = cos-particle-restrict.b: A partícula base está vazia, mas a partícula obtida não está.
        cos-particle-restrict.2 = cos-particle-restrict.2: Restrição de partícula proibida: ''{0}''.
        cos-st-restricts.1.1 = cos-st-restricts.1.1: O tipo ''{1}'' é atômico. Dessa forma, sua '{'base type definition'}', ''{0}'', deve ser uma definição de tipo simples atômico ou um tipo de dados primitivo criado.
        cos-st-restricts.2.1 = cos-st-restricts.2.1: Na definição do tipo de lista ''{0}'', o tipo ''{1}'' é um tipo de item inválido porque é um tipo  de lista ou um tipo de união que contém uma lista.
        cos-st-restricts.2.3.1.1 = cos-st-restricts.2.3.1.1: O componente "{"final"}" da "{"item type definition"}" ''{0}'' contém ''list''. Isso significa que ''{0}'' não pode ser usado como um tipo de item do tipo de lista ''{1}''.
        cos-st-restricts.3.3.1.1 = cos-st-restricts.3.3.1.1: O componente "{"final"}" de "{"member type definitions"}", ''{0}'', contém ''union''. Isso significa que ''{0}'' não pode ser usado como um tipo de membro do tipo de união ''{1}''.
        cos-valid-default.2.1 = cos-valid-padrão.2.1: O elemento ''{0}'' tem uma restrição de valor e deve ter um modelo de conteúdo simples ou misto.
        cos-valid-default.2.2.2 = cos-valid-padrão.2.2.2: Como o elemento ''{0}'' tem uma '{'value constraint'}' e sua definição de tipo tem {''content type'}' misto, então a partícula do '{'content type'}' deve ser esvaziável.
        c-props-correct.2 = c-props-correct.2: A cardinalidade dos Campos de keyref ''{0}'' e chave ''{1}'' deve ser correspondente.
        ct-props-correct.3 = ct-props-correct.3: Definições circulares detectadas para o tipo complexo ''{0}''. Isso significa que ''{0}'' está contido em sua própria hierarquia de tipo, o que é um erro.
        ct-props-correct.4 = ct-props-correct.4: Erro do tipo ''{0}''. Os usos do atributo duplicado com o mesmo nome e namespace de destino foram especificados. O nome do uso do atributo duplicado é ''{1}''.
        ct-props-correct.5 = ct-props-correct.5: Erro do tipo ''{0}''. Duas declarações do atributo ''{1}'' e ''{2}'' têm tipos que são obtidos do ID.
        derivation-ok-restriction.1 = derivation-ok-restriction.1: O tipo ''{0}'' foi obtido por meio da restrição do tipo ''{1}''. No entanto, ''{1}'' tem uma propriedade '{'final'}' que proíbe a derivação por restrição.
        derivation-ok-restriction.2.1.1 = derivation-ok-restriction.2.1.1: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo tem um valor de ''uso'' de ''{2}'', que é inconsistente com o valor ''obrigatório'' em um uso de atributo correspondente no tipo de base.
        derivation-ok-restriction.2.1.2 = derivation-ok-restriction.2.1.2: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo tem o tipo ''{2}'', que é obtido de forma válida de "{3}", o tipo de uso do atributo correspondente no tipo de base.
        derivation-ok-restriction.2.1.3.a = derivation-ok-restriction.2.1.3.a: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo tem uma restrição de valor efetivo que não é fixa e a restrição de valor efetivo do atributo correspondente no tipo de base é fixa.
        derivation-ok-restriction.2.1.3.b = derivation-ok-restriction.2.1.3.b: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo tem uma restrição de valor efetivo fixa com um valor de "{2}" que não é consistente com o valor de "{3}" para a restrição de valor efetivo fixa do uso do atributo correspondente no tipo de base.
        derivation-ok-restriction.2.2.a = derivation-ok-restriction.2.2.a: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo não tem um uso de atributo correspondente na base e o tipo de base não tem um atributo curinga.
        derivation-ok-restriction.2.2.b = derivation-ok-restriction.2.2.b: Erro do tipo ''{0}''. O uso do atributo ''{1}'' neste tipo não tem um uso de atributo correspondente na base e o curinga no tipo de base não permite o namespace "{2}" deste uso do atributo.
        derivation-ok-restriction.3 = derivation-ok-restriction.3: Erro do tipo ''{0}''. O uso do atributo ''{1}'' no tipo de base tem REQUIRED como verdadeiro, mas não há uso de atributo correspondente no tipo obtido.
        derivation-ok-restriction.4.1 = derivation-ok-restriction.4.1: Erro do tipo ''{0}''. A derivação tem um curinga de atributo, mas a base não tem.
        derivation-ok-restriction.4.2 = derivation-ok-restriction.4.2: Erro do tipo ''{0}''. O curinga na derivação não é um subconjunto de curingas válido daquele da base.
        derivation-ok-restriction.4.3 = derivation-ok-restriction.4.3: Erro do tipo ''{0}''. O conteúdo do processo do curinga na derivação ({1}) é mais fraco que aquele da base ({2}).
        derivation-ok-restriction.5.2.2.1 = derivation-ok-restriction.5.2.2.1: Erro do tipo ''{0}''. O tipo de conteúdo simples deste tipo ''{1}'' não se trata de uma restrição válida do tipo de conteúdo simples da base, ''{2}''.
        derivation-ok-restriction.5.3.2 = derivation-ok-restriction.5.3.2: Erro do tipo ''{0}''. O tipo de conteúdo deste tipo está vazio, mas o tipo de conteúdo da base, ''{1}'', não está vazio ou é esvaziável.
        derivation-ok-restriction.5.4.1.2 = derivation-ok-restriction.5.4.1.2: Erro do tipo ''{0}''. O tipo de conteúdo deste tipo é misto, mas o tipo de conteúdo da base ''{1}'' não é.
        derivation-ok-restriction.5.4.2 = derivation-ok-restriction.5.4.2: Erro do tipo ''{0}''. A partícula do tipo não é uma restrição válida da partícula da base.
        enumeration-required-notation = enumeration-required-notation: O tipo de NOTATION, ''{0}'' usado por {2} ''{1}'', deve ter um valor de aspecto de enumeração que especifica os elementos de notação usados por este tipo.
        enumeration-valid-restriction = enumeration-valid-restriction: O valor da enumeração ''{0}'' não é o espaço do valor do tipo de base, {1}.
        e-props-correct.2 = e-props-correct.2: Valor de restrição de valor inválido ''{1}'' no elemento ''{0}''.
        e-props-correct.4 = e-props-correct.4: A "{"type definition"}" do elemento ''{0}'' não é obtida de forma válida a partir da "{"type definition"}" de substitutionHead ''{1}'' ou a propriedade "{"substitution group exclusions"}" de ''{1}'' não permite esta derivação.
        e-props-correct.5 = e-props-correct.5: Uma "{"value constraint"}" não deve estar presente no elemento ''{0}'' porque a "{"type definition"}" do elemento ou o "{"content type"}" da "{"type definition"}" é ID ou obtida do ID.
        e-props-correct.6 = e-props-correct.6: Grupo de substituição circular detectada para o elemento ''{0}''.
        fractionDigits-valid-restriction = fractionDigits-valid-restriction: Na definição de {2}, o valor ''{0}'' de ''fractionDigits'' do aspecto é inválido porque ele deve ser <= ao valor de ''fractionDigits'' que foi definido como ''{1}'' em um dos tipos de ancestrais.
        fractionDigits-totalDigits = fractionDigits-totalDigits: Na definição de {2}, o valor ''{0}'' do aspecto ''fractionDigits'' é inválido porque o valor deve ser <= o valor de ''totalDigits'' que é ''{1}''.
        length-minLength-maxLength.1.1 = length-minLength-maxLength.1.1: Para o tipo {0}, é um erro para que o valor do tamanho ''{1}'' seja menor que o valor de minLength ''{2}''.
        length-minLength-maxLength.1.2.a = length-minLength-maxLength.1.2.a: Para o tipo {0}, é um erro para que a base não tenha um aspecto de minLength, se a restrição atual tiver o aspecto minLength e a restrição atual ou a base tenha o aspecto de tamanho.
        length-minLength-maxLength.1.2.b = length-minLength-maxLength.1.2.b: Para o tipo {0}, é um erro para que o minLength ''{1}'' atual não seja igual ao minLength ''{2}'' base.
        length-minLength-maxLength.2.1 = length-minLength-maxLength.1.2: Para o tipo {0}, é um erro para que o valor do tamanho ''{1}'' seja maior que o valor de maxLength ''{2}''.
        length-minLength-maxLength.2.2.a = length-minLength-maxLength.2.2.a: Para o tipo {0}, é um erro para que a base não tenha um aspecto de maxLength, se a restrição atual tiver o aspecto maxLength e a restrição atual ou a base tiver o aspecto de tamanho.
        length-minLength-maxLength.2.2.b = length-minLength-maxLength.2.2.b: Para o tipo {0}, é um erro para que o maxLength ''{1}'' atual não seja igual ao maxnLength ''{2}'' base.
        length-valid-restriction = length-valid-restriction: Erro do tipo ''{2}''. O valor do tamanho = ''{0}'' deve ser = o valor do tipo de base ''{1}''.
        maxExclusive-valid-restriction.1 = maxExclusive-valid-restriction.1: Erro do tipo ''{2}''. O valor maxExclusive =''{0}'' deve ser <= maxExclusive do tipo de base ''{1}''.
        maxExclusive-valid-restriction.2 = maxExclusive-valid-restriction.2: Erro do tipo ''{2}''. O valor maxExclusive =''{0}'' deve ser <= maxInclusive do tipo de base ''{1}''.
        maxExclusive-valid-restriction.3 = maxExclusive-valid-restriction.3: Erro do tipo ''{2}''. O valor maxExclusive =''{0}'' deve ser > minExclusive do tipo de base ''{1}''.
        maxExclusive-valid-restriction.4 = maxExclusive-valid-restriction.4: Erro do tipo ''{2}''. O valor maxExclusive =''{0}'' deve ser > minExclusive do tipo de base ''{1}''.
        maxInclusive-maxExclusive = maxInclusive-maxExclusive: É um erro para que maxInclusive e maxExclusive sejam especificados para o mesmo tipo de dados. Em {2}, maxInclusive = ''{0}'' e maxExclusive = ''{1}''.
        maxInclusive-valid-restriction.1 = maxInclusive-valid-restriction.1: Erro do tipo ''{2}''. O valor maxInclusive =''{0}'' deve ser <= maxInclusive do tipo de base ''{1}''.
        maxInclusive-valid-restriction.2 = maxInclusive-valid-restriction.2: Erro do tipo ''{2}''. O valor maxInclusive =''{0}'' deve ser <= maxExclusive do tipo de base ''{1}''.
        maxInclusive-valid-restriction.3 = maxInclusive-valid-restriction.3: Erro do tipo ''{2}''. O valor maxInclusive =''{0}'' deve ser > = minInclusive do tipo de base ''{1}''.
        maxInclusive-valid-restriction.4 = maxInclusive-valid-restriction.4: Erro do tipo ''{2}''. O valor maxInclusive =''{0}'' deve ser > minInclusive do tipo de base ''{1}''.
        maxLength-valid-restriction = maxLength-valid-restriction: Na definição de {2}, o valor maxLength = ''{0}'' deve ser <= que o do tipo de base ''{1}''.
        mg-props-correct.2 = mg-props-correct.2: Definições circulares detectadas para o grupo ''{0}''. Seguir de forma recursiva dos valores de '{'term'}' das partículas conduz a uma partícula cujo '{'term'}' é o próprio grupo.
        minExclusive-less-than-equal-to-maxExclusive = minExclusive-less-than-equal-to-maxExclusive: Na definição de {2}, o valor minExclusive = ''{0}'' deve ser <= que o valor maxExclusive = ''{1}''.
        minExclusive-less-than-maxInclusive = minExclusive-less-than-maxInclusive: Na definição de {2}, o valor minExclusive = ''{0}'' deve ser <= que o valor maxInclusive = ''{1}''.
        minExclusive-valid-restriction.1 = minExclusive-valid-restriction.1: Erro do tipo ''{2}''. O valor minExclusive =''{0}'' deve ser >= minExclusive do tipo de base ''{1}''.
        minExclusive-valid-restriction.2 = minExclusive-valid-restriction.2: Erro do tipo ''{2}''. O valor minExclusive =''{0}'' deve ser <= maxExclusive do tipo de base ''{1}''.
        minExclusive-valid-restriction.3 = minExclusive-valid-restriction.3: Erro do tipo ''{2}''. O valor minExclusive =''{0}'' deve ser >= minInclusive do tipo de base ''{1}''.
        minExclusive-valid-restriction.4 = minExclusive-valid-restriction.4: Erro do tipo ''{2}''. O valor minExclusive =''{0}'' deve ser < maxExclusive do tipo de base ''{1}''.
        minInclusive-less-than-equal-to-maxInclusive = minInclusive-less-than-equal-to-maxInclusive: Na definição de {2}, o valor minInclusive = ''{0}'' deve ser <= que o valor maxInclusive = ''{1}''.
        minInclusive-less-than-maxExclusive = minInclusive-less-than-maxExclusive: Na definição de {2}, o valor minInclusive = ''{0}'' deve ser <= que o valor maxExclusive = ''{1}''.
        minInclusive-minExclusive = minInclusive-minExclusive: É um erro para que minInclusive e minExclusive sejam especificados para o mesmo tipo de dados. Em {2}, minInclusive = ''{0}'' e minExclusive = ''{1}''.
        minInclusive-valid-restriction.1 = minInclusive-valid-restriction.1: Erro do tipo ''{2}''. O valor minInclusive =''{0}'' deve ser >= minInclusive do tipo de base ''{1}''.
        minInclusive-valid-restriction.2 = minInclusive-valid-restriction.2: Erro do tipo ''{2}''. O valor minInclusive =''{0}'' deve ser <= maxInclusive do tipo de base ''{1}''.
        minInclusive-valid-restriction.3 = minInclusive-valid-restriction.3: Erro do tipo ''{2}''. O valor minInclusive =''{0}'' deve ser > minExclusive do tipo de base ''{1}''.
        minInclusive-valid-restriction.4 = minInclusive-valid-restriction.4: Erro do tipo ''{2}''. O valor minInclusive =''{0}'' deve ser <= maxExclusive do tipo de base ''{1}''.
        minLength-less-than-equal-to-maxLength = minLength-less-than-equal-to-maxLength: Na definição de {2}, o valor minLength = ''{0}'' deve ser < o valor de maxLength = ''{1}''.
        minLength-valid-restriction = minLength-valid-restriction: Na definição de {2}, minLength = ''{0}'' deve ser >= que o do tipo de base ''{1}''.
        no-xmlns = no-xmlns: O {name} de uma declaração de atributo não deve corresponder a 'xmlns'.
        no-xsi = no-xsi: O "{"target namespace"}" de uma declaração do atributo não deve corresponder a ''{0}''.
        p-props-correct.2.1 = p-props-correct.2.1: Na declaração de ''{0}'', o valor de ''minOccurs'' é ''{1}'', mas não deve ser maior que o valor de ''maxOccurs'', que é ''{2}''.
        rcase-MapAndSum.1 = rcase-MapAndSum.1: Não há um mapeamento funcional completo entre as partículas.
        rcase-MapAndSum.2 = rcase-MapAndSum.2: A faixa de ocorrência do grupo, ({0},{1}), não é uma restrição válida da faixa de ocorrência do grupo base, ({2},{3}).
        rcase-NameAndTypeOK.1 = rcase-NameAndTypeOK.1: Os elementos têm nomes e namespaces de destino que não são iguais: Elemento ''{0}'' no namespace ''{1}'' e elemento ''{2}'' no namespace ''{3}''.
        rcase-NameAndTypeOK.2 = rcase-NameAndTypeOK.2: Erro da partícula cujo "{"term"}" é a declaração do elemento ''{0}''. O "{"nillable"}" da declaração do elemento é verdadeiro, mas a partícula correspondente no tipo de base tem uma declaração de elemento cujo "{"nillable"}" é falso.
        rcase-NameAndTypeOK.3 = rcase-NameAndTypeOK.3: Erro da partícula cujo "{"term"}" é a declaração do elemento ''{0}''. Sua faixa de ocorrência, ({1},{2}) não é uma restrição válida da faixa, ({3},{4} da partícula correspondente no tipo de base.
        rcase-NameAndTypeOK.4.a = rcase-NameAndTypeOK.4.a: O elemento ''{0}'' não está fixado, mas o elemento correspondente no tipo de base está fixado com o valor ''{1}''.
        rcase-NameAndTypeOK.4.b = rcase-NameAndTypeOK.4.b: O elemento ''{0}'' está fixado com o valor ''{1}'', mas o elemento correspondente no tipo de base está fixado com o valor ''{2}''.
        rcase-NameAndTypeOK.5 = rcase-NameAndTypeOK.5: Restrições de identidade do elemento ''{0}'' não são subconjuntos daquelas da base.
        rcase-NameAndTypeOK.6 = rcase-NameAndTypeOK.6: As substituições não permitidas do elemento ''{0}'' não são um superconjunto daquelas da base.
        rcase-NameAndTypeOK.7 = rcase-NameAndTypeOK.7: O tipo de elemento ''{0}'', ''{1}'' não é obtido do tipo de elemento base ''{2}''.
        rcase-NSCompat.1 = rcase-NSCompat.1: O elemento ''{0}'' tem um namespace ''{1}'' que não é permitido pelo curinga na base.
        rcase-NSCompat.2 = rcase-NSCompat.2: Erro da partícula cujo "{"term"}" é a declaração do elemento ''{0}''. Sua faixa de ocorrência, ({1},{2}), não é uma restrição válida da faixa, ({3},{4}, da partícula correspondente no tipo de base.
        rcase-NSRecurseCheckCardinality.1 = rcase-NSRecurseCheckCardinality.1: Não há um mapeamento funcional completo entre as partículas.
        rcase-NSRecurseCheckCardinality.2 = rcase-NSRecurseCheckCardinality.2: A faixa de ocorrências do grupo, ({0},{1}), não é uma restrição válida da faixa de curingas base, ({2},{3}).
        rcase-NSSubset.1 = rcase-NSSubset.1: Curinga não é um subconjunto de curingas correspondente na base.
        rcase-NSSubset.2 = rcase-NSSubset.2: A faixa de ocorrências de curinga, ({0},{1}), não é uma restrição válida daquela da base, ({2},{3}),.
        rcase-NSSubset.3 = rcase-NSSubset.3: O conteúdo do processo do curinga, ''{0}'', é mais fraco que aquele da base, ''{1}''.
        rcase-Recurse.1 = rcase-Recurse.1: A faixa de ocorrência do grupo, ({0},{1}), não é uma restrição válida da faixa de ocorrência do grupo base, ({2},{3}).
        rcase-Recurse.2 = rcase-Recurse.2: Não há um mapeamento funcional completo entre as partículas.
        rcase-RecurseLax.1 = rcase-RecurseLax.1: A faixa de ocorrências do grupo, ({0},{1}), não é uma restrição válida da faixa de ocorrências do grupo base, ({2},{3}).
        rcase-RecurseLax.2 = rcase-RecurseLax.2: Não há um mapeamento funcional completo entre as partículas.
        rcase-RecurseUnordered.1 = rcase-RecurseUnordered.1: A faixa de ocorrências do grupo, ({0},{1}), não é uma restrição válida da faixa de ocorrências do grupo base, ({2},{3}).
        rcase-RecurseUnordered.2 = rcase-RecurseUnordered.2: Não há um mapeamento funcional completo entre as partículas.
#        We're using sch-props-correct.2 instead of the old src-redefine.1
#        src-redefine.1 = src-redefine.1: The component ''{0}'' is begin redefined, but its corresponding component isn't in the schema document being redefined (with namespace ''{2}''), but in a different document, with namespace ''{1}''.
        sch-props-correct.2 = sch-props-correct.2: Um esquema não pode conter dois componentes globais com o mesmo nome; este esquema contém duas ocorrências de ''{0}''.
        st-props-correct.2 = st-props-correct.2: Definições circulares detectadas para o tipo simples {0}''. Isso significa que ''{0}'' está contido em sua própria hierarquia de tipo, o que é um erro.
        st-props-correct.3 = st-props-correct.3: Erro do tipo ''{0}''. O valor de '{'final'}' da '{'base type definition'}', ''{1}'', proíbe a obtenção por restrição.
        totalDigits-valid-restriction = totalDigits-valid-restriction: Na definição de {2}, o valor ''{0}'' do "totalDigits"'' do aspecto é inválido porque ele deve ser <= ao valor de ''totalDigits", que foi definido como ''{1}'' em um dos tipos de ancestrais.
        whiteSpace-valid-restriction.1 = whiteSpace-valid-restriction.1: Na definição de {0}, o valor ''{1}'' do aspecto ''whitespace'' é inválido porque o valor para ''whitespace'' foi definido como ''colapse'' em um dos tipos de ancestrais.
        whiteSpace-valid-restriction.2 = whiteSpace-valid-restriction.2: Na definição de {0}, o valor do aspecto ''preserve'' é inválido para o aspecto "whitespace" porque o valor para ''whitespace'' foi definido como ''replace'' em um dos tipos de ancestrais.

#schema for Schemas

        s4s-att-invalid-value = s4s-att-invalid-value: Valor de atributo inválido para ''{1}'' no elemento''{0}''. Motivo gravado: {2}
        s4s-att-must-appear = s4s-att-must-appear: O atributo ''{1}'' deve aparecer no elemento ''{0}''.
        s4s-att-not-allowed = s4s-att-not-allowed: O atributo ''{1}'' não pode aparecer no elemento ''{0}''.
        s4s-elt-invalid = s4s-elt-invalid: O elemento ''{0}'' não é um elemento válido em um documento do esquema.
        s4s-elt-must-match.1 = s4s-elt-must-match.1: O conteúdo de ''{0}'' deve corresponder a {1}. Foi detectado um problema começando em: {2}.
        s4s-elt-must-match.2 = s4s-elt-must-match.2: O conteúdo de ''{0}'' deve corresponder a {1}. Não foram encontrados elementos suficientes.
        # the "invalid-content" messages provide less information than the "must-match" counterparts above. They're used for complex types when providing a "match" would be an information dump
        s4s-elt-invalid-content.1 = s4s-elt-invalid-content.1: O conteúdo de ''{0}'' é inválido. O elemento ''{1}'' é inválido, mal posicionado ou ocorre com muita frequência.
        s4s-elt-invalid-content.2 = s4s-elt-invalid-content.2: O conteúdo de ''{0}'' é inválido. O elemento ''{1}'' não pode ficar vazio.
        s4s-elt-invalid-content.3 = s4s-elt-invalid-content.3: Os elementos do tipo ''{0}'' não podem aparecer após as declarações como filhos de um elemento de <schema>.
        s4s-elt-schema-ns = s4s-elt-schema-ns: O namespace do elemento ''{0}'' deve ser do namespace do esquema, ''http://www.w3.org/2001/XMLSchema''.
        s4s-elt-character = s4s-elt-character: Não são permitidos caracteres sem espaço em branco nos elementos do esquema diferentes de ''xs:appinfo'' e ''xs:documentation''. Verificado ''{0}''.

# codes not defined by the spec

        c-fields-xpaths = c-fields-xpaths: O valor do campo = ''{0}'' não é válido.
        c-general-xpath = c-general-xpath: A expressão ''{0}'' não é válida em relação ao subconjunto de XPath suportado pelo Esquema XML.
        c-general-xpath-ns = c-general-xpath-ns: Um prefixo de namespace na expressão de XPath ''{0}'' não foi associado a um namespace.
        c-selector-xpath = c-selector-xpath: O valor do seletor = ''{0}'' não é válido; os xpaths do seletor não podem conter atributos.
        EmptyTargetNamespace = EmptyTargetNamespace: No documento do esquema ''{0}'', o valor do atributo ''targetNamespace'' não pode ser uma string vazia.
        FacetValueFromBase = FacetValueFromBase: Na declaração do tipo ''{0}'', o valor ''{1}'' do aspecto ''{2}'' deve ser proveniente do espaço de valor do tipo de base, ''{3}''.
        FixedFacetValue = FixedFacetValue: Na definição de {3}, o valor ''{1}'' do aspecto ''{0}'' é inválido porque o valor de ''{0}'' foi enviado para ''{2}'' em um dos tipos de ancestrais e '{'fixed'}' = true.
        InvalidRegex = InvalidRegex: O valor do padrão ''{0}'' não é uma expressão regular válida. O erro reportado foi: ''{1}'' na coluna ''{2}''.
        MaxOccurLimit = A configuração atual do parser não permite que o valor de um atributo maxOccurs seja definido como maior que o valor {0}.
        PublicSystemOnNotation = PublicSystemOnNotation: Pelo menos ''public'' e ''system'' devem aparecer no elemento ''notation''.
        SchemaLocation = SchemaLocation: schemaLocation value = ''{0}''deve ter número par de URIs.
        TargetNamespace.1 = TargetNamespace.1: Esperava o namespace ''{0}'', mas o namespace de destino do documento do esquema é ''{1}''.
        TargetNamespace.2 = TargetNamespace.2: Exceto no namespace, mas o documento do esquema tem um namespace de destino ''{1}''.
        UndeclaredEntity = UndeclaredEntity: A entidade ''{0}'' não foi declarada.
        UndeclaredPrefix = UndeclaredPrefix: Não é possível resolver ''{0}'' como um QName: o prefixo ''{1}'' não foi declarado.


# JAXP 1.2 schema source property errors

        jaxp12-schema-source-type.1 = A propriedade ''http://java.sun.com/xml/jaxp/properties/schemaSource'' não pode ter um valor do tipo ''{0}''. Os tipos possíveis do valor suportados são String, File, InputStream, InputSource ou um array desses tipos.
        jaxp12-schema-source-type.2 = A propriedade ''http://java.sun.com/xml/jaxp/properties/schemaSource'' não pode ter um valor de array do tipo ''{0}''. Os tipos possíveis do array suportados são Object, String, File, InputStream e InputSource.
        jaxp12-schema-source-ns = Ao utilizar um array do tipo Object como valor da propriedade 'http://java.sun.com/xml/jaxp/properties/schemaSource', não é válido ter dois esquemas que compartilham o mesmo namespace de destino.
