#
# Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

error.multiple.main.operations=Você não pode especificar mais de um opção '-cuxtid'
error.cant.open=não é possível abrir: {0}
error.illegal.option=Opção inválida: {0}
error.unrecognized.option=opção não reconhecida : {0}
error.missing.arg=a opção {0}  exige um argumento
error.bad.file.arg=Erro ao fazer parsing dos argumentos de arquivo
error.bad.option=Uma das opções -{ctxuid} deve ser especificada.
error.bad.cflag=flag 'c' requer que os arquivos de manifesto ou entrada sejam especificados!
error.bad.uflag=o flag 'u' requer que arquivos de manifesto, o flag 'e' ou arquivos de entrada sejam especificados!
error.bad.eflag=o flag 'e' e manifesto com o atributo 'Main-Class' não podem ser especificados \njuntos!
error.bad.dflag=A opção '-d, --describe-module' não exige a especificação de arquivos de entrada
error.bad.reason=motivo incorreto: {0}, deve ser deprecated, deprecated-for-removal ou incubating
error.nosuch.fileordir={0} : não há tal arquivo ou diretório
error.write.file=Erro ao gravar o arquivo jar existente
error.create.dir={0} : não foi possível criar o diretório
error.incorrect.length=largura incorreta durante o processamento: {0}
error.create.tempfile=Não foi possível criar um arquivo temporário
error.hash.dep=Módulo de hashing com {0} dependências. Não é possível localizar o módulo {1} no caminho do módulo
error.module.options.without.info=Um dentre --module-version ou --hash-modules está sem module-info.class
error.no.operative.descriptor=Nenhum descritor de operação para a release: {0}
error.no.root.descriptor=Nenhum descritor do módulo-raiz, especifique --release
error.unable.derive.automodule=Não é possível obter o descritor do módulo para: {0}
error.unexpected.module-info=Descritor de módulo inesperado {0}
error.module.descriptor.not.found=Descritor de módulo não encontrado
error.invalid.versioned.module.attribute=Atributo {0} de descritor de módulo inválido
error.missing.provider=Prestador de serviços  não encontrado: {0}
error.release.value.notnumber=release {0} não válida
error.release.value.toosmall=release {0} não válida; deve ser >= 9
error.release.unexpected.versioned.entry=entrada {0} com controle de versão inesperada para a release {1}
error.validator.jarfile.exception=não é possível validar {0}: {1}
error.validator.jarfile.invalid=arquivo jar {0} multi-release inválido excluído
error.validator.bad.entry.name=nome de entrada incorreto, {0}
error.validator.version.notnumber=o nome de entrada {0} não tem um número de versão
error.validator.entryname.tooshort=nome de entrada {0} muito pequeno, não é um diretório
error.validator.isolated.nested.class=a entrada {0} é uma classe aninhada isolada
error.validator.new.public.class=a entrada {0} contém uma nova classe pública não encontrada nas entradas de base
error.validator.incompatible.class.version=a entrada {0} tem uma versão de classe incompatível com uma versão anterior
error.validator.different.api=a entrada {0} contém uma classe com api diferente da versão anterior
error.validator.names.mismatch=a entrada {0} contém uma classe com o nome interno {1}; os nomes não correspondem
error.validator.info.name.notequal=module-info.class em um diretório com controle de versão contém nome incorreto
error.validator.info.requires.transitive=module-info.class em um diretório com controle de versão contém "requires transitive" adicional
error.validator.info.requires.added=module-info.class em um diretório com controle de versão contém "requires" adicional
error.validator.info.requires.dropped=module-info.class em um diretório com controle de versão falta "requires"
error.validator.info.exports.notequal=module-info.class em um diretório com controle de versão contém "exports" diferente
error.validator.info.opens.notequal=module-info.class em um diretório com controle de versão contém "opens" diferente
error.validator.info.provides.notequal=module-info.class em um diretório com controle de versão contém "provides" diferente
error.validator.info.version.notequal={0}: module-info.class em um diretório com controle de versão contém "version" diferente
error.validator.info.manclass.notequal={0}: module-info.class em um diretório com controle de versão contém "main-class" diferente
warn.validator.identical.entry=Advertência: a entrada {0} contém uma classe\nidêntica a uma que já está no jar
warn.validator.resources.with.same.name=Advertência: entrada {0}; diversos recursos com o mesmo nome
warn.validator.concealed.public.class=Advertência: a entrada {0} é uma classe pública\nem um pacote oculto; colocar esse jar no caminho de classe resultará\nem interfaces públicas incompatíveis
warn.release.unexpected.versioned.entry=entrada {0} com controle de versão inesperada
out.added.manifest=manifesto adicionado
out.added.module-info=module-info: {0} adicionado
out.automodule=Nenhum descritor de módulo encontrado. Módulo automático derivado.
out.update.manifest=manifesto atualizado
out.update.module-info=module-info: {0} atualizado
out.ignore.entry=ignorando entrada {0}
out.adding=adicionando: {0}
out.deflated=(compactado {0}%)
out.stored=(armazenado 0%)
out.create=\  criado: {0}
out.extracted=extraído: {0}
out.inflated=\ inflado: {0}
out.size=(entrada = {0}) (saída= {1})

usage.compat=Interface de Compatibilidade:\nUso: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] arquivos] ...\nOpções:\n    -c  cria novo arquivo compactado\n    -t  lista o sumário do arquivo compactado\n    -x  extrai arquivos com o nome (ou todos) do arquivo compactado\n    -u  atualiza o arquivo compactado existente\n    -v  gera saída detalhada na saída padrão\n    -f  especifica o nome do arquivo compactado\n    -m  inclui as informações do manifesto do arquivo de manifesto especificado\n    -n   executa a normalização Pack200 após a criação de um novo arquivo compactado\n    -e  especifica o ponto de entrada da aplicativo para aplicativo stand-alone \n        empacotada em um arquivo jar executável\n    -0  armazena somente; não usa compactação ZIP\n    -P  preserva os componentes '/' inicial (caminho absoluto) e ".." (diretório pai) nos nomes dos arquivos\n    -M  não cria um arquivo de manifesto para as entradas\n    -i  gera informações de índice para os arquivos jar especificados\n    -C  passa para o diretório especificado e inclui o arquivo a seguir\nSe um arquivo também for um diretório, ele será processado repetidamente.\nO nome do arquivo de manifesto, o nome do arquivo compactado e o nome do ponto de entrada são\nespecificados na mesma ordem dos flags 'm', 'f' e 'e'.\n\nExemplo 1: para arquivar dois arquivos de classe em um arquivo compactado denominado classes.jar: \n       jar cvf classes.jar Foo.class Bar.class \nExemplo 2: use um arquivo de manifesto existente 'mymanifest' e arquive todos os\n           arquivos no diretório foo/ em 'classes.jar': \n       jar cvfm classes.jar mymanifest -C foo/ .\n

main.usage.summary=Uso: jar [OPTION...] [ [--release VERSION] [-C dir] files] ...
main.usage.summary.try=Tente `jar --ajuda' para obter mais informações.

main.help.preopt=Uso: arquivos [OPTION...] [ [--release VERSION] [-C dir] jar]...\njar cria um arquivo compactado para classes e recursos, e pode manipular ou\nrestaurar classes ou recursos individuais de um arquivo compactado.\n\n Exemplos:\n # Cria um arquivo compactado chamado classes.jar com dois arquivos de classe:\n jar --create --file classes.jar Foo.class Bar.class\n # Cria um arquivo compactado usando um manifesto existente, com todos os arquivos em foo/:\n jar --create --file classes.jar --manifest mymanifest -C foo/ .\n # Cria um arquivo compactado jar modular, em que o descritor do módulo se localiza em\n # classes/module-info.class:\n jar --create --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ classes resources\n # Atualiza um arquivo jar não modular existente para um jar modular:\n jar --update --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ module-info.class\n # Cria um arquivo jar de várias releases, colocando alguns arquivos no diretório META-INF/versions/9:\n jar --create --file mr.jar -C foo classes --release 9 -C foo9 classes\n\nPara reduzir ou simplificar o comando jar, você pode especificar argumentos em um arquivo de texto separado\ne especificá-lo no comando jar com o sinal de arroba (@) como um prefixo.\n\n Exemplos:\n # Lê opções adicionais e lista os arquivos de classe do arquivo classes.list\n jar --create --file my.jar @classes.list\n
main.help.opt.main=\ Modo de operação principal:\n
main.help.opt.main.create=\  -c, --create               Cria o arquivo compactado
main.help.opt.main.generate-index=\  -i, --generate-index=FILE  Gera informações de índice para os arquivos compactados jar \n                             especificados
main.help.opt.main.list=\  -t, --list                 Lista o conteúdo do arquivo compactado
main.help.opt.main.update=\  -u, --update               Atualiza um arquivo compactado jar existente
main.help.opt.main.extract=\  -x, --extract              Extrai arquivos nomeados (ou todos) do arquivo compactado
main.help.opt.main.describe-module=\  -d, --describe-module      Imprime o descritor do módulo ou nome do módulo automático
main.help.opt.any=\ Modificadores de operação válidos em qualquer modo:\n\n  -C DIR                     Altera para o diretório especificado e inclui o\n                             seguinte arquivo:
main.help.opt.any.file=\  -f, --file=FILE            O nome do arquivo compactado. Quando omitido, stdin ou\n                             stdout será usado com base na operação\n      --release VERSION      Coloca todos os arquivos a seguir em um diretório com controle de versão\n                             do arquivo jar (i.e. META-INF/versions/VERSION/)
main.help.opt.any.verbose=\  -v, --verbose              Gera saída detalhada na saída padrão
main.help.opt.create=\ Modificadores de operação válidos somente no modo de criação:\n
main.help.opt.create.update=\ Modificadores de operação válidos somente no modo de criação e atualização:\n
main.help.opt.create.update.main-class=\  -e, --main-class=CLASSNAME O ponto de entrada do aplicativo para aplicativos\n                             stand-alone empacotados em um arquivo compactado jar modular\n                             ou executável
main.help.opt.create.update.manifest=\  -m, --manifest=FILE        Inclui as informações de manifesto provenientes do arquivo de\n                             manifesto em questão
main.help.opt.create.update.no-manifest=\  -M, --no-manifest          Não cria um arquivo de manifesto para as entradas
main.help.opt.create.update.module-version=\      --module-version=VERSION    A versão do módulo, ao criar um arquivo jar\n                             modular, ou atualizar um arquivo jar não modular
main.help.opt.create.update.hash-modules=\      --hash-modules=PATTERN Calcula e registra os hashes dos módulos\n                             correlacionado pelo padrão fornecido e do qual depende\n                             direta ou indiretamente em um arquivo jar modular que está sendo\n                             criado ou em um arquivo jar não modular que está sendo atualizado
main.help.opt.create.update.module-path=\  -p, --module-path          Local de dependência de módulo para gerar\n                             o hash
main.help.opt.create.update.do-not-resolve-by-default=\      --do-not-resolve-by-default  Excluir do conjunto de módulos raiz padrão
main.help.opt.create.update.warn-if-resolved=\      --warn-if-resolved     Dica para que uma ferramenta emita uma advertência se o módulo\n                             for resolvido. Um destes: deprecated, deprecated-for-removal,\n                             ou incubating
main.help.opt.create.update.index=\ Modificadores de operação válidos somente no modo de criação, atualização e geração de índice:\n
main.help.opt.create.update.index.no-compress=\  -0, --no-compress          Somente armazenamento; não use compactação ZIP
main.help.opt.other=\ Outras opções:\n
main.help.opt.other.help=\  -h, --help[:compat]        Fornece esta ajuda ou, opcionalmente, a ajuda de compatibilidade
main.help.opt.other.help-extra=\      --help-extra           Fornecer ajuda sobre opções extras
main.help.opt.other.version=\      --version              Imprime a versão do programa
main.help.postopt=\ Arquivo compactado será um arquivo jar modular se um descritor de módulo, 'module-info.class', estiver\n localizado na raiz dos diretórios em questão ou na raiz do próprio arquivo compactado\n jar. As seguintes operações só são válidas ao criar um jar modular\n ou atualizar um jar não modular existente: '--module-version',\n '--hash-modules' e '--module-path'.\n\n Argumentos obrigatórios ou opcionais para opções longas também são obrigatórios ou opcionais\n para quaisquer opções curtas correspondentes.
