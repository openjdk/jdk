#
# Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

error.multiple.main.operations=您不能指定多個 '-cuxtid' 選項
error.cant.open=無法開啟: {0}
error.illegal.option=無效的選項: {0}
error.unrecognized.option=無法辨識的選項 : {0}
error.missing.arg=選項 {0} 需要一個引數
error.bad.file.arg=剖析檔案引數時發生錯誤
error.bad.option=必須指定 -{ctxuid} 的其中一個選項。
error.bad.cflag='c' 旗標要求指定資訊清單或輸入檔案！
error.bad.uflag='u' 旗標要求指定資訊清單、'e' 旗標或輸入檔案！
error.bad.eflag=無法同時指定 'e' 旗標和具有 'Main-Class' 屬性的\n資訊清單！
error.bad.dflag='-d, --describe-module' 選項不需要指定輸入檔
error.bad.reason=錯誤原因: {0}，必須是 deprecated、deprecated-for-removal 或 incubating 其中之一
error.nosuch.fileordir={0} : 沒有這類檔案或目錄
error.write.file=寫入現有的 jar 檔案時發生錯誤
error.create.dir={0} : 無法建立目錄
error.incorrect.length=處理 {0} 時長度不正確
error.create.tempfile=無法建立暫存檔案
error.hash.dep=雜湊模組 {0} 相依性，在模組路徑上找不到模組 {1}
error.module.options.without.info=--module-version 或 --hash-modules 其中一個沒有 module-info.class
error.no.operative.descriptor=沒有以下版本的操作描述區: {0}
error.no.root.descriptor=沒有根模組描述區，請指定 --release
error.unable.derive.automodule=無法衍生 {0} 的模組描述區
error.unexpected.module-info=未預期的模組描述區 {0}
error.module.descriptor.not.found=找不到模組描述區
error.invalid.versioned.module.attribute=模組描述區屬性 {0} 無效
error.missing.provider=找不到服務提供者: {0}
error.release.value.notnumber=版本 {0} 無效
error.release.value.toosmall=版本 {0} 無效，必須大於等於 9
error.release.unexpected.versioned.entry=版本 {1} 有未預期的啟動多版本功能項目 {0}
error.validator.jarfile.exception=無法驗證 {0}: {1}
error.validator.jarfile.invalid=已刪除無效的多重版本 jar 檔案 {0}
error.validator.bad.entry.name=項目名稱 {0} 的格式錯誤
error.validator.version.notnumber=項目名稱 {0} 沒有版本編號
error.validator.entryname.tooshort=項目名稱 {0} 太短，無法作為目錄
error.validator.isolated.nested.class=項目 {0} 是已隔離的巢狀結構類別
error.validator.new.public.class=項目 {0} 含有在基準項目中找不到的新公用類別
error.validator.incompatible.class.version=項目 {0} 的類別版本與較舊版本不相容
error.validator.different.api=項目 {0} 的某個類別含有與較舊版本不同的 API
error.validator.names.mismatch=項目 {0} 含有內部名稱為 {1} 的類別，名稱不相符
error.validator.info.name.notequal=已啟動多版本功能目錄中的 module-info.class 包含不正確的名稱
error.validator.info.requires.transitive=已啟動多版本功能目錄中的 module-info.class 包含額外的 "requires transitive"
error.validator.info.requires.added=已啟動多版本功能目錄中的 module-info.class 包含額外的 "requires"
error.validator.info.requires.dropped=已啟動多版本功能目錄中的 module-info.class 包含遺漏的 "requires"
error.validator.info.exports.notequal=已啟動多版本功能目錄中的 module-info.class 包含不同的 "exports"
error.validator.info.opens.notequal=已啟動多版本功能目錄中的 module-info.class 包含不同的 "opens"
error.validator.info.provides.notequal=已啟動多版本功能目錄中的 module-info.class 包含不同的 "provides"
error.validator.info.version.notequal={0}: 已啟動多版本功能目錄中的 module-info.class 包含不同的 "version"
error.validator.info.manclass.notequal={0}: 已啟動多版本功能目錄中的 module-info.class 包含不同的 "main-class"
warn.validator.identical.entry=警告: 項目 {0} 的某個類別\n與 jar 中的現有項目相同
warn.validator.resources.with.same.name=警告: 項目 {0} 中的多個資源名稱相同
warn.validator.concealed.public.class=警告: 項目 {0} 是隱藏套裝程式中的\n公用類別，若將此 jar 放在類別路徑上\n會造成公用介面不相容
warn.release.unexpected.versioned.entry=未預期的啟動多版本功能項目 {0}
out.added.manifest=已新增資訊清單
out.added.module-info=已新增 module-info: {0}
out.automodule=找不到模組描述區。已自動衍生模組。
out.update.manifest=已更新資訊清單
out.update.module-info=已更新 module-info: {0}
out.ignore.entry=忽略項目 {0}
out.adding=新增: {0}
out.deflated=(壓縮 {0}%)
out.stored=(儲存 0%)
out.create=\  建立: {0}
out.extracted=擷取: {0}
out.inflated=\ 擴展: {0}
out.size=\ (讀={0})(寫={1})

usage.compat=相容性介面:\n用法: jar {ctxui}[vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files] ...\n選項:\n    -c  建立新存檔\n    -t  列出存檔的目錄\n    -x  從存檔中擷取指定 (或全部) 的檔案\n    -u  更新現有存檔\n    -v  在標準輸出中產生詳細輸出\n    -f  指定存檔檔案名稱\n    -m  包含指定之資訊清單檔案中的資訊清單資訊\n    -n  在建立新存檔之後執行 Pack200 正規化\n    -e  為隨附於可執行 jar 檔案中的獨立應用程式 \n        指定應用程式進入點\n    -0  僅儲存; 不使用 ZIP 壓縮方式\n    -P  保留檔案名稱前面的 '/' (絕對路徑) 和 ".." (上層目錄) 元件\n    -M  不為項目建立資訊清單檔案\n    -i  為指定的 jar 檔案產生索引資訊\n    -C  變更至指定的目錄並包含後面所列的檔案\n如果有任何檔案是目錄，則會對其進行遞迴處理。\n資訊清單檔案名稱、存檔檔案名稱以及進入點名稱\n的指定順序與指定 'm'、'f' 以及 'e' 旗標的順序相同。\n\n範例 1: 將兩個類別檔案存檔至名為 classes.jar 的存檔中: \n       jar cvf classes.jar Foo.class Bar.class \n範例 2: 使用現有的資訊清單檔案 'mymanifest' 並將\n           foo/ 目錄中的所有檔案存檔至 'classes.jar': \n       jar cvfm classes.jar mymanifest -C foo/。\n

main.usage.summary=用法: jar [OPTION...] [ [--release VERSION] [-C dir] files] ...
main.usage.summary.try=請使用 'jar --help' 以取得更多的資訊。

main.help.preopt=用法: jar [OPTION...] [ [--release VERSION] [-C dir] files] ...\njar 會建立一個類別和資源的存檔，而且可操控或\n從存檔回復個別類別或資源。\n\n 範例:\n # 建立一個名為 classes.jar 的存檔，其中含有兩個類別檔案:\n jar --create --file classes.jar Foo.class Bar.class\n # 使用現有的資訊清單加上 foo/ 中的所有檔案建立一個存檔:\n jar --create --file classes.jar --manifest mymanifest -C foo/ .\n # 建立一個模組化 jar 存檔，其中的模組描述區位於\n # classes/module-info.class:\n jar --create --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ classes resources\n # 將現有的非模組化 jar 更新成模組化 jar:\n jar --update --file foo.jar --main-class com.foo.Main --module-version 1.0\n     -C foo/ module-info.class\n # 建立多重版本的 jar，將部分檔案放置在 META-INF/versions/9 目錄中:\n jar --create --file mr.jar -C foo classes --release 9 -C foo9 classes\n\n若要縮短或簡化 jar 命令，可以在個別文字檔中指定引數，\n然後使用 at 符號 (@) 作為前置碼，將其傳送至 jar 命令。\n\n 範例:\n # 從 classes.list 檔案讀取額外的選項和類別檔案清單\n jar --create --file my.jar @classes.list\n
main.help.opt.main=\ 主要作業模式:\n
main.help.opt.main.create=\  -c, --create               建立存檔
main.help.opt.main.generate-index=\  -i, --generate-index=FILE  為指定的 jar 存檔產生索引\n                             資訊
main.help.opt.main.list=\  -t, --list                 列出存檔的目錄
main.help.opt.main.update=\  -u, --update               更新現有的 jar 存檔
main.help.opt.main.extract=\  -x, --extract              從存檔中擷取指定 (或所有) 檔案
main.help.opt.main.describe-module=\  -d, --describe-module      列印模組描述區或自動產生的模組名稱
main.help.opt.any=\ 可在任何模式下使用的作業修飾條件:\n\n  -C DIR                     變更為指定目錄並包含\n                             下列檔案
main.help.opt.any.file=\  -f, --file=FILE            存檔檔案名稱。如果省略，會根據作業使用\n                             stdin 或 stdout\n      --release VERSION      將所有下列檔案放置在 jar 的啟動多版本\n                             功能目錄中 (例如 META-INF/versions/VERSION/)
main.help.opt.any.verbose=\  -v, --verbose              在標準輸出中產生詳細輸出
main.help.opt.create=\ 只能在建立模式使用的作業修飾條件:\n
main.help.opt.create.update=\ 只能在建立和更新模式下使用的作業修飾條件:\n
main.help.opt.create.update.main-class=\  -e, --main-class=CLASSNAME 隨附於模組化或可執行\n                             jar 存檔中獨立應用程式的\n                             應用程式進入點
main.help.opt.create.update.manifest=\  -m, --manifest=FILE        包含指定資訊清單檔案中的資訊清單\n                             資訊
main.help.opt.create.update.no-manifest=\  -M, --no-manifest          不為項目建立資訊清單檔案
main.help.opt.create.update.module-version=\      --module-version=VERSION    建立模組化 jar 或更新非模組化 jar 時\n                             使用的模組版本
main.help.opt.create.update.hash-modules=\      --hash-modules=PATTERN 運算及記錄與指定樣式\n                             相符的模組雜湊，這直接或間接地\n                             相依於正在建立的模組化 jar 或正在\n                             更新的非模組化 jar
main.help.opt.create.update.module-path=\  -p, --module-path          模組相依性的位置，用於產生\n                             雜湊
main.help.opt.create.update.do-not-resolve-by-default=\      --do-not-resolve-by-default  不包括預設的模組設定根目錄
main.help.opt.create.update.warn-if-resolved=\      --warn-if-resolved     若模組已解析，則提示工具以發出警告。\n                             deprecated、deprecated-for-removal 或 incubating \n                             其中之一
main.help.opt.create.update.index=\ 只能在建立、更新及產生索引模式下使用的作業修飾條件:\n
main.help.opt.create.update.index.no-compress=\  -0, --no-compress          僅儲存; 不使用 ZIP 壓縮方式
main.help.opt.other=\ 其他選項:\n
main.help.opt.other.help=\  -h, --help[:compat]        提供此說明或選擇性顯示相容性說明
main.help.opt.other.help-extra=\      --help-extra           提供額外選項的說明
main.help.opt.other.version=\      --version              列印程式版本
main.help.postopt=\ 如果模組描述區 ('module-info.class') 位於指定目錄的根\n 或 jar 存檔本身的根，則存檔會是\n 模組化的 jar。下列作業只能在建立模組化 jar 或更新\n 現有非模組化 jar 時進行: '--module-version'、\n '--hash-modules' 和 '--module-path'。\n\n 長選項的強制性或選擇性引數也會是任何對應短選項的\n 強制性或選擇性引數。
