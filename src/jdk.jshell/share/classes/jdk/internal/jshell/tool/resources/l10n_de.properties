#
# Copyright (c) 2016, 2024, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =Willkommen bei JShell - Version {0}\nGeben Sie für eine Einführung Folgendes ein: /help intro
jshell.err.opt.arg = Argument für {0} fehlt.
jshell.err.opt.invalid = Ungültige Optionen: {0}.
jshell.err.opt.one = Es darf nur eine {0}-Option verwendet werden.
jshell.err.opt.startup.conflict = Nicht miteinander vereinbare Optionen: Es wurde sowohl --startup als auch --no-startup verwendet.
jshell.err.opt.feedback.one = Es darf nur eine Feedbackoption (--feedback, -q, -s oder -v) verwendet werden.
jshell.err.opt.unknown = Unbekannte Option: {0}

jshell.msg.terminated = Status-Engine beendet.
jshell.msg.terminated.restore = Stellen Sie Definitionen wieder her mit: /reload -restore

jshell.msg.use.one.of = Verwenden Sie eine der folgenden Optionen: {0}
jshell.msg.see.classes.etc = Siehe /types, /methods, /vars oder /list
jshell.err.arg = Ungültiges "{0}"-Argument: {1}
jshell.msg.see = Hilfe finden Sie unter {0}.

jshell.err.file.not.accessible = Auf Datei "{1}" für "{0}" kann nicht zugegriffen werden: {2}
jshell.err.file.not.found = Datei "{1}" für "{0}" nicht gefunden.
jshell.err.file.exception = Datei "{1}" für "{0}" hat eine Ausnahme ausgelöst: {2}
jshell.err.file.filename = Für "{0}" muss ein Dateinamenargument angegeben werden.

jshell.err.startup.unexpected.exception = Unerwartete Ausnahme beim Lesen von Startinformationen: {0}
jshell.err.unexpected.exception = Unerwartete Ausnahme: {0}

jshell.err.invalid.command = Ungültiger Befehl: {0}
jshell.err.command.ambiguous = Befehl "{0}" ist mehrdeutig: {1}
jshell.msg.set.restore = Es werden neue Optionen festgelegt, und der Status wird wiederhergestellt.
jshell.msg.set.editor.set = Editor gesetzt auf: {0}
jshell.msg.set.editor.retain = Editoreinstellung beibehalten: {0}
jshell.msg.set.indent.set = Einzugsebene gesetzt auf: {0}
jshell.err.invalid.indent = Ungültige Einzugsebene: {0}
jshell.err.no.builtin.editor = Integrierter Editor nicht verfügbar.
jshell.err.cant.launch.editor = Integrierter Editor kann nicht gestartet werden - unerwartete Ausnahme: {0}
jshell.msg.try.set.editor = Informationen zum Verwenden des externen Editors finden Sie unter "/help /set editor".
jshell.msg.press.return.to.leave.edit.mode = Drücken Sie die Eingabetaste, um den Bearbeitungsmodus zu verlassen.
jshell.err.wait.applies.to.external.editor = -wait gilt für externe Editoren
jshell.label.editpad = JShell-Bearbeitungs-Pad

jshell.err.setting.to.retain.must.be.specified = Die beizubehaltende Einstellung muss angegeben werden - {0}
jshell.msg.set.show.mode.settings = \nVerwenden Sie zum Anzeigen der Moduseinstellungen "/set prompt", "/set truncation", ...,\noder verwenden Sie "/set mode" gefolgt von dem Feedbackmodusnamen.
jshell.err.continuation.prompt.required = Fortsetzungs-Prompt erforderlich - {0}

jshell.msg.try.command.without.args = Verwenden Sie "{0}" ohne Argumente.
jshell.msg.no.active = Keine aktiven Definitionen vorhanden.

jshell.msg.resetting = Wird zurückgesetzt...
jshell.msg.resetting.state = Status wird zurückgesetzt.

jshell.err.reload.no.previous = Keine vorherige Historie zum Wiederherstellen vorhanden
jshell.err.reload.restarting.previous.state = Es wird ein Neustart ausgeführt und der vorherige Status wiederhergestellt.
jshell.err.reload.restarting.state = Neustart wird ausgeführt und Status wiederhergestellt.

jshell.err.restart.failed = Neustart nicht erfolgreich: {0}\n\nVorherige Einstellungen werden wiederhergestellt, und ein Neustart wird ausgeführt...

jshell.msg.vars.not.active = (nicht aktiv)

jshell.err.out.of.range = Außerhalb des zulässigen Bereichs

jshell.msg.error = Fehler:
jshell.msg.warning = Warnung:

jshell.err.sub.arg = Für den Befehl "{0}" ist ein Unterbefehl erforderlich. Siehe: "/help {0}"
jshell.err.sub.ambiguous = Mehrdeutiges Unterbefehlsargument für "{0}": {1}

jshell.err.classpath.arg = Für den /classpath-Befehl ist ein Pfadargument erforderlich.
jshell.msg.classpath = Pfad "{0}" zu Classpath hinzugefügt

jshell.err.help.arg = Es beginnen keine Befehle oder Themen mit dem angegebenen Argument: {0}
jshell.msg.help.begin =Geben Sie einen Java-Sprachausdruck, eine Anweisung oder eine Deklaration ein.\nSie können auch einen der folgenden Befehle eingeben:\n
jshell.msg.help.subject =\nUm weitere Informationen zu erhalten, geben Sie "/help" gefolgt von dem Namen\neines Befehls oder Themas ein.\nBeispiel: "/help /list" oder "/help intro".\n\nThemen:\n\n

jshell.err.no.snippet.with.id = Kein Snippet mit ID: {0}
jshell.err.end.snippet.range.less.than.start = Snippet-Bereichsende niedriger als Bereichsanfang: {0} - {1}
jshell.err.range.requires.id = Für Snippet-Bereiche sind Snippet-IDs erforderlich: {0}

jshell.err.exit.not.expression = Das Argument für /exit muss ein gültiger ganzzahliger Ausdruck sein. Es ist jedoch kein Ausdruck: {0}
jshell.err.exit.bad.type = Das Argument für /exit muss ein gültiger ganzzahliger Ausdruck sein. Der Typ ist {1} : {0}
jshell.err.exit.bad.value = Das Argument für /exit besitzt den ungültigen Wert {1} : {0}

jshell.err.drop.arg =Geben Sie im /drop-Argument einen zu löschenden Import oder eine zu löschende Variable, Methode oder Klasse an.\nGeben Sie die Elemente nach ID oder Name an. Verwenden Sie /list, um IDs anzuzeigen. Verwenden Sie /reset, um den gesamten Status zurückzusetzen.
jshell.err.failed = Nicht erfolgreich.
jshell.msg.native.method = Native Methode
jshell.msg.unknown.source = Unbekannte Quelle
jshell.msg.goodbye = Auf Wiedersehen
jshell.msg.goodbye.value = Auf Wiedersehen ({0})

jshell.msg.help.for.help = Geben Sie /help für einen Hilfetext ein.

jshell.err.mode.name = Feedbackmodusname erwartet: {0}
jshell.err.missing.mode = Feedbackmodus fehlt - {0}
jshell.err.field.name = Feldname erwartet: {0} - {1}
jshell.err.mode.unknown = Kein Feedbackmodus benannt: {0} - {1}

jshell.err.feedback.does.not.match.mode = Entspricht keinem aktuellen Feedbackmodus: {0} - {1}
jshell.err.feedback.ambiguous.mode = Entspricht mehr als einem aktuellen Feedbackmodus: {0} - {1}
jshell.err.feedback.must.be.quoted = Format "{0}" muss in Anführungszeichen gesetzt werden - {1}
jshell.err.feedback.not.a.valid.selector = Kein gültiger Selektor "{0}" in "{1}" - {2}
jshell.err.feedback.multiple.sections = Art des Selektors in mehreren Abschnitten der Selektorliste "{0}" in "{1}" - {2}
jshell.err.feedback.different.selector.kinds = Unterschiedliche Arten von Selektoren in denselben Abschnitten der Selektorliste "{0}" in "{1}" - {2}

jshell.msg.feedback.new.mode = Neuen Feedbackmodus erstellt: {0}
jshell.msg.feedback.mode = Feedbackmodus: {0}
jshell.msg.feedback.mode.following = Verfügbare Feedbackmodi:
jshell.msg.feedback.retained.mode.following = Beibehaltene Feedbackmodi:
jshell.err.mode.creation = Zum Erstellen eines neuen Modus muss entweder die Option -command oder die Option -quiet verwendet werden - {0}
jshell.err.mode.exists = Zu erstellender Modus ist bereits vorhanden: {0} - {1}

jshell.err.truncation.expected.length = Erwartete Abschneidelänge - {0}
jshell.err.truncation.length.not.integer = Abschneidelänge muss eine Ganzzahl sein: {0} - {1}

jshell.err.not.valid.with.predefined.mode = Nicht gültig mit einem vordefinierten Modus: {0} - {1}
jshell.err.retained.feedback.mode.must.be.retained.or.predefined = Für "/set feedback -retain <Modus>" muss <Modus> vordefiniert werden oder mit "/set mode -retain" beibehalten worden sein - {0}

jshell.err.unknown.option = Unbekannte Option: {0} - {1}
jshell.err.default.option.or.program = Geben Sie Option -default, Option -delete oder das Programm an - {0}
jshell.err.option.or.filename = Geben Sie maximal eine der Optionen -default, -none oder einen Startdateinamen an - {0}
jshell.err.unexpected.at.end = Unerwartete Argumente am Ende des Befehls: {0} - {1}
jshell.err.conflicting.options = Nicht miteinander vereinbare Optionen - {0}
jshell.err.cannot.delete.current.mode = Der aktuelle Feedbackmodus "{0}" kann nicht gelöscht werden. Verwenden Sie zunächst "/set feedback" - {1}
jshell.err.cannot.delete.retained.mode = Der beibehaltene Feedbackmodus "{0}" kann nicht gelöscht werden. Verwenden Sie zunächst "/set feedback -retain" - {1}
jshell.err.may.not.specify.options.and.snippets = Optionen und Snippets dürfen nicht gemeinsam verwendet werden: {0}
jshell.err.no.such.snippets = Snippet nicht vorhanden: {0}
jshell.err.the.snippet.cannot.be.used.with.this.command = Dieser Befehl akzeptiert das Snippet "{0}" nicht: {1}
jshell.err.retained.mode.failure = Fehler in beibehaltenen Modi (Modi gelöscht) - {0} {1}

jshell.err.corrupted.stored.startup = Gespeicherter Start beschädigt. Standardwert wird verwendet - {0}

jshell.err.exception.thrown = Ausnahme {0}
jshell.err.exception.thrown.message = Ausnahme {0}: {1}
jshell.err.exception.cause = Verursacht von: {0}
jshell.err.exception.cause.message = Verursacht von: {0}: {1}

jshell.console.see.synopsis = <Erneut Tabulatortaste drücken, um Zusammenfassung anzuzeigen>
jshell.console.see.full.documentation = <Erneut Tabulatortaste drücken, um vollständige Dokumentation anzuzeigen>
jshell.console.see.documentation = <Erneut Tabulatortaste drücken, um Dokumentation anzuzeigen>
jshell.console.see.next.page = <Erneut Tabulatortaste drücken, um nächste Seite anzuzeigen>
jshell.console.see.next.javadoc = <Tabulatortaste drücken, um nächste Dokumentation anzuzeigen>
jshell.console.see.next.command.doc = <Tabulatortaste drücken, um nächsten Befehl anzuzeigen>
jshell.console.no.such.command = Befehl nicht vorhanden
jshell.console.completion.current.signatures = Signaturen:
jshell.console.completion.all.completions.number = <Erneut Tabulatortaste drücken, um alle möglichen Abschlüsse anzuzeigen. Insgesamt mögliche Abschlüsse: {0}>
jshell.console.completion.all.completions = <Erneut Tabulatortaste drücken, um alle möglichen Abschlüsse anzuzeigen>
jshell.console.no.javadoc = <Keine Dokumentation gefunden>
jshell.console.do.nothing = Nichts machen
jshell.console.choice = Auswahl:\u0020

jshell.console.create.variable = Variable erstellen
jshell.console.create.method = Methode erstellen
jshell.console.resolvable = \nDie ID kann in diesem Kontext aufgelöst werden.
jshell.console.no.candidate = \nKeine vollqualifizierten Kandidatennamen für Import gefunden.
jshell.console.incomplete = \nErgebnisse sind möglicherweise unvollständig. Wiederholen Sie den Vorgang später, um vollständige Ergebnisse zu erhalten.
jshell.console.erroneous = \nUnvollständig oder fehlerhaft. Ein einzelner gültiger Ausdruck oder eine einzelne gültige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.
jshell.console.exprstmt = \nEin einzelner gültiger Ausdruck oder eine einzelne gültige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.
jshell.console.empty = \nLeerer Eintrag. Ein einzelner gültiger Ausdruck oder eine einzelne gültige Anweisung muss Umschalt+Tab gefolgt von M vorangehen.

jshell.fix.wrong.shortcut =Unerwartetes Zeichen nach Umschalt+Tab.\nVerwenden Sie "I" für automatischen Import, "V" zur Variablenerstellung oder "M" zur Methodenerstellung.\nWeitere Informationen finden Sie unter:\n/help shortcuts

help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\nMögliche Optionen:\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\n    --add-modules <Modul>(,<Modul>)*\n                          Gibt aufzulösende Module oder alle Module im\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs lautet\n    --enable-native-access\n                          Ermöglicht Ausführung eingeschränkter nativer Methoden durch Code\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausführung\n    --no-startup          Startdefinitionen werden nicht ausgeführt\n    --feedback <Modus>     Gibt den anfänglichen Feedbackmodus an. Der Modus kann\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\n                            vorab benutzerdefiniert sein\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\n    -s                    Äußerst stilles Feedback. Identisch mit: --feedback silent\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\n    -J<Kennzeichen>              Übergibt <Kennzeichen> an das Laufzeitsystem, hat aber keine Auswirkungen\n                            auf die Ausführung von Code-Snippets. Um Kennzeichen anzugeben,\n                            die die Ausführung von Code-Snippets beeinflussen, verwenden Sie\n                            -R<Kennzeichen>. Verwenden Sie alternativ dazu -J<Kennzeichen> mit\n                            --execution local.\n    -R<Kennzeichen>              Übergibt <Kennzeichen> nur dann an das Laufzeitsystem, wenn\n                            Code-Snippets ausgeführt werden. Beispiel: -R-Dfoo=bar\n                            bedeutet, dass die Ausführung des Snippets\n                            System.getProperty("foo") "bar" zurückgibt.\n    -C<Kennzeichen>              Übergibt <Kennzeichen> an den Java-Compiler in JShell.\n                            Beispiel: -C-Xlint aktiviert alle empfohlenen\n                            LINT-Warnungen, und -C--release=<N> kompiliert für\n                            Java SE N, wie wenn --release N angegeben wird.\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\n\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\nPRINTING, TOOLING oder JAVASE.\nEine Ladedatei kann auch "-" zur Angabe einer Standardeingabe ohne interaktiven I/O sein.\n\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\n--module-path und --add-modules) finden Sie unter:\n\t/help context\n\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\nDoppelpunkt (:), um Elemente zu trennen.\n
help.usage.x = \    --add-exports <Modul>/<Package>   Gibt ein Package an, das als\n                                         Export aus seinem definierenden Modul gelten soll \n    --execution <Spezifikation>                 Gibt eine alternative Ausführungs-Engine an.\n                                         Dabei gilt: <Spezifikation> ist eine ExecutionControl-Spezifikation.\n                                         In der Dokumentation zu dem Package\n                                         jdk.jshell.spi finden Sie Informationen zur Syntax der Spezifikation\n    \nDies sind keine Standardoptionen und können jederzeit ohne vorherige Ankündigung geändert werden.\n

help.list.summary = Listet die eingegebene Quelle auf
help.list.args = [<Name oder ID>|-all|-start]
help.list =Zeigt die Snippets mit vorangestellten Snippet-IDs an.\n\n/list\n\tListet die derzeit aktiven Code-Snippets auf, die Sie eingegeben oder mit /open eingelesen haben\n\n/list -start\n\tListet die ausgewerteten Start-Snippets auf\n\n/list -all\n\tListet alle Snippets auf, einschließlich aller nicht erfolgreichen, überschriebenen, gelöschten und Start-Snippets\n\n/list <Name>\n\tListet Snippets mit dem angegebenen Namen auf (aktive Snippets werden bevorzugt aufgeführt)\n\n/list <ID>\n\tFührt das Snippet mit der angegebenen Snippet-ID auf.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.edit.summary = Bearbeitet einen Quelleintrag
help.edit.args = <Name oder ID>
help.edit =Bearbeitet ein oder mehrere Code-Snippets in einem externen Editor.\nDer zu verwendende Editor wird mit /set editor festgelegt. Wenn kein Editor festgelegt wird, werden\ndie folgenden Umgebungsvariablen in der folgenden Reihenfolge geprüft: JSHELLEDITOR, VISUAL\nund EDITOR. Wenn kein Editor und auch keine der Editorumgebungsvariablen festgelegt wurde,\nwird ein einfacher Editor gestartet.\n\n/edit <Name>\n\tBearbeitet die Snippets mit den angegebenen Namen (aktive Snippets werden bevorzugt aufgeführt)\n\n/edit <ID>\n\tBearbeitet das Snippet mit der angegebenen Snippet-ID.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/edit -start\n\tBearbeitet die Start-Snippets. Vorgenommene Änderungen gelten nur für diese Session und\n\twirken sich nicht auf die Starteinstellung aus\n\n/edit -all\n\tBearbeitet alle Snippets, einschließlich aller nicht erfolgreichen, überschriebenen, gelöschten und Start-Snippets\n\n/edit\n\tBearbeitet das derzeit aktive Code-Snippet, das Sie eingegeben oder mit /open eingelesen haben

help.drop.summary = Löscht einen Quelleintrag
help.drop.args = <Name oder ID>
help.drop =Löscht ein Snippet (deaktiviert es).\n\n/drop <Name>\n\tLöscht das Snippet mit dem angegebenen Namen\n\n/drop <ID>\n\tLöscht das Snippet mit der angegebenen Snippet-ID.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.save.summary = Speichert die Snippet-Quelle in einer Datei
help.save.args = [-all|-history|-start] <Datei>
help.save =Speichert die angegebenen Snippets und/oder Befehle in der angegebenen Datei.\n\n/save <Datei>\n\tSpeichert die Quelle derzeit aktiver Snippets in der Datei.\n\n/save -all <Datei>\n\tSpeichert die Quelle aller Snippets in der Datei.\n\tUmfasst die Quelle von überschriebenem, nicht erfolgreichem und Startcode\n\n/save -history <Datei>\n\tSpeichert die sequenzielle Historie aller Befehle und Snippets, die seit dem\n\tStart des JShell-Tools eingegeben wurden.\n\n/save -start <Datei>\n\tSpeichert die aktuellen Startdefinitionen in der Datei\n\n/save <ID> <Datei>\n\tSpeichert das Snippet mit der angegebenen Snippet-ID.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"

help.open.summary = Öffnet eine Datei als Quelleingabe
help.open.args = <Datei>
help.open =Datei öffnen und ihren Inhalt als Snippets und Befehle lesen.\n\n/open <Datei>\n\tAngegebene Datei als JShell-Tooleingabe lesen.\n/open <URL>\n\tAngegebene URL herunterladen und als JShell-Tooleingabe verwenden.\n\nDie <Datei> kann der Name einer Betriebssystemdatei oder einer der folgenden vordefinierten\nDateinamen sein: DEFAULT, PRINTING, TOOLING oder JAVASE.\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\nDefinitionen der Methoden-Snippets print(), println() und printf(),\nDefinitionen\nvon Methoden-Snippets, die JDK-Tools ausführen, oder Importe aller Java SE-Packages.\n

help.vars.summary = Listet die deklarierten Variablen und ihre zugehörigen Werte auf
help.vars.args = [<Name oder ID>|-all|-start]
help.vars =Listet den Typ, Namen und Wert der eingegebenen Variablen auf.\n\n/vars\n\tListet den Typ, Namen und Wert der derzeit aktiven Variablen auf\n\n/vars <Name>\n\tListet Variablen mit dem angegebenen Namen auf (aktive Variablen werden bevorzugt aufgeführt)\n\n/vars <ID>\n\tListet die Variable mit der angegebenen Snippet-ID auf.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/vars -start\n\tListet die Variablen in den ausgewerteten Start-Snippets auf\n\n/vars -all\n\tListet alle Variablen auf, einschließlich aller nicht erfolgreichen, überschriebenen, gelöschten und Startvariablen

help.methods.summary = Listet die deklarierten Methoden und ihre zugehörigen Signaturen auf
help.methods.args = [<Name oder ID>|-all|-start]
help.methods =Listet den Namen, die Parametertypen und den Rückgabetyp der eingegebenen Methoden auf.\n\n/methods\n\tListet den Namen, die Parametertypen und den Rückgabetyp der derzeit aktiven Methoden auf\n\n/methods <Name>\n\tListet die Methoden mit dem angegebenen Namen auf (aktive Methoden werden bevorzugt aufgeführt)\n\n/methods <ID>\n\tListet die Methode mit der angegebenen Snippet-ID auf.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/methods -start\n\tListet die Methoden in den ausgewerteten Start-Snippets auf\n\n/methods -all\n\tListet alle Snippets auf, einschließlich aller nicht erfolgreichen, überschriebenen, gelöschten und Start-Snippets

help.types.summary = Listet die Typdeklarationen auf
help.types.args =[<Name oder ID>|-all|-start]
help.types =Listet eingegebene Klassen und Schnittstellen auf.\n\n/types\n\tListet die derzeit aktiven Typdeklarationen auf\n\n/types <Name>\n\tListet die Typdeklarationen mit dem angegebenen Namen auf (aktive Snippets werden bevorzugt aufgeführt)\n\n/types <ID>\n\tListet die Typdeklaration mit der angegebenen Snippet-ID auf.\n\tEs können mehrere IDs oder ID-Bereiche verwendet werden, siehe "/help id"\n\n/types -start\n\tListet die Typdeklarationen in den ausgewerteten Start-Snippets auf\n\n/types -all\n\tListet alle Typdeklarationen auf, einschließlich aller nicht erfolgreichen, überschriebenen, gelöschten und Starttypdeklarationen

help.imports.summary = Listet die importierten Elemente auf
help.imports.args =
help.imports =Listet die derzeit aktiven Importe auf. Dies umfasst Importe aus\nStart-Snippets.

help.exit.summary = Beendet das JShell-Tool
help.exit.args =[<Snippet mit ganzzahligem Ausdruck>]
help.exit =Beendet das JShell-Tool. Änderungen werden nicht gespeichert.\nSpeichern Sie Ihre Änderungen, bevor Sie diesen Befehl ausführen\n\n/exit\n\tBeendet das JShell-Tool. Der Beendigungsstatus ist null\n\n/exit <Snippet mit ganzzahligem Ausdruck>\n\tWertet das Snippet aus. Wenn das Snippet nicht erfolgreich oder kein ganzzahliger Ausdruck ist,\n\twird der Fehler angezeigt. Andernfalls wird das JShell-Tool mit dem\n\tAusdruckswert als Beendigungsstatus beendet

help.reset.summary = Setzt das JShell-Tool zurück
help.reset.args = [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>]...
help.reset =Setzt den Code und den Ausführungsstatus des JShell-Tools zurück:\n\t* Der gesamte eingegebene Code geht verloren\n\t* Der Ausführungsstatus wird neu gestartet\n\t* Der Startcode wird erneut ausgeführt\nSpeichern Sie Ihre Änderungen, bevor Sie diesen Befehl verwenden.\nDer /reset-Befehl akzeptiert Auswertungskontextoptionen, siehe:\n\n\t/help context\n

help.reload.summary = Setzt die relevante Historie (derzeitige oder vorherige) zurück und gibt sie erneut wieder (-restore)
help.reload.args = [-restore] [-quiet] [-class-path <Pfad>] [-module-path <Pfad>]...
help.reload =Setzt den Code und den Ausführungsstatus des JShell-Tools zurück und gibt anschließend jedes gültige Snippet\nsowie alle /drop-Befehle in der Reihenfolge wieder, in der sie eingegeben wurden.\n\n/reload\n\tDient zum Zurücksetzen und Wiedergeben der gültigen Historie seit Starten des JShell-Tools bzw.\n\tseit Ausführung eines /reset- oder /reload-Befehls - je nachdem, was\n\tals Letztes erfolgt ist\n\n/reload -restore\n\tDient zum Zurücksetzen und Wiedergeben der gültigen Historie zwischen dem vorherigen und aktuellen\n\tStarten des JShell-Tools bzw. der Ausführung eines /reset-, /reload- oder /env-\n\tBefehls. Diese Wiedergabe kann somit zum Wiederherstellen einer vorherigen\n\tJShell-Toolsession verwendet werden\n\n/reload [-restore] -quiet\n\tMit dem Argument "-quiet" wird die Wiedergabe nicht angezeigt, etwaige Fehler\n\thingegen schon\n\nJeder der obigen Befehle akzeptiert Auswertungskontextoptionen, siehe:\n\n\t/help context\n\nBeispiel:\n\n\t/reload -add-modules com.greetings -restore

help.env.summary = Zeigt den Auswertungskonzept an oder ändert ihn
help.env.args = [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>] ...
help.env =Zeigt den Auswertungskontext an oder ändert ihn. Der Auswertungskontext ist der Classpath,\nModulpfad usw.\n\n/env\n\tZeigt den Auswertungskontext als Kontextoptionen an\n\n/env [-class-path <Pfad>] [-module-path <Pfad>] [-add-modules <Module>] ...\n\tDurch Festlegen mindestens einer Option wird der Auswertungskontext festgelegt. Wenn Snippets\n\tdefiniert wurden, wird der Ausführungsstatus auf den neuen Auswertungskontext\n\tzurückgesetzt, und die Snippets werden erneut wiedergegeben. Die Wiedergabe wird nicht \n\tangezeigt, etwaige Fehler hingegen schon. Dies entspricht:\n\n\t\t/reload -quiet ...\n\nWeitere Einzelheiten zu Auswertungskontextoptionen finden Sie unter:\n\n\t/help context\n\nBeispiel:\n\n\t/env -add-modules com.greetings

help.history.summary = Historie Ihrer Eingaben
help.history.args = [-all]
help.history =Zeigt die Historie der Snippet- und Befehlseingaben an.\n\n/history\n\tListet die Historie der Snippet- und Befehlseingaben seit Start des JShell-Tools auf\n\n/history -all\n\tListet die gesamte Historie der Snippet- und Befehlseingaben aus dieser und vorherigen Sessions auf

help.debug.summary = Schaltet Debugging des JShell-Tools um
help.debug.args = [0][r][g][f][c][d][e]
help.debug =Zeigt Debugginginformationen für die JShell-Toolimplementierung an.\n0: Debugging deaktiviert\nr: Debugging auf Toolebene aktiviert\ng: Allgemeines Debugging aktiviert\nf: Dateimanagerdebugging aktiviert\nc: Abschlussanalysedebugging aktiviert\nd: Abhängigkeitsdebugging aktiviert\ne: Ereignisdebugging aktiviert

help.help.summary = Ruft Informationen zur Verwendung des JShell-Tools ab
help.help.args = [<Befehl>|<Thema>]
help.help =Zeigt Informationen zur Verwendung des JShell-Tools an.\n/help\n\tListet die Befehle und Hilfethemen des JShell-Tools auf\n\n/help <Befehl>\n\tZeigt Informationen zum angegebenen Befehl an.\n\tNur die ersten paar Buchstaben des Befehls werden benötigt - bei mehr als einer\n\tÜbereinstimmung wird jede einzelne angezeigt. Beispiel: /help /li\n\n/help <Thema>\n\tZeigt Informationen zu dem angegebenen Hilfethema an. Beispiel: /help intro

help.set.summary = Legt Konfigurationsinformationen fest
help.set.args = editor|start|feedback|mode|prompt|truncation|format ...
help.set =Legt die Konfigurationsinformationen für das JShell-Tool fest, darunter:\nden zu verwendenden externen Editor, die zu verwendenden Startdefinitionen, einen neuen Feedbackmodus,\nden Befehls-Prompt, den zu verwendenden Feedbackmodus oder das Ausgabeformat.\n\n/set editor [-wait] <Befehl> <optionales Argument>...\n\tGibt den Befehl an, der für den /edit-Befehl gestartet werden soll.\n\tDer <Befehl> ist eine betriebssystemabhängige Zeichenfolge\n\n/set start <Datei>\n\tDer Inhalt der angegebenen <Datei> wird zu den Standardstart-Snippets und -befehlen\n\n/set feedback <Modus>\n\tLegt den Feedbackmodus fest, der das angezeigte Feedback für eingegebene Snippets und Befehle beschreibt\n\n/set mode <Modus> [<alter Modus>] -command|-quiet|-delete\n\tErstellt oder aktualisiert einen benutzerdefinierten Feedbackmodus. Optional kann er auch von einem vorhandenen Modus kopiert werden\n\n/set prompt <Modus> "<Prompt>" "<Fortsetzungs-Prompt>"\n\tLegt die angezeigten Prompts für einen angegebenen Feedbackmodus fest\n\n/set truncation <Modus> <Länge> <Selektor>...\n\tLegt die maximale Länge eines angezeigten Wertes fest\n\n/set format <Modus> <Feld> "<Format>" <Selektor>...\n\tKonfiguriert einen Feedbackmodus durch Festlegen des Formats eines Feldes, wenn der Selektor übereinstimmt\n\n/set indent <Anzahl>\n\tLegt die Anzahl der Leerzeichen fest, mit denen Snippets automatisch eingerückt werden sollen\n\n/set\n\tZeigt Editor-, Start- und Feedbackeinstellungen als /set-Befehle an.\n\tLassen Sie den festgelegten Wert weg, um die Einstellungen eines der oben genannten Befehle anzuzeigen\n\nUm weitere Informationen zu einem dieser Formate zu erhalten, verwenden Sie /help mit dem angegebenen Format.\nBeispiel:   /help /set format

help.quest.summary = Ruft Informationen zur Verwendung des JShell-Tools ab
help.quest.args = [<Befehl>|<Thema>]
help.quest =Zeigt Informationen zur Verwendung des JShell-Tools an (Abkürzung für /help).\n/?\n\tZeigt eine Liste der Befehle und Hilfethemen an\n/? <Befehl>\n\tZeigt Informationen zum angegebenen Befehl an.\n\tNur die ersten paar Buchstaben des Befehls werden benötigt - bei mehr als einer\n\tÜbereinstimmung wird jeder einzelne angezeigt. Beispiel: /? /li\n\n/? <Thema>\n\tZeigt Informationen zu dem angegebenen Hilfethema an. Beispiel: /? intro

help.bang.summary = Führt das letzte Snippet erneut aus, siehe: /help rerun
help.bang.args =
help.bang =Wertet das zuletzt eingegebene Snippet erneut aus.

help.slashID.summary = Führt Snippets nach ID oder ID-Bereich erneut aus, siehe: /help rerun
help.slashID.args =
help.slashID =/<id> <id> <id>\n\n/<id>-<id>\n\nWertet die durch die ID oder den ID-Bereich angegebenen Snippets erneut aus.\nEin ID-Bereich wird als zwei per Bindestrich getrennte IDs dargestellt. Beispiel:  3-17\nStart- und Fehler-Snippets können verwendet werden. Beispiel: s3-s9 oder e1-e4\nEs können beliebig viele IDs oder ID-Bereiche verwendet werden. Beispiel: /3-7 s4 14-16 e2\nSiehe "/help id".

help.previous.summary = Führt das n-te vorherige Snippet erneut aus, siehe: /help rerun
help.previous.args =
help.previous =Wertet das n-te zuletzt eingegebene Snippet erneut aus.

help.intro.summary = Einführung in das JShell-Tool
help.intro =Mit dem JShell-Toll können Sie Java-Code ausführen und umgehend Ergebnisse erhalten.\nSie können eine Java-Definition (Variable, Methode, Klasse usw.) wie int x = 8,\neinen Java-Ausdruck wie x + x,\neine Java-Anweisung oder einen Java-Import eingeben.\nDiese kleinen Java-Code-Chunks werden als "Snippets" bezeichnet.\n\nAußerdem stehen Ihnen die JShell-Toolbefehle zur Verfügung, mit denen Sie Ihr Vorgehen\nbesser verstehen und steuern können. Beispiel: /list\n\nEine Liste der Befehle können Sie aufrufen mit: /help

help.keys.summary = Beschreibung der Readline-ähnlichen Eingabebearbeitung
help.keys =Das JShell-Tool bietet Unterstützung für Zeilenbearbeitung, damit Sie in Snippets\nund Befehlen navigieren und diese bearbeiten können. Sie können den aktuellen Befehl/das aktuelle Snippet bearbeiten\noder vorherige Befehle/Snippets aus der Historie abrufen, bearbeiten und ausführen.\nDiese Unterstützung ähnelt Readline/Editline mit einfachen Emacs-ähnlichen Bindings.\nEs gibt auch für das JShell-Tool spezifische Schlüsselsequenzen.\n\nZeilen- und Historiennavigation:\n\n\tEingabetaste\n\t\tGibt das aktuelle Snippet ein\n\tNach-links-Taste oder Strg+B\n\t\tNavigiert ein Zeichen zurück\n\tNach-rechts-Taste oder Strg+F\n\t\tNavigiert ein Zeichen vorwärts\n\tNach-oben-Taste oder Strg+P\n\t\tNavigiert eine Zeile nach oben, rückwärts in der Historie\n\tNach-unten-Taste oder Strg+N\n\t\tNavigiert eine Zeile nach unten, vorwärts in der Historie\n\tStrg+A\n\t\tNavigiert an den Anfang der Zeile\n\tStrg+E\n\t\tNavigiert an das Ende der Zeile\n\tMeta+B\n\t\tNavigiert ein Wort zurück\n\tMeta+F\n\t\tNavigiert ein Wort vorwärts\n\tStrg+R\n\t\tDurchsucht die Historie rückwärts\n\n\nEinfache Zeilen- und Historienbearbeitung:\n\n\tMeta+Eingabetaste oder Strg+Eingabetaste (je nach Plattform)\n\t\tFügt eine neue Zeile in das Snippet ein\n\tStrg+_ (für Unterstrich kann Umschalttaste erforderlich sein) oder Strg+X gefolgt von Strg+U\n\t\tMacht Änderung rückgängig. Wiederholen Sie die Eingabe, um weitere Änderungen rückgängig zu machen\n\tEntf\n\t\tLöscht das Zeichen bei dem oder hinter dem Cursor, je nach Betriebssystem\n\tRücktaste\n\t\tLöscht das Zeichen vor dem Cursor\n\tStrg+K\n\t\tLöscht den Text vom Cursor bis zum Ende der Zeile\n\tMeta+D\n\t\tLöscht den Text vom Cursor bis zum Ende des Wortes\n\tStrg+W\n\t\tLöscht den Text vom Cursor bis zum vorangegangenen Leerzeichen\n\tStrg+Y\n\t\tFügt den zuletzt gelöschten Text in die Zeile ein\n\tMeta+Y\n\t\tNach Strg+Y durchläuft Meta+Y den zuletzt gelöschten Text\n\tStrg+X gefolgt von Strg+K\n\t\tLöscht das gesamte Snippet\n\n\nTastenkombinationen für JShell-Tool:\n\n\tWeitere Einzelheiten können Sie aufrufen über: /help shortcuts\n\n\tTab\n\t\tSchließt Java-ID oder JShell-Befehl ab\n\tUmschalt+Tab gefolgt von V\n\t\tKonvertiert den Ausdruck in eine Variablendeklaration\n\tUmschalt+Tab gefolgt von M\n\t\tKonvertiert die Anweisung in eine Methodendeklaration\n\tUmschalt+Tab gefolgt von I\n\t\tFügt Importe für diese ID hinzu\n\t\n\nWeitere Zeilen- und Historienbearbeitung:\n\n\tStrg+L\n\t\tBereinigt den Bildschirm und gibt das Snippet erneut aus\n\tStrg+U\n\t\tLöscht die gesamte Zeile\n\tStrg+T\n\t\tTransponiert Zeichen\n\tStrg+X gefolgt von Strg+B\n\t\tNavigiert zur entsprechenden Klammer, eckigen Klammer, ...\n\tStrg+X gefolgt von =\n\t\tAktiviert den Modus zum Anzeigen der aktuellen Zeichenposition\n\tStrg+X gefolgt von Strg+O\n\t\tSchaltet um zwischen Überschreiben und Einfügen von Zeichen\n\tMeta+C\n\t\tSetzt Anfangsbuchstaben eines Wortes in Großbuchstaben\n\tMeta+U\n\t\tKonvertiert ein Wort in Großbuchstaben\n\tMeta+L\n\t\tKonvertiert ein Wort in Kleinbuchstaben\n\tMeta+0 bis Meta+9 gefolgt von Taste\n\t\tWiederholt den Vorgang die angegebene Anzahl von Malen\n\nDabei gilt z.B.: "Strg+A" bedeutet, dass Sie die Steuerungstaste gedrückt halten und A drücken.\nAuf vielen Tastaturen ist die Taste "Meta" gleichbedeutend mit der Taste "Alt".\nUnterstützung für Zeilenbearbeitung wird von JLine 3 abgeleitet.

help.shortcuts.summary = Beschreibung der Tastenanschläge für Snippet- und Befehlsabschluss,\nZugriff auf Informationen und automatische Codegenerierung
help.shortcuts =Unterstützte Tastenkombinationen:\n\n\tTab\n\t\tDrücken Sie nach Eingabe der ersten paar Buchstaben einer Java-ID,\n\t\teines JShell-Toolbefehls oder, in einigen Fällen, eines JShell-\n\t\tToolbefehlsarguments die Tabulatortaste, um die Eingabe abzuschließen.\n\t\tWenn mehrere Abschlüsse vorhanden sind, werden mögliche Abschlüsse\n\t\tangezeigt.\n\t\tDurch erneutes Drücken der Tabulatortaste wird Dokumentation angezeigt, sofern vorhanden und relevant.\n\n\tUmschalt+Tab gefolgt von V\n\t\tHalten Sie nach einem abgeschlossenen Ausdruck die Umschalttaste gedrückt,\n\t\tund drücken Sie die Tabulatortaste. Lassen Sie dann los, und drücken Sie die Taste V.\n\t\tDer Ausdruck wird in eine Variablendeklaration konvertiert, \n\t\tderen Typ auf dem Typ des Ausdrucks basiert.\n\n\tUmschalt+Tab gefolgt von M\n\t\tHalten Sie nach Abschluss eines Ausdrucks oder einer Anweisung die\n\t\tUmschalttaste gedrückt, und drücken Sie die Tabulatortaste. Lassen Sie dann los, und drücken\n\t\tSie die Taste M. Der Ausdruck bzw. die Anweisung wird in eine\n\t\tMethodendeklaration konvertiert. Bei einem Ausdruck basiert der\n\t\tRückgabetyp der Methode auf dem Typ des Ausdrucks.\n\n\tUmschalt+Tab gefolgt von I\n\t\tHalten Sie nach einer nicht auflösbaren ID die Umschalttaste gedrückt,\n\t\tund drücken Sie die Tabulatortaste. Lassen Sie dann los, und drücken Sie die Taste I.\n\t\tDas JShell-Tool schlägt daraufhin mögliche Importe vor, die die\n\t\tID basierend auf dem Inhalt des angegebenen Classpath auflösen werden.\n\t\tGeben Sie die Ziffer ein, die dem gewünschten Import entspricht,\n\t\toder drücken Sie die Taste 0, um keine Importe hinzuzufügen.\n\nInformationen zu weiteren Sondertasten können Sie aufrufen durch: /help keys

help.context.summary = Beschreibung der Auswertungskontextoptionen für /env /reload und /reset
help.context =Mit diesen Optionen wird der Auswertungskontext konfiguriert. Sie können beim Starten des \nJShell-Tools in der Befehlszeile oder beim Neustarten des JShell-Tools mit den Befehlen\n/env, /reload oder /reset als Befehlsoptionen angegeben werden.\n\nSie lauten:\n\t--class-path <Pfad>\n\t\tDer <Pfad> ist eine Liste von Verzeichnissen, JAR-Archiven\n\t\tund ZIP-Archiven, die nach Klassendateien durchsucht werden sollen.\n\t\tVerwenden Sie unter Windows ein Semikolon (;), um Elemente im Pfad\n\t\tzu trennen. Verwenden Sie auf anderen Plattformen einen Doppelpunkt (:), um Elemente zu trennen.\n\t--module-path <Pfad>...\n\t\tDer <Pfad> ist eine Liste von Verzeichnissen, JAR-Archiven\n\t\tund ZIP-Archiven, die nach Modulen durchsucht werden sollen.\n\t\tVerwenden Sie unter Windows ein Semikolon (;), um Elemente im Pfad\n\t\tzu trennen. Verwenden Sie auf anderen Plattformen einen Doppelpunkt (:), um Elemente zu trennen.\n\t--add-modules <Modulname>[,<Modulname>...]\n\t\tRoot-Module, die zusätzlich zum Ausgangsmodul aufgelöst werden sollen.\n\t\t<Modulname> kann auch ALL-DEFAULT, ALL-SYSTEM,\n\t\tALL-MODULE-PATH sein.\n\t--add-exports <Modul>/<Package>=<Zielmodul>(,<Zielmodul>)*\n\t\taktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\n\t\tunabhängig von der Moduldeklaration.\n\t\t<Zielmodul> kann ALL-UNNAMED sein, um in alle unbenannten\n\t\tModule zu exportieren. Wenn in JShell das <Zielmodul> nicht angegeben\n\t\twird (no =), wird ALL-UNNAMED verwendet.\n\nAuswertungskontextoptionen, die in der Befehlszeile eingegeben oder mit einem vorherigen\n/reset-, /env- oder /reload-Befehl angegeben werden, werden beibehalten, es sei denn,\nes wird eine Option eingegeben, die die Einstellung außer Kraft setzt.\n\nIn der Befehlszeile benötigen diese Optionen zwei Bindestriche. Beispiel: --module-path\nIn den JShell-Toolbefehlen können sie ein oder zwei Bindestriche aufweisen. Beispiel: -module-path

help.id.summary = Beschreibung der Snippet-IDs und deren Verwendung
help.id =Jedes eingegebene Code-Snippet hat eine eindeutige Snippet-ID. Auch wenn Sie\ndasselbe Snippet erneut eingeben, erhält es eine neue ID. Bei normalen Snippets ist die ID\neine aufsteigende Zahl. Snippets, die mit einem Fehler nicht erfolgreich verlaufen, haben eine\nmit "e" beginnende Snippet-ID. Start-Snippets haben eine mit "s" beginnende ID.\n\nEine Snippet-ID stellt eine der Möglichkeiten dar, in einem Befehl auf ein Snippet zu verweisen. Beispiel:\nMit dem folgenden Befehl wird das Snippet mit der ID "14" gelöscht:\n\n\t/drop 14\n\nMit dem Befehl "/list" zeigen Sie die ID eines oder mehrerer Snippets an. Um die ID\naller Snippets anzuzeigen, einschließlich aller nicht erfolgreichen, überschriebenen und Start-Snippets,\nverwenden Sie den Befehl "/list -all".\n\nSie können auch auf einen ID-Bereich verweisen, indem Sie die Anfangs-ID und die End-ID mit einem\nBindestrich trennen. Beispiel: "1-4" entspricht "1 2 3 4". Für alle Befehle,\ndie auf Snippets verweisen, kann eine Liste mit IDs, ID-Bereichen und Snippet-Namen\nals Argumenten angegeben werden. Diese Befehle sind: /list, /edit, /drop, /save, /vars, /methods,\n/types und /<id>. Einige Beispiele:\n\n\t/edit 7-23\n\n\t/save s1-s4 3-8 foo 12 myfile\n\n\t/9-12 33\n\nSiehe "/help /edit", "/help /save" bzw. "/help rerun".

help.rerun.summary = Beschreibung von Möglichkeiten zur erneuten Auswertung zuvor eingegebener Snippets
help.rerun =Es gibt vier Möglichkeiten zur erneuten Auswertung zuvor eingegebener Snippets.\nDas letzte Snippet kann erneut ausgewertet werden mit: /!\nDas n-te vorherige Snippet kann mit Schrägstrich-Minus und der jeweiligen Ziffer für n erneut ausgewertet werden. Beispiel: /-4\nBeispiel:\n\n\tjshell> 2 + 2\n\t$1 ==> 4\n\n\tjshell> /!\n\t2 + 2\n\t$2 ==> 4\n\n\tjshell> int z\n\tz ==> 0\n\n\tjshell> /-1\n\tint z;\n\tz ==> 0\n\n\tjshell> /-4\n\t2 + 2\n\t$5 ==> 4\n\nDie erneut auszuwertenden Snippets können per Snippet-ID oder ID-Bereich angegeben werden.\nEin ID-Bereich wird als zwei durch Bindestrich getrennte IDs dargestellt. Beispiel: 3-17\nEs können auch Start- und Fehler-Snippets verwendet werden. Beispiel: s3-s9 oder e1-e4\nEs können beliebig viele IDs oder ID-Bereiche verwendet werden. Beispiel: /3-7 s4 14-16 e2\nSiehe auch "/help id".\n\nAußerdem können Sie die Historie auch rückwärts durchsuchen, indem Sie Strg+R gefolgt von der zu suchenden Zeichenfolge eingeben.

help.set._retain = Mit der Option "-retain" wird eine Einstellung zur Verwendung in zukünftigen Sessions gespeichert.\nDie -retain-Option kann für die folgenden Formen von /set verwendet werden:\n\n\t/set editor -retain\n\t/set start -retain\n\t/set feedback -retain\n\t/set mode -retain\n\nWeitere Einzelheiten zu diesen Befehlen - Beispiel: /help /set editor

help.set.format.summary = Legt das Format zum Melden eines Snippet-Ereignisses fest

help.set.format = Legt das Format zum Melden eines Snippet-Ereignisses fest:\n\n\t/set format <Modus> <Feld> "<Format>" <Selektor>...\n\nZeigt Formateinstellungen an:\n\n\t/set format [<Modus> [<Feld>]]\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus - siehe "/help /set mode".\n<Feld> ist der Name des zu definierenden kontextspezifischen Formats.\n<Format> ist eine in Anführungszeichen gesetzte Zeichenfolge, die zum Wert des Feldes wird, wenn einer der\nSelektoren übereinstimmt (oder keine Selektoren vorhanden sind). Bei Verwendung dieses Formats\nwerden in geschweiften Klammern eingeschlossene Feldnamen durch den Wert des Feldes zu diesem\nZeitpunkt ersetzt. Diese Felder können zuvor mit diesem Befehl definiert worden sein oder können\neines der folgenden vordefinierten, kontextspezifischen Felder sein:\n\t{name}       == Der Name. Beispiel: Variablenname, ...\n\t{type}       == Der Typname. Der Typ einer Variablen oder eines Ausdrucks, die\n\t\t\tParametertypen einer Methode\n\t{value}      == Der Ergebniswert eines Ausdrucks oder einer Variableninitialisierung\n\t{unresolved} == Die Liste nicht aufgelöster Referenzen\n\t{errors}     == Die Liste behebbarer Fehler (nur während der Verarbeitung\n\t\t\tdes Feldes "display")\n\t{err}        == Eine nicht formatierte Fehlerzeile (nur während der Verarbeitung\n\t\t\tdes Feldes "errorline")\nZur Bestimmung des angezeigten Feedbacks greift das Tool auf folgende Felder zu:\n\t{display}    == Die angezeigte Meldung für ein Snippet-Ereignis\n\t{errorline}  == Das Format einer Fehlerzeile im Feld "errors"\n\t{pre}        == Das Feedbackpräfix (am Beginn des Befehlsfeedbacks)\n\t{post}       == Das Feedback-Postfix (am Ende des Befehlsfeedbacks)\n\t{errorpre}   == Das Fehlerpräfix (am Beginn des Fehlerfeedbacks)\n\t{errorpost}  == Das Fehler-Postfix (am Ende des Fehlerfeedbacks)\nDiese Fehler haben Standardeinstellungen (die überschrieben werden können).\nDabei gilt: <Selektor> ist der Kontext, in dem das Format angewendet wird.\nDie Struktur des Selektors besteht aus einer durch Bindestriche getrennten Liste der Selektortyplisten.\nEine Selektortypliste ist eine durch Kommas getrennte Liste der Werte eines Selektortyps.\nEin Selektor stimmt überein, wenn jede Selektortypliste übereinstimmt. Eine Selektortypliste\nstimmt überein, wenn einer der Werte übereinstimmt.\n\nDer case-Selektortyp beschreibt die Art des Snippets. Die Werte lauten:\n\timport     -- Importdeklaration\n\tclass      -- Klassendeklaration\n\tinterface  -- Schnittstellendeklaration\n\tenum       -- Enum-Deklaration\n\tannotation -- Annotationsschnittstellendeklaration\n\trecord     -- Datensatzdeklaration\n\tmethod     -- Methodendeklaration -- Hinweis: {type}==parameter-types\n\tvardecl    -- Variablendeklaration ohne Initialisierung\n\tvarinit    -- Variablendeklaration mit Initialisierung\n\texpression -- Ausdruck -- Hinweis: {name}==Scratch-Variablenname\n\tvarvalue   -- Variablenwertausdruck\n\tassignment -- Variablenzuweisung\n\tstatement  -- Anweisung\nDer action-Selektortyp beschreibt, welcher Vorgang an dem Snippet vorgenommen wurde. Die Werte lauten:\n\tadded     -- Snippet wurde hinzugefügt\n\tmodified  -- Ein vorhandenes Snippet wurde geändert\n\treplaced  -- Ein vorhandenes Snippet wurde durch ein neues Snippet ersetzt\n\toverwrote -- Ein vorhandenes Snippet wurde überschrieben\n\tdropped   -- Snippet wurde gelöscht\n\tused      -- Snippet wurde verwendet, wo es nicht zulässig war\nDer when-did-it-occur-Selektortyp beschreibt, ob es sich um eine direkte oder indirekte Aktion handelt. Die Werte lauten:\n\tprimary -- Das eingegebene Snippet\n\tupdate  -- Ein Update eines abhängigen Snippets\nDer resolution-state-Selektortyp beschreibt den Auflösungs-/Definitionsstatus des Snippets. Die Werte lauten:\n\tok         -- Korrekt aufgelöst\n\tdefined    -- Trotz \
behebbarer nicht aufgelöster Referenzen definiert\n\tnotdefined -- Aufgrund behebbarer nicht aufgelöster Referenzen nicht definiert\nDer unresolved-count-Selektortyp beschreibt die Anzahl nicht aufgelöster Referenzen. Die Werte lauten:\n\tunresolved0 -- Es sind keine nicht aufgelösten Namen vorhanden\n\tunresolved1 -- Es ist ein nicht aufgelöster Name vorhanden\n\tunresolved2 -- Es sind mindestens zwei nicht aufgelöste Namen vorhanden\nDer errors-count-Selektortyp beschreibt die Anzahl der Fehler. Die Werte lauten:\n\terror0 -- Keine Fehler\n\terror1 -- Ein Fehler\n\terror2 -- Mindestens zwei Fehler\n\nBeispiele:\n\t/set format mymode action 'Erstellt' added-primary\n\t/set format mymode action 'Update ersetzt' replaced-update\n\t/set format mymode display '{pre}{action} Klasse {name}{post}' class-ok\n\t/set format mymode display '{pre}{action} Variable {name}, auf Null zurückgesetzt{post}' replaced-vardecl,varinit-ok-update\n\nNachfolgende Selektoren für ein Feld können einige oder alle zuvor verwendeten Selektoren überschreiben - "last one wins"-Prinzip\n\nBei fehlender Angabe von <Format> werden die aktuellen Formateinstellungen angezeigt.\nBei Angabe von <Modus> werden nur die Formateinstellungen für diesen Modus angezeigt.\nBei Angabe von sowohl <Modus> als auch <Feld> werden nur die Formateinstellungen für\ndiesen Modus und dieses Feld angezeigt. Beispiel:\n\t/set format mymode\nzeigt die Formateinstellungen für den Modus "mymode" an\n

help.set.truncation.summary = Legt die maximale Länge eines angezeigten Wertes fest

help.set.truncation = Legt die maximale Länge eines angezeigten Wertes fest:\n\n\t/set truncation <Modus> <Länge> <Selektor>...\n\nAktuelle Abschneideeinstellungen anzeigen:\n\n\t/set truncation [<Modus>]\n\nHier gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus - siehe "/help /set mode".\n<Länge> ist eine Ganzzahl ohne Vorzeichen, die eine Maximallänge angibt.\n<Selektor> ist nur erforderlich, wenn Sie die Abschneidelänge des Wertes nach Kontext\noptimieren möchten. In diesem Fall ist <Selektor> der Kontext, in dem das Abschneiden angewendet wird.\nDie Struktur des Selektors besteht aus einer durch Bindestriche getrennten Liste der Selektortyplisten.\nEine Selektortypliste ist eine durch Kommas getrennte Liste der Werte eines Selektortyps.\nEin Selektor stimmt überein, wenn jede Selektortypliste übereinstimmt. Eine Selektortypliste\nstimmt überein, wenn einer der Werte übereinstimmt.\n\nNachfolgend sind die entsprechenden Selektortypen für das Abschneiden aufgelistet.\n\nDer case-Selektortyp beschreibt die Art des Snippets. Die Werte lauten:\n\tvardecl    -- Variablendeklaration ohne Initialisierung\n\tvarinit    -- Variablendeklaration mit Initialisierung\n\texpression -- Ausdruck -- Hinweis: {name}==Scratch-Variablenname\n\tvarvalue   -- Variablenwertausdruck\n\tassignment -- Variablenzuweisung\nDer action-Selektortyp beschreibt, welcher Vorgang an dem Snippet vorgenommen wurde. Die Werte lauten:\n\tadded     -- Snippet wurde hinzugefügt\n\tmodified  -- Ein vorhandenes Snippet wurde geändert\n\treplaced  -- Ein vorhandenes Snippet wurde durch ein neues Snippet ersetzt\nBeispiele:\n\t/set trunc mymode 80\n\t/set truncation mymode 45 expression\n\t/set truncation mymode 0 vardecl-modified,replaced\n\nNachfolgende Selektoren für ein Feld können einige oder alle zuvor verwendeten Selektoren überschreiben - "last one wins"-Prinzip\n\nBei fehlender Angabe von <Länge> werden die Abschneideeinstellungen angezeigt.\nBei Angabe von <Modus> werden nur die Abschneideeinstellungen für diesen Modus angezeigt.\nBeispiel:\n\t/set truncation mymode\nZeigt die Abschneideeinstellungen für den Modus "mymode" an\n

help.set.feedback.summary = Legt den Feedbackmodus mit einer Beschreibung des angezeigten Feedbacks für eingegebene Snippets und Befehle fest

help.set.feedback = Legt den Feedbackmodus mit einer Beschreibung des angezeigten Feedbacks für eingegebene Snippets und Befehle fest:\n\n\t/set feedback [-retain] <Modus>\n\nBehält den aktuellen Feedbackmodus für zukünftige Sessions bei:\n\n\t/set feedback -retain\n\nZeigt den Feedbackmodus an und listet verfügbare Modi auf:\n\n\t/set feedback\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\nSie dürfen nur gerade genügend Buchstaben verwenden, um den Namen eindeutig zu machen.\nBenutzerdefinierte Modi können hinzugefügt werden, siehe "/help /set mode"\n\nBei Verwendung der -retain-Option wird diese Einstellung in dieser und zukünftigen\nAusführungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Modus> oder -retain werden der aktuelle Feedbackmodus und verfügbare Modi angezeigt.\n

help.set.mode.summary = Erstellt einen benutzerdefinierten Feedbackmodus (optional durch Kopieren aus einem vorhandenen Modus)

help.set.mode = Erstellt einen benutzerdefinierten Feedbackmodus (optional durch Kopieren aus einem vorhandenen Modus):\n\n\t/set mode <neuer Modus> [<alter Modus>] (-command|-quiet)\n\nBehält einen benutzerdefinierten Feedbackmodus für zukünftige Sessions bei:\n\n\t/set mode -retain <Modus>\n\nLöscht einen benutzerdefinierten Feedbackmodus:\n\n\t/set mode -delete [-retain] <Modus>\n\nZeigt Feedbackmoduseinstellungen an:\n\n\t/set mode [<Modus>]\n\nDabei gilt: <neuer Modus> ist der Name des zu erstellenden Modus.\n<alter Modus> ist der Name eines vorhandenen Feedbackmodus.\n<Modus> ist der Name eines vorhandenen Feedbackmodus.\n\nBei Angabe von <alter Modus> werden die zugehörigen Einstellungen in den neuen Modus kopiert.\n\nDas Feedback, das ein Modus für eingegebene Snippets bereitstellt, wird von den "/set format"-Einstellungen\nbestimmt. Für eingegebene Befehle ist das Feedback dagegen entweder aktiviert oder deaktiviert.\nDies wird durch die beim Erstellen des Modus verwendete Option bestimmt. Es muss entweder die Option "-command"\noder die Option "-quiet" angegeben werden. Bei Verwendung von "-command" wird im neuen Modus informatives\nund bestätigendes Befehlsfeedback angezeigt. Bei Verwendung von "-quiet" wird bei Befehlen\nnur erforderliches Feedback angegeben (z.B. Fehler).\n\nNach dem Erstellen des neuen Modus können Sie diesen mit "/set format", "/set prompt und "/set truncation"\nkonfigurieren. Verwenden Sie "/set feedback", um den neuen Modus zu verwenden.\n\nBei Verwendung der Option "-retain" (ohne Option "-delete") wird der Modus (einschließlich\ndes aktuellen Prompts, Formats und der Abschneideeinstellungen) zur Verwendung in\nzukünftigen Ausführungen des JShell-Tools gespeichert. Wenn "-retain" nicht verwendet wird, wird der Modus nur in\nder aktuellen Session definiert. Verwenden Sie "-retain" nach dem Aktualisieren der Moduseinstellungen erneut,\num die Updates sessionübergreifend beizubehalten.\n\nWenn nur die Option "-delete" verwendet wird, wird der Modus aus der aktuellen Session gelöscht.\nWenn sowohl "-retain" als auch "-delete" verwendet werden, wird der Modus aus der aktuellen und aus\nzukünftigen Sessions gelöscht.\n\nBei fehlender Angabe von Optionen werden die Moduseinstellungen angezeigt.\nBei Angabe des <Modus> werden nur die Moduseinstellungen für diesen Modus angezeigt.\nHinweis: Die Einstellungen für den Modus umfassen die Einstellungen für Prompt, Format und\nAbschneiden.\nBeispiel:\n\t/set mode mymode\n\nZeigt Modus, Prompt, Format und Abschneideeinstellungen für den Modus "mymode" an

help.set.prompt.summary = Legt die Prompts fest

help.set.prompt = Legt die Prompts fest. Es müssen sowohl der normale als auch der Fortsetzungs-Prompt festgelegt werden:\n\n\t/set prompt <Modus> "<Prompt>" "<Fortsetzungs-Prompt>"\n\nZeigt den normalen und den Fortsetzungs-Prompt an:\n\n\t/set prompt [<Modus>]\n\nDabei gilt: <Modus> ist der Name eines zuvor definierten Feedbackmodus.\n<Prompt> und <Fortsetzungs-Prompt> sind in Anführungszeichen gesetzte Zeichenfolgen, die als Eingabe-Prompts ausgegeben werden.\nOptional können beide "%%s" enthalten. Dies wird durch die nächste Snippet-ID ersetzt.\nDer Eingabe wird unter Umständen keine ID zugewiesen, wenn es sich z.B. um einen Fehler oder Befehl handelt.\nDer Fortsetzungs-Prompt wird in einem mehrzeiligen Snippet in der zweiten und allen nachfolgenden Zeilen verwendet.\n\nBei fehlender Angabe von <Prompt> werden die aktuell festgelegten Prompts angezeigt.\nBei Angabe des <Modus> werden nur die Prompts für diesen Modus angezeigt.\nBeispiel:\n\t/set prompt mymode\nZeigt die für den Modus "mymode" festgelegten Prompts an\n

help.set.editor.summary =Legt den mit dem /edit-Befehl zu startenden Befehl fest

help.set.editor =Legt den mit dem /edit-Befehl zu startenden Befehl fest:\n\n\t/set editor [-retain] [-wait] <Befehl>\n\n\t/set editor [-retain] -default\n\n\t/set editor [-retain] -delete\n\nBehält die aktuelle Editoreinstellung für zukünftige Sessions bei:\n\n\t/set editor -retain\n\nZeigt den mit dem /edit-Befehl zu startenden Befehl an:\n\n\t/set editor\n\nDer <Befehl> ist eine betriebssystemabhängige Zeichenfolge.\nDer <Befehl> kann durch Leerzeichen getrennte Argumente (z.B. Kennzeichen) enthalten\n\nBei Angabe der Option -default wird der integrierte Standardeditor verwendet.\n\nBei Angabe der Option -delete werden vorherige Einstellungen ignoriert - die Editoreinstellungen\nwerden wie beim Starten des JShell-Tools initialisiert. Insbesondere wird eine eventuell vorhandene\nbeibehaltene Einstellung verwendet (es sei denn, es werden sowohl -retain als auch -delete angegeben - \nin diesem Fall wird die beibehaltene Einstellung gelöscht). Ist eine der folgenden Umgebungsvariablen festgelegt,\nwird sie verwendet: JSHELLEDITOR, VISUAL oder EDITOR (in dieser Reihenfolge). Andernfalls\nwird der integrierte Standardeditor verwendet.\n\nBei Angabe von <Befehl> wird dieser als externer Editor verwendet. Der <Befehl>\nbesteht aus dem Programm und null oder mehr Programmargumenten. Bei Verwendung von <Befehl>\nwird die zu bearbeitende temporäre Datei als letztes Argument angehängt.\nNormalerweise wird der Bearbeitungsmodus fortgesetzt, bis der externe Editor beendet wird. Einige externe Editoren\nwerden umgehend beendet (z.B. wenn das Bearbeitungsfenster vorhanden ist). Es müssen entweder Kennzeichen\nfür externe Editoren verwendet werden, um ein umgehendes Beenden zu verhindern, oder die Option -wait muss\nverwendet werden, um den Benutzer zur Angabe aufzufordern, wann der Bearbeitungsmodus beendet werden soll.\n\nHinweis: Bei aktivem Bearbeitungsmodus werden keine Befehlseingaben angezeigt. Nach Beenden des Bearbeitungsmodus\nwerden keine Änderungen an den bearbeiteten Snippets angezeigt.\n\nBei Verwendung der Option -retain wird die Einstellung in dieser und zukünftigen\nAusführungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Befehl> oder Optionen wird die Editoreinstellung angezeigt.\n

help.set.start.summary =Legt die Startkonfiguration fest

help.set.start =Legt die Startkonfiguration fest - eine Abfolge aus Snippets und Befehlen, die beim Hochfahren gelesen werden:\n\n\t/set start [-retain] <Datei>...\n\n\t/set start [-retain] -default\n\n\t/set start [-retain] -none\n\nBehält die Startkonfiguration für zukünftige Sessions bei:\n\n\t/set start -retain\n\nZeigt die Starteinstellung an:\n\n\t/set start\n\nDer Inhalt der angegebenen <Datei> wird zu den verwendeten Start-Snippets und -befehlen,\nwenn die Befehle /reset, /reload oder /env in dieser Session verwendet werden.\nWird stattdessen die Option -default angegeben, werden die vordefinierten Startimport-\nSnippets verwendet.\nBei Verwendung der Option -none sind die Starteinstellungen leer. Es werden keine\nStart-Snippets oder -befehle verwendet.\nDieser Befehl eignet sich zum Testen der Starteinstellungen. Um diese für zukünftige\nAusführungen des JShell-Tools beizubehalten, verwenden Sie den Befehl:\n\t/set start -retain\n\nBei Verwendung der Option -retain wird die Einstellung in dieser und zukünftigen\nAusführungen des JShell-Tools verwendet.\n\nBei fehlender Angabe von <Datei> oder Optionen werden die Starteinstellungen angezeigt.\nHinweis: Wenn der Start zuletzt von einer Datei festgelegt wurde, wird das mit dem\nBefehl "set start" gefolgt vom Inhalt der Datei angezeigt.\n\nDie <Datei> kann der Name einer Betriebssystemdatei oder einer der vordefinierten\nStartdateinamen sein: DEFAULT, PRINTING, TOOLING oder JAVASE.\nHierbei handelt es sich jeweils um: die Standardimport-Snippets (wie von -default verwendet),\nDefinitionen der Methoden-Snippets print(), println() und printf() oder\nImporte aller Java SE-Packages.\nEs kann mehr als eine <Datei> angegeben werden. Beispiel:\n\n\t/set start -retain DEFAULT PRINTING

help.set.indent.summary =Gibt die Anzahl der Leerzeichen zum Einrücken der Snippets an

help.set.indent =Gibt die Anzahl der Leerzeichen zum Einrücken der Snippets an:\n\n\t/set indent <Anzahl>\n\nZeigt die Einzugseinstellung an:\n\n\t/set indent\n
startup.feedback = /set mode verbose -command    \n\n/set prompt verbose '\\njshell> '   '   ...> '    \n\n/set format verbose pre '|  '    \n/set format verbose post '%n'    \n/set format verbose errorpre '|  '    \n/set format verbose errorpost '%n'    \n\n/set format verbose errorline '{post}{pre}    {err}'    \n\n/set format verbose action 'Erstellt' added-primary    \n/set format verbose action 'Geändert' modified-primary    \n/set format verbose action 'Ersetzt' replaced-primary    \n/set format verbose action 'Überschrieben' overwrote-primary    \n/set format verbose action 'Gelöscht' dropped-primary    \n/set format verbose action '  Update erstellt' added-update    \n/set format verbose action '  Update geändert' modified-update    \n/set format verbose action '  Update ersetzt' replaced-update    \n/set format verbose action '  Update überschrieben' overwrote-update    \n/set format verbose action '  Update gelöscht' dropped-update    \n\n/set format verbose until ', Instanziierung oder Aufruf der zugehörigen Methoden ist jedoch nicht möglich bis'   defined-class,record-primary    \n/set format verbose until ', Aufruf der zugehörigen Methoden ist jedoch nicht möglich bis'                      defined-interface-primary    \n/set format verbose until ', Verwendung ist jedoch nicht möglich bis'                                  defined-enum,annotation-primary    \n/set format verbose until ', Aufruf ist jedoch nicht möglich bis'                               defined-method-primary    \n/set format verbose until ', Referenzierung ist jedoch nicht möglich bis'                            notdefined-primary    \n/set format verbose until ' Instanziierung oder Aufruf der zugehörigen Methoden ist nicht möglich bis'          defined-class,record-update    \n/set format verbose until ' Aufruf der zugehörigen Methoden ist nicht möglich bis'                              defined-interface-update    \n/set format verbose until ' Aufruf ist nicht möglich bis'                                      defined-method-update    \n/set format verbose until ' Referenzierung ist nicht möglich bis'                                   notdefined-update    \n\n/set format verbose unrerr '{unresolved} ist deklariert'                                           unresolved1-error0    \n/set format verbose unrerr '{unresolved} sind deklariert'                                          unresolved2-error0    \n/set format verbose unrerr ' dieser Fehler ist behoben: {errors}'                                 unresolved0-error1    \n/set format verbose unrerr '{unresolved} ist deklariert, und dieser Fehler ist behoben: {errors}'     unresolved1-error1    \n/set format verbose unrerr '{unresolved} sind deklariert, und dieser Fehler ist behoben: {errors}'    unresolved2-error1    \n/set format verbose unrerr ' diese Fehler sind behoben: {errors}'                              unresolved0-error2    \n/set format verbose unrerr '{unresolved} ist deklariert, und diese Fehler sind behoben: {errors}'  unresolved1-error2    \n/set format verbose unrerr '{unresolved} sind deklariert, und diese Fehler sind behoben: {errors}' unresolved2-error2    \n\n/set format verbose resolve '{until}{unrerr}'                                                   defined,notdefined-added,modified,replaced,used    \n\n/set format verbose typeKind 'Klasse'                  class    \n/set format verbose typeKind 'Schnittstelle'              interface    \n/set format verbose typeKind 'Enum'                   enum    \n/set format verbose typeKind 'Annotationsschnittstelle'   annotation    \n/set format verbose typeKind 'Datensatz'                 record    \n\n/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\n/set format verbose display '{result}{pre}Scratch-Variable {name} erstellt: {type}{post}'    \
expression-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}Wert von {name}: {type}{post}'                    varvalue-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}Zugewiesen zu {name}: {type}{post}'                 assignment-primary    \n/set format verbose display '{result}{pre}{action} Variable {name}: {type}{resolve}{post}'  varinit,vardecl    \n/set format verbose display '{pre}{action} Variable {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n/set format verbose display '{pre}{action} Variable {name}{post}'                            dropped-vardecl,varinit,expression    \n/set format verbose display '{pre}{action} Variable {name}, auf Null zurückgesetzt{post}'             replaced-vardecl,varinit-ok-update    \n\n/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation,record    \n/set format verbose display '{pre}{action} Methode {name}({type}){resolve}{post}'             method    \n\n/set format verbose display '{pre}Verwendung von {typeKind} {name} wurde versucht{resolve}{post}'         used-class,interface,enum,annotation,record    \n/set format verbose display '{pre}Aufruf der Methode {name} ({type}) wurde versucht{resolve}{post}'    used-method    \n\n/set truncation verbose 80\n/set truncation verbose 1000                                                                  varvalue,expression\n\n/set mode normal -command verbose    \n/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n/set format normal display '{pre}{action} Variable {name}, auf Null zurückgesetzt{post}'             replaced-vardecl,varinit-ok-update    \n/set format normal display '{pre}{action} Variable {name}{resolve}{post}'                   replaced-vardecl,varinit-notdefined    \n/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n/set mode concise -quiet normal    \n\n/set prompt concise 'jshell> '   '   ...> '    \n\n/set format concise display ''                                                              class,interface,enum,annotation,record,method,assignment,varinit,vardecl-ok    \n\n/set feedback normal    \n\n/set mode silent -quiet    \n/set prompt silent '-> ' '>> '    \n/set truncation silent 80\n/set truncation silent 1000                                                                  varvalue,expression\n/set format silent pre '|  '    \n/set format silent post '%n'    \n/set format silent errorpre '|  '    \n/set format silent errorpost '%n'    \n/set format silent display ''    \n
