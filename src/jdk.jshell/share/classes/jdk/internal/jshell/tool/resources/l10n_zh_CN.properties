#
# Copyright (c) 2016, 2023, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

jshell.msg.welcome =欢迎使用 JShell -- 版本 {0}\n要大致了解该版本, 请键入: /help intro
jshell.err.opt.arg = 缺少 {0} 的参数。
jshell.err.opt.invalid = 无效的选项: {0}。
jshell.err.opt.one = 只能使用一个 {0} 选项。
jshell.err.opt.startup.conflict = 冲突的选项: 同时使用了 --startup 和 --no-startup。
jshell.err.opt.feedback.one = 只能使用一个反馈选项 (--feedback, -q, -s 或 -v)。
jshell.err.opt.unknown = 未知选项: {0}

jshell.msg.terminated = 状态引擎已终止。
jshell.msg.terminated.restore = 使用 /reload -restore 可还原定义

jshell.msg.use.one.of = 使用以下之一: {0}
jshell.msg.see.classes.etc = 请参阅 /types, /methods, /vars 或 /list
jshell.err.arg = 无效的 ''{0}'' 参数: {1}
jshell.msg.see = 有关帮助信息, 请参阅{0}。

jshell.err.file.not.accessible = 无法访问 ''{0}'' 的文件 ''{1}'': {2}
jshell.err.file.not.found = 找不到 ''{0}'' 的文件 ''{1}''。
jshell.err.file.exception = ''{0}'' 的文件 ''{1}'' 引发了异常错误: {2}
jshell.err.file.filename = ''{0}'' 需要文件名参数。

jshell.err.startup.unexpected.exception = 读取启动时出现意外的异常错误：{0}
jshell.err.unexpected.exception = 意外异常错误: {0}

jshell.err.invalid.command = 无效的命令: {0}
jshell.err.command.ambiguous = 命令 ''{0}'' 不明确: {1}
jshell.msg.set.restore = 正在设置新选项并还原状态。
jshell.msg.set.editor.set = 编辑器设置为: {0}
jshell.msg.set.editor.retain = 保留的编辑器设置: {0}
jshell.msg.set.indent.set = 缩进级别设置为：{0}
jshell.err.invalid.indent = 缩进级别无效：{0}
jshell.err.no.builtin.editor = 内置编辑器不可用。
jshell.err.cant.launch.editor = 无法启动内置编辑器 -- 意外的异常错误: {0}
jshell.msg.try.set.editor = 请参阅 ''/help /set editor'' 来了解如何使用外部编辑器。
jshell.msg.press.return.to.leave.edit.mode = 按“返回”退出编辑模式。
jshell.err.wait.applies.to.external.editor = -wait 适用于外部编辑器
jshell.label.editpad = JShell Edit Pad

jshell.err.setting.to.retain.must.be.specified = 必须指定要保留的设置 -- {0}
jshell.msg.set.show.mode.settings = \n要显示模式设置, 请使用 ''/set prompt'', ''/set truncation'', ...\n或者使用 ''/set mode'' 后跟反馈模式名称。
jshell.err.continuation.prompt.required = 更多提示是必填的 -- {0}

jshell.msg.try.command.without.args = 尝试使用不带参数的 ''{0}''。
jshell.msg.no.active = 没有活动定义。

jshell.msg.resetting = 正在重置...
jshell.msg.resetting.state = 正在重置状态。

jshell.err.reload.no.previous = 没有可还原的上一个历史记录
jshell.err.reload.restarting.previous.state = 正在重新启动并还原到先前的状态。
jshell.err.reload.restarting.state = 正在重新启动并还原状态。

jshell.err.restart.failed = 重新启动失败: {0}\n\n正在还原为以前的设置并重新启动...

jshell.msg.vars.not.active = (不活动)

jshell.err.out.of.range = 超出范围

jshell.msg.error = 错误:
jshell.msg.warning = 警告:

jshell.err.sub.arg = ''{0}'' 命令需要子命令。请参阅: ''/help {0}''
jshell.err.sub.ambiguous = ''{0}'' 的子命令参数不明确: {1}

jshell.err.classpath.arg = /classpath 命令要求路径参数。
jshell.msg.classpath = 路径 ''{0}'' 已添加到类路径

jshell.err.help.arg = 没有命令或主题以提供的参数开始: {0}
jshell.msg.help.begin =键入 Java 语言表达式, 语句或声明。\n或者键入以下命令之一:\n
jshell.msg.help.subject =\n有关详细信息, 请键入 ''/help'', 后跟\n命令或主题的名称。\n例如 ''/help /list'' 或 ''/help intro''。主题:\n\n

jshell.err.no.snippet.with.id = 没有片段具有 ID：{0}
jshell.err.end.snippet.range.less.than.start = 片段范围的结束值小于开始值: {0} - {1}
jshell.err.range.requires.id = 片段范围需要片段 ID：{0}

jshell.err.exit.not.expression = /exit 的参数必须是有效的整数表达式, 这不是表达式: {0}
jshell.err.exit.bad.type = /exit 的参数必须是有效的整数表达式, 类型为 {1}: {0}
jshell.err.exit.bad.value = /exit 的参数具有错误值 {1}: {0}

jshell.err.drop.arg =在 /drop 参数中，请指定要删除的导入、变量、方法或类。\n按 ID 或名称指定。使用 /list 可查看 ID。使用 /reset 可重置所有状态。
jshell.err.failed = 失败。
jshell.msg.native.method = 本机方法
jshell.msg.unknown.source = 未知源
jshell.msg.goodbye = 再见
jshell.msg.goodbye.value = 再见 ({0})

jshell.msg.help.for.help = 键入 /help 以获取帮助信息。

jshell.err.mode.name = 预期反馈模式名称: {0}
jshell.err.missing.mode = 缺少反馈模式 -- {0}
jshell.err.field.name = 预期字段名: {0} -- {1}
jshell.err.mode.unknown = 未指定反馈模式: {0} -- {1}

jshell.err.feedback.does.not.match.mode = 不匹配任何当前反馈模式: {0} -- {1}
jshell.err.feedback.ambiguous.mode = 匹配了多个当前反馈模式: {0} -- {1}
jshell.err.feedback.must.be.quoted = 格式 ''{0}'' 必须使用引号括起来 -- {1}
jshell.err.feedback.not.a.valid.selector = 不是 ''{1}'' 中有效的选择器 ''{0}'' -- {2}
jshell.err.feedback.multiple.sections = 选择器类型在 ''{1}'' 中选择器列表 ''{0}'' 的多个部分中 -- {2}
jshell.err.feedback.different.selector.kinds = 不同的选择器类型位于 ''{1}'' 中选择器列表 ''{0}'' 的相同部分中 -- {2}

jshell.msg.feedback.new.mode = 已创建新的反馈模式: {0}
jshell.msg.feedback.mode = 反馈模式: {0}
jshell.msg.feedback.mode.following = 可用的反馈模式:
jshell.msg.feedback.retained.mode.following = 保留的反馈模式:
jshell.err.mode.creation = 要创建新模式, 必须使用 -command 或 -quiet 选项 -- {0}
jshell.err.mode.exists = 要创建的模式已存在: {0} -- {1}

jshell.err.truncation.expected.length = 预期截断长度 -- {0}
jshell.err.truncation.length.not.integer = 截断长度必须为整数: {0} -- {1}

jshell.err.not.valid.with.predefined.mode = 对于预定义的模式无效: {0} -- {1}
jshell.err.retained.feedback.mode.must.be.retained.or.predefined = ''/set feedback -retain <模式>'' 要求 <模式> 为预定义模式或者已经使用 ''/set mode -retain'' 保留 -- {0}

jshell.err.unknown.option = 未知选项: {0} -- {1}
jshell.err.default.option.or.program = 指定 -default 选项, -delete 选项或程序 -- {0}
jshell.err.option.or.filename = 最多指定 -default, -none 或启动文件名中的一项 -- {0}
jshell.err.unexpected.at.end = 命令结尾处遇到意外的参数: {0} -- {1}
jshell.err.conflicting.options = 冲突的选项 -- {0}
jshell.err.cannot.delete.current.mode = 无法删除当前反馈模式 ''{0}'', 请先使用 ''/set feedback'' -- {1}
jshell.err.cannot.delete.retained.mode = 无法删除保留的反馈模式 ''{0}'', 请先使用 ''/set feedback -retain'' -- {1}
jshell.err.may.not.specify.options.and.snippets = 不能同时使用选项和片段: {0}
jshell.err.no.such.snippets = 没有此类片段: {0}
jshell.err.the.snippet.cannot.be.used.with.this.command = 此命令不接受片段 ''{0}'' : {1}
jshell.err.retained.mode.failure = 保留模式中出现故障 (已清除模式) -- {0} {1}

jshell.err.corrupted.stored.startup = 存储的启动已损坏, 正在使用默认值 -- {0}

jshell.err.exception.thrown = 异常错误 {0}
jshell.err.exception.thrown.message = 异常错误 {0}：{1}
jshell.err.exception.cause = 原因：{0}
jshell.err.exception.cause.message = 原因: {0}： {1}

jshell.console.see.synopsis = <再次按 Tab 可查看提要>
jshell.console.see.full.documentation = <再次按 Tab 可查看完整文档>
jshell.console.see.documentation = <再次按 Tab 可查看文档>
jshell.console.see.next.page = <再次按 Tab 可查看下一页>
jshell.console.see.next.javadoc = <按 Tab 可查看下一文档>
jshell.console.see.next.command.doc = <按 Tab 可查看下一命令>
jshell.console.no.such.command = 该命令不存在
jshell.console.completion.current.signatures = 签名:
jshell.console.completion.all.completions.number = <再次按 Tab 可查看所有可能的输入提示; 可能的输入提示总计: {0}>
jshell.console.completion.all.completions = <再次按 Tab 可查看所有可能的输入提示>
jshell.console.no.javadoc = <找不到文档>
jshell.console.do.nothing = 不执行任何操作
jshell.console.choice = 选项:\u0020
jshell.console.create.variable = 创建变量
jshell.console.create.method = 创建方法
jshell.console.resolvable = \n标识符可在此上下文中解析。
jshell.console.no.candidate = \n没有找到可导入的候选全限定名称。
jshell.console.incomplete = \n结果可能不完整; 请稍候重试以获取完整结果。
jshell.console.erroneous = \n不完整或错误。Shift+Tab m 前必须为单个有效的表达式或语句。
jshell.console.exprstmt = \nShift+Tab m 后必须为单个有效的表达式或语句。
jshell.console.empty = \n空条目。Shift+Tab m 前必须为单个有效的表达式或语句。

jshell.fix.wrong.shortcut =Shift+Tab 后出现意外的字符。\n使用 "i" 表示自动导入，使用 "v" 表示变量创建，使用 "i" 表示方法创建。\n有关详细信息，请参阅：\n/help 快捷方式

help.usage = 用法：   jshell <option>... <load-file>...\n其中，可能的选项包括：\n    --class-path <path>   指定用户类文件的查找位置\n    --module-path <path>  指定应用程序模块的查找位置\n    --add-modules <module>(,<module>)*\n                          指定要解析的模块；如果 <module> 为 \n                            ALL-MODULE-PATHs，则为模块路径中的所有模块\n    --enable-native-access\n                          允许代码运行受限的本机方法\n    --enable-preview      允许代码依赖于此发行版的预览功能\n    --startup <file>      对启动定义执行单次替换\n    --no-startup          不运行启动定义\n    --feedback <mode>     指定初始反馈模式。该模式可以是\n                            预定义的（silent、concise、normal 或 verbose），\n                            也可以是用户以前定义的\n    -q                    无提示反馈。等同于：--feedback concise\n    -s                    真正无提示反馈。等同于：--feedback silent\n    -v                    详细反馈。等同于：--feedback verbose\n    -J<flag>              直接将 <flag> 传递到运行时系统。\n                            为每个运行时标记或标记参数使用一个 -J\n    -R<flag>              将 <flag> 传递到远程运行时系统。\n                            为每个远程标记或标记参数使用一个 -R\n    -C<flag>              将 <flag> 传递到编译器。\n                            为每个编译器标记或标记参数使用一个 -C\n    --version             输出版本信息并退出\n    --show-version        输出版本信息并继续\n    --help, -?, -h        输出标准选项的此提要并退出\n    --help-extra, -X      输出非标准选项的帮助并退出\n\n文件参数可以是文件名，或者是预定义的文件名之一：DEFAULT、\nPRINTING、TOOLING 或 JAVASE。\n加载文件还可以是 "-"，用于指明标准输入，没有交互式 I/O。\n\n有关评估上下文选项（--class-path、--module-path \n和 --add-modules）的详细信息，请参见：\n\t/help context\n\n路径列出要搜索的目录和档案。对于 Windows，请使用\n分号 (;) 来分隔路径中的项。在其他平台上，请使用\n冒号 (:) 来分隔各项。\n
help.usage.x = \    --add-exports <模块>/<程序包>      指定要考虑从其定义模块导出\n                                         的程序包\n    --execution <规范>                 指定替代执行引擎。\n                                         其中 <规范> 是 ExecutionControl 规范。\n                                         有关规范的语法，请参阅程序包\n                                         jdk.jshell.spi 的文档\n    \n这些选项是非标准选项，如有更改，恕不另行通知。\n

help.list.summary = 列出您键入的源
help.list.args = [<名称或 id>|-all|-start]
help.list =显示前面带有其片段 ID 的片段。\n\n/list\n\t列出您键入的或使用 /open 读取的当前活动的代码片段\n\n/list -start\n\t列出评估的启动片段\n\n/list -all\n\t列出所有片段，包括失败的片段、覆盖的片段、删除的片段和启动片段\n\n/list <名称>\n\t列出具有指定名称的片段（特别是活动片段）\n\n/list <id>\n\t列出具有指定片段 ID 的片段。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'

help.edit.summary = 编辑源条目
help.edit.args = <名称或 id>
help.edit =在外部编辑器中编辑源的片段。\n使用 /set editor 可以设置要使用的编辑器。如果尚未设置编辑器，\n则将按顺序检查以下环境变量：JSHELLEDITOR、VISUAL \n和 EDITOR。如果尚未设置编辑器并且未设置任何\n编辑器环境变量，则将启动一个简单的编辑器。\n\n/edit <名称>\n\t编辑具有指定名称的片段（特别是活动片段）\n\n/edit <id>\n\t编辑具有指定片段 ID 的片段。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'\n\n/edit -start\n\t编辑启动片段。任何更改保持在此会话中，\n\t不影响启动设置\n\n/edit -all\n\t编辑所有片段，包括失败的片段、覆盖的片段、删除的片段和启动片段\n\n/edit\n\t编辑您键入或使用 /open 读取的当前活动的代码片段

help.drop.summary = 删除源条目
help.drop.args = <名称或 id>
help.drop =删除片段 -- 使片段处于不活动状态。\n\n/drop <名称>\n\t删除具有指定名称的片段\n\n/drop <id>\n\t删除具有指定片段 ID 的片段。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'

help.save.summary = 将片段源保存到文件
help.save.args = [-all|-history|-start] <文件>
help.save =将指定的片段和/或命令保存到指定文件。\n\n/save <文件>\n\t将当前活动片段的源保存到文件。\n\n/save -all <文件>\n\t将所有片段的源保存到文件。\n\t这包括覆盖的、失败的以及启动代码的源。\n\n/save -history <文件>\n\t保存自启动 jshell 工具以来输入的所有命令和片段的\n\t顺序历史记录。\n\n/save -start <文件>\n\t将当前启动定义保存到文件\n\n/save <id> <文件>\n\t保存具有指定片段 ID 的片段。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'

help.open.summary = 打开文件作为源输入
help.open.args = <file>
help.open =打开文件并读取其内容作为片段和命令。\n\n/open <file>\n\t读取指定的文件作为 jshell 工具输入。\n/open <URL>\n\t下载并使用指定的 URL 作为 jshell 工具输入。\n\n<file> 可以是操作系统文件名，也可以是预定义的\n文件名之一：DEFAULT、PRINTING、TOOLING 或 JAVASE。\n这些项的说明分别如下：默认导入片段（如 -default 所使用的），\nprint()、println() 和 printf() 方法片段的定义，运行 JDK 工具的\n方法片段的定义或所有 Java SE 程序包的导入项。\n

help.vars.summary = 列出已声明变量及其值
help.vars.args = [<名称或 id>|-all|-start]
help.vars =列出已输入变量的类型、名称和值。\n\n/vars\n\t列出当前活动变量的类型、名称和值\n\n/vars <名称>\n\t列出具有指定名称的变量（特别是活动变量）\n\n/vars <id>\n\t列出具有指定片段 ID 的变量。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'\n\n/vars -start\n\t列出已评估启动片段中的变量\n\n/vars -all\n\t列出所有变量，包括已失败变量、已覆盖变量、已删除变量和启动变量

help.methods.summary = 列出已声明方法及其签名
help.methods.args = [<名称或 id>|-all|-start]
help.methods =列出已输入方法的名称、参数类型和返回类型。\n\n/methods\n\t列出当前活动方法的名称、参数类型和返回类型\n\n/methods <名称>\n\t列出具有指定名称的方法（特别是活动方法）\n\n/methods <id>\n\t列出具有指定片段 ID 的方法。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'\n\n/methods -start\n\t列出已评估启动片段中的方法\n\n/methods -all\n\t列出所有片段，包括失败的片段、覆盖的片段、删除的片段和启动片段

help.types.summary = 列出类型声明
help.types.args =[<名称或 id>|-all|-start]
help.types =列出已输入的类和接口。\n\n/types\n\t列出当前活动的类型声明\n\n/types <名称>\n\t列出具有指定名称的类型声明（特别是活动片段）\n\n/types <id>\n\t列出具有指定片段 ID 的类型声明。\n\t可以使用一个或多个 ID 或 ID 范围，参见 '/help id'\n\n/types -start\n\t列出已评估启动片段中的类型声明\n\n/types -all\n\t列出所有类型声明，包括已失败类型声明、已覆盖类型声明、已删除类型声明和启动类型声明

help.imports.summary = 列出导入的项
help.imports.args =
help.imports =列出当前活动的导入。这包括来自启动片段的\n导入。

help.exit.summary = 退出 jshell 工具
help.exit.args =[<integer-expression-snippet>]
help.exit =退出 jshell 工具。不保存工作。\n在使用此命令前应该先保存任何工作\n\n/exit\n\t退出 jshell 工具。退出状态为零\n\n/exit <整数表达式片段>\n\t评估片段。如果片段失败或者不是整数表达式，\n\t则显示错误。否则退出 jshell 工具，并将\n\t表达式的值作为退出状态

help.reset.summary = 重置 jshell 工具
help.reset.args = [-class-path <路径>] [-module-path <路径>] [-add-modules <模块>]...
help.reset =重置 jshell 工具代码和执行状态：\n\t* 所有输入的代码丢失\n\t* 重新启动执行状态\n\t* 重新执行启动代码\n在使用此命令前应该先保存任何工作。\n/reset 命令接受评估上下文选项，参见：\n\n\t/help context\n

help.reload.summary = 重置和重放相关历史记录 -- 当前历史记录或上一个历史记录 (-restore)
help.reload.args = [-restore] [-quiet] [-class-path <路径>] [-module-path <路径>]...
help.reload =重置 jshell 工具代码和执行状态，然后按照各有效片段和\n任何 /drop 命令的输入顺序重放它们。\n\n/reload\n\t重置和重放自进入 jshell 工具以来的有效历史记录，\n\t或者执行 /reset 或 /reload 命令中最新的那个\n\t命令\n\n/reload -restore\n\t重置并重放上一次进入 jshell 工具与最近进入 jshell\n\t工具之间的有效历史记录，或者执行 /reset、/reload\n\t或 /env 命令。这进而可用于还原上一个\n\tjshell 工具会话\n\n/reload [-restore] -quiet\n\t使用 '-quiet' 参数时，不显示重放，但将显示\n\t所有错误\n\n上面每个命令都接受评估上下文选项，请参见：\n\n\t/help context\n\n例如：\n\n\t/reload -add-modules com.greetings -restore

help.env.summary = 查看或更改评估上下文
help.env.args = [-class-path <路径>] [-module-path <路径>] [-add-modules <模块>] ...
help.env =查看或更改评估上下文。评估上下文是类路径，\n模块路径等等。\n\n/env\n\t显示作为上下文选项显示的评估上下文\n\n/env [-class-path <路径>] [-module-path <路径>] [-add-modules <模块>] ...\n\t在至少设置一个选项的情况下，设置评估上下文。如果\n\t已定义片段，则将使用新评估上下文重置\n\t执行状态，并且将重放片段 -- 不显示\n\t重放，但是将显示所有错误。这等同于：\n\n\t\t/reload -quiet ...\n\n\t有关评估上下文选项的详细信息，请参见：\n\n\t/help context\n\n例如：\n\n\t/env -add-modules com.greetings

help.history.summary = 您键入的内容的历史记录
help.history.args = [-all]
help.history =显示输入的片段和命令的历史记录。\n\n/history\n\t列出自启动此 jshell 工具以来输入的片段和命令的历史记录\n\n/history -all\n\t列出此会话和以前会话中输入的片段和命令的历史记录

help.debug.summary = 切换 jshell 工具的调试
help.debug.args = [0][r][g][f][c][d][e]
help.debug =显示 jshell 工具实现的调试信息\n0：禁用调试\nr：启用工具级别调试\ng：启用常规调试\nf：启用文件管理器调试\nc：启用输入提示分析调试\nd：启用被依赖对象调试\ne：启用事件调试

help.help.summary = 获取有关使用 jshell 工具的信息
help.help.args = [<command>|<subject>]
help.help =显示有关使用 jshell 工具的信息。\n/help\n\t列出 jshell 工具命令和帮助主题\n\n/help <command>\n\t显示有关指定命令的信息。\n\t只需输入命令的前几个字母 -- 如果有多个匹配项，\n\t则将显示项。示例：/help /li\n\n/help <subject>\n\t显示有关指定帮助主题的信息。示例：/help intro

help.set.summary = 设置配置信息
help.set.args = editor|start|feedback|mode|prompt|truncation|format ...
help.set =设置 jshell 工具配置信息，包括：\n要使用的外部编辑器、要使用的启动定义、新的反馈模式、\n命令提示符、要使用的反馈模式或输出的格式。\n\n/set editor [-wait] <命令> <可选参数>...\n\t指定要为 /edit 命令启动的命令。\n\t<命令> 是与操作系统相关的字符串\n\n/set start <文件>\n\t指定 <文件> 的内容将成为默认启动片段和命令\n\n/set feedback <模式>\n\t设置用于描述为所输入片段和命令显示的反馈的反馈模式\n\n/set mode <模式> [<旧模式>] -command|-quiet|-delete\n\t创建或更新用户定义的反馈模式，可以选择从现有模式复制\n\n/set prompt <模式> "<提示>" "<更多提示>"\n\t设置为给定反馈模式显示的提示符\n\n/set truncation <模式> <长度> <选择器>...\n\t设置显示值的最大长度\n\n/set format <模式> <字段> "<格式>" <选择器>...\n\t通过设置当选择器匹配时字段的格式来配置反馈模式\n\n/set indent <数字>\n\t设置应用于自动缩进片段的空格数\n\n/set\n\t以 /set 命令形式显示编辑器、启动和反馈设置。\n\t要显示以上任意项的设置，请忽略 set 值\n\n要获取有关其中一个格式的详细信息，请对指定的格式使用 /help。\n例如：   /help /set format

help.quest.summary = 获取有关使用 jshell 工具的信息
help.quest.args = [<command>|<subject>]
help.quest =显示有关使用 jshell 工具的信息（/help 的缩写形式）。\n/?\n\t显示命令和帮助主题的列表\n/? <command>\n\t显示有关指定命令的信息。\n\t只需输入命令的前几个字母 -- 如果有多个\n\t匹配项，则将显示所有项。示例：/? /li\n/? <subject>\n\t显示有关指定帮助主题的信息。示例：/? intro

help.bang.summary = 重新运行上一个片段 -- 请参阅 /help rerun
help.bang.args =
help.bang =重新评估最近输入的片段。

help.slashID.summary = 按 ID 或 ID 范围重新运行片段 -- 参见 /help rerun
help.slashID.args =
help.slashID =/<id> <id> <id>\n\n/<id>-<id>\n\n重新评估按 ID 或 ID 范围指定的片段。\nID 范围使用通过连字符分隔的两个 ID 表示，例如：3-17\n可以使用启动和错误片段，例如：s3-s9 或 e1-e4\n可以使用任意数量的 ID 或 ID 范围，例如：/3-7 s4 14-16 e2\n参见 '/help id'。

help.previous.summary = 重新运行以前的第 n 个片段 -- 请参阅 /help rerun
help.previous.args =
help.previous =重新评估最近输入的第 n 个片段。

help.intro.summary = jshell 工具的简介
help.intro =使用 jshell 工具可以执行 Java 代码，从而立即获取结果。\n您可以输入 Java 定义（变量、方法、类等等），例如：int x = 8\n或 Java 表达式，例如：x + x\n或 Java 语句或导入。\n这些小块的 Java 代码称为“片段”。\n\n这些 jshell 工具命令还可以让您了解和\n控制您正在执行的操作，例如：/list\n\n有关命令的列表，请执行：/help

help.keys.summary = 类似 readline 的输入编辑的说明
help.keys =jshell 工具提供行编辑支持，允许您在片段和命令中\n导航并进行编辑。您可以编辑当前命令/片段，也可以\n从历史记录中检索以前的命令/片段，进行编辑并执行。\n此支持类似于 readline/editline，具有与 emacs 相似的\n简单绑定。还有特定于 jshell 工具的关键字序列。\n\n行和历史记录导航：\n\n\tReturn\n\t\t输入当前片段\n\t左箭头或 Ctrl+B\n\t\t向后移动一个字符\n\t右箭头或 Ctrl+F\n\t\t向前移动一个字符\n\t上箭头或 Ctrl+P\n\t\t向上移动一行，向后浏览历史记录\n\t下箭头或 Ctrl+N\n\t\t向下移动一行，向前浏览历史记录\n\tCtrl+A\n\t\t移至行的开头\n\tCtrl+E\n\t\t移至行的结尾\n\tMeta+B\n\t\t向后移动一个单词\n\tMeta+F\n\t\t向前移动一个单词\n\tCtrl+R\n\t\t向后搜索历史记录\n\n\n行和历史记录基本编辑：\n\n\tMeta+Return 或 Ctrl+Return（根据平台）\n\t\t在片段中插入新行\n\tCtrl+_（下划线可能需要 Shift 键）或 Ctrl+X 然后 Ctrl+U\n\t\t撤消编辑 - 重复操作可撤消多项编辑\n\tDelete\n\t\t删除光标处或其后面的字符，具体取决于操作系统\n\tBackspace\n\t\t删除光标前面的字符\n\tCtrl+K\n\t\t删除从光标到行结尾的文本\n\tMeta+D\n\t\t删除从光标到单词结尾的文本\n\tCtrl+W\n\t\t删除从光标到前一个空格的文本\n\tCtrl+Y\n\t\t将最近删除的文本粘贴到行中\n\tMeta+Y\n\t\t在按 Ctrl+Y 之后，按 Meta+Y 可循环浏览先前删除的文本\n\tCtrl+X 然后 Ctrl+K\n\t\t删除整个片段\n\n\njshell 工具的快捷方式：\n\n\t有关详细信息，请参阅：/help 快捷方式\n\n\tTab\n\t\t完成 Java 标识符或 jshell 命令\n\tShift+Tab 然后 v\n\t\t将表达式转换为变量声明\n\tShift+Tab 然后 m\n\t\t将语句转换为方法声明\n\tShift+Tab 然后 i\n\t\t为此标识符添加导入\n\t\n\n多行和历史记录编辑：\n\n\tCtrl+L\n\t\t清除屏幕并重新输出片段\n\tCtrl+U\n\t\t终止整行\n\tCtrl+T\n\t\t转置字符\n\tCtrl+X 然后 Ctrl+B\n\t\t导航到匹配的方括号、括号 ...\n\tCtrl+X 然后 =\n\t\t进入显示当前字符位置的模式\n\tCtrl+X 然后 \
Ctrl+O\n\t\t在覆盖字符与插入字符之间切换\n\tMeta+C\n\t\t单词首字母大写\n\tMeta+U\n\t\t将单词转换为大写\n\tMeta+L\n\t\t将单词转换为小写\n\tMeta+0 至 Meta+9 然后键\n\t\t重复指定次数\n\n例如 "Ctrl+A" 表示按住 Ctrl 键并按 A。\n其中 "Meta" 在许多键盘上是 "Alt"。\n行编辑支持源自 JLine 3。

help.shortcuts.summary = 片段和命令输入提示, 信息访问以及\n自动代码生成的按键说明
help.shortcuts =支持的快捷方式包括：\n\n\tTab\n\t\t在输入 Java 标识符、jshell 工具命令或\n\t\t在某些情况下输入 jshell 工具命令参数的\n\t\t前几个字母后，按 Tab 键可以完成输入。\n\t\t如果有多个输入提示，将显示可能的输入提示。\n\t\t再按一次 Tab 将显示可用的适用文档。\n\n\tShift+Tab 然后 v\n\t\t在完整的表达式后面，按住 Tab 键的同时\n\t\t按下 Shift 键，然后释放并按 "v" 键，表达式\n\t\t将转换为类型基于表达式类型的变量声明。\n\n\tShift+Tab 然后 m\n\t\t完成表达式或语句之后，按住 Tab 键的同时\n\t\t按下 Shift 键，然后释放并按住 "m" 键，表达式或\n\t\t语句将转换为方法声明。如果是表达式，\n\t\t则方法返回类型基于表达式的类型。\n\n\tShift+Tab 然后 i\n\t\t在不可解析的标识符后面，按住 Tab 键的同时\n\t\t按下 Shift 键，然后释放并按 "i" 键，jshell 工具会\n\t\t推荐可能的导入项，以基于指定类路径的内容解析标识符。\n\t\t输入与所需导入对应的数字，或按 "0" 键不添加导入项。\n\n有关特殊键的信息，请参阅：/help 键

help.context.summary = /env /reload 和 /reset 的评估上下文选项的说明
help.context =这些选项用于配置评估上下文。它们可以在启动 jshell 工具时\n在命令行上指定，或者在使用命令 /env、/reload 或 /reset \n重新启动 jshell 工具时作为命令选项指定。\n\n它们是：\n\t--class-path <路径>\n\t\t<路径> 是用于搜索类文件的目录、\n\t\tJAR 档案和 ZIP 档案的列表。\n\t\t对于 Windows，使用分号 (;) 分隔路径中的项。\n\t\t在其他平台上，使用冒号 (:) 分隔各项。\n\t--module-path <路径>...\n\t\t<路径> 是用于搜索模块的目录、\n\t\tJAR 档案和 ZIP 档案的列表。\n\t\t对于 Windows，使用分号 (;) 分隔路径中的项。\n\t\t在其他平台上，使用冒号 (:) 分隔各项。\n\t--add-modules <模块名称>[,<模块名称>...]\n\t\t除了初始模块之外要解析的根模块。\n\t\t<模块名称> 还可以是 ALL-DEFAULT、ALL-SYSTEM、\n\t\tALL-MODULE-PATH。\n\t--add-exports <模块>/<程序包>=<目标模块>(,<目标模块>)*\n\t\t更新 <模块> 以将 <程序包> 导出到 <目标模块>，\n\t\t而无论模块声明如何。\n\t\t<目标模块> 可以是 ALL-UNNAMED 以导出到全部\n\t\t未命名模块。在 jshell 中，如果未指定 \n\t\t<目标模块> (no =)，则使用 ALL-UNNAMED。\n\n除非输入的选项覆盖了设置，否则在命令行上输入的\n或者使用以前的 /reset、/env 或 /reload 命令提供的\n评估上下文选项将会保留。\n\n在命令行上，这些选项必须具有两个短划线，例如：--module-path\n在 jshell 工具命令上，它们必须具有一个或两个短划线，例如：-module-path

help.id.summary = 片段 ID 以及如何使用它们的说明
help.id =输入的每个代码片段有自己的唯一片段 ID。即使再次\n输入相同的片段，它都会具有新 ID。对于普通片段，ID\n是一个增长的编号。对于失败且出错的片段，其片段 ID\n以 "e" 开头。对于启动中的片段，其 ID 以 "s" 开头。\n\n片段 ID 是在命令中引用片段的一种方法。例如，\n此命令删除 ID 为 '14' 的片段：\n\n\t/drop 14\n\n要查看一个或多个片段的 ID，请使用 '/list' 命令。要查看所有\n片段的 ID，包括失败片段、启动片段和覆盖片段，请使用\n'/list -all' 命令。\n\n您还可以使用连字符分隔开始 ID 和结束 ID，\n以此来引用 ID 范围。例如，'1-4' 与 '1 2 3 4' 相同。\n引用片段的所有命令将获取 ID、ID 范围以及片段名称的\n列表作为参数。这些命令包括：/list、/edit、/drop、/save、/vars、/methods、\n/types 和 /<id>。一些示例：\n\n\t/edit 7-23\n\n\t/save s1-s4 3-8 foo 12 myfile\n\n\t/9-12 33\n\n分别参见 '/help /edit'、'/help /save' 和 '/help rerun'。

help.rerun.summary = 重新评估以前输入片段的方法的说明
help.rerun =重新评估以前输入的片段有四种方法。\n可使用以下方法重新评估上一个片段：/!\n可以使用斜杠加减号加数字 n 的方式来重新评估之前的第 n 个片段，例如：/-4\n例如：\n\n\tjshell> 2 + 2\n\t$1 ==> 4\n\n\tjshell> /!\n\t2 + 2\n\t$2 ==> 4\n\n\tjshell> int z\n\tz ==> 0\n\n\tjshell> /-1\n\tint z;\n\tz ==> 0\n\n\tjshell> /-4\n\t2 + 2\n\t$5 ==> 4\n\n可以使用片段 ID 或 ID 范围指定要重新评估的片段。\nID 范围使用连字符分隔的两个 ID 表示，例如：3-17\n可以使用启动和错误片段，例如：s3-s9 或 e1-e4\n可以使用任意数量的 ID 或 ID 范围，例如：/3-7 s4 14-16 e2\n另请参见 '/help id'。\n\n最后，可以通过输入 Ctrl+R 后跟要搜索的字符串，在历史记录中向后搜索。

help.set._retain = '-retain' 选项保存设置以便在将来会话中使用。\n可以在 /set 的以下格式中使用 -retain 选项:\n\n\t/set editor -retain\n\t/set start -retain\n\t/set feedback -retain\n\t/set mode -retain\n\n有关详细信息, 请参阅这些命令 -- 例如, /help /set editor

help.set.format.summary = 设置用于报告片段事件的格式

help.set.format = 设置用于报告片段事件的格式：\n\n\t/set format <模式> <字段> "<格式>" <选择器>...\n\n显示格式设置:\n\n\t/set format [<模式> [<字段>]]\n\n其中 <模式> 是以前定义的反馈模式的名称 -- 请参阅 '/help /set mode'。\n其中 <字段> 是要定义的上下文特定格式的名称。\n其中 <格式> 是一个带引号的字符串, 该字符串将为\n字段的值 (如果选择器匹配, 或者没有任何选择器)。\n在使用格式时, 用大括号括起的字段名将会在相应时间\n使用字段值替换。这些字段可能已使用此命令定义, \n也可能是特定于上下文的以下预定义字段之一:\n\t{name}       == 名称, 例如: 变量的名称, ...\n\t{type}       == 类型名称。变量或表达式的类型,\n\t\t\t方法的参数类型\n\t{value}      == 表达式或变量初始化的结果值\n\t{unresolved} == 未解析引用的列表\n\t{errors}     == 可恢复错误的列表 (只在处理\n\t\t\t"display" 字段期间)\n\t{err}        == 无格式的错误行 (只在处理\n\t\t\t"errorline" 字段期间)\n该工具访问以下字段来确定所显示的反馈:\n\t{display}    == 为片段事件显示的消息\n\t{errorline}  == "errors" 字段中的一个错误行的格式\n\t{pre}        == 反馈前缀 (作为命令反馈的开头)\n\t{post}       == 反馈后缀 (作为命令反馈的结尾)\n\t{errorpre}   == 错误前缀 (作为错误反馈的开头)\n\t{errorpost}  == 错误后缀 (作为错误反馈的结尾)\n这些字段具有默认设置 (可覆盖)。\n其中 <selector> 是应用格式的上下文。\n选择器结构是一个由选择器类型列表构成的列表, 使用连字符分隔。\n选择器类型列表是单个选择器类型的值的列表, 使用逗号分隔。\n如果每个选择器类型列表匹配, 则选择器匹配; 如果其中某个值\n匹配, 则选择器类型列表匹配。\n\ncase 选择器类型描述了片段的类型。值包括:\n\timport     -- 导入声明\n\tclass      -- 类声明\n\tinterface  -- 接口声明\n\tenum       -- 枚举声明\n\tannotation -- 批注接口声明\n\trecord     -- 记录声明\n\tmethod     -- 方法声明 -- 注: {type}==parameter-types\n\tvardecl    -- 不带初始化的变量声明\n\tvardecl    -- 带初始化的变量声明\n\texpression -- 表达式 -- \
注: {name}==scratch-variable-name\n\tvarvalue   -- 变量值表达式\n\tassignment -- 分配变量\n\tstatement  -- 语句\n操作选择器类型描述了对片段执行的操作。值包括:\n\tadded     -- 片段已添加\n\tmodified  -- 现有片段已修改\n\treplaced  -- 现有片段已替换为新片段\n\toverwrote -- 现有片段已覆盖\n\tdropped   -- 片段已删除\n\tused      -- 片段在不能使用的时候已被使用\nwhen-did-it-occur 选择器类型描述了这是直接操作还是间接操作。值包括:\n\tprimary -- 输入的片段\n\tupdate  -- 对相关片段的更新\nresolution-state 选择器类型描述了片段的解析/定义状态。值包括:\n\tok         -- 已正确解析\n\tdefined    -- 已定义, 但存在可恢复的未解析引用\n\tnotdefined -- 由于存在可恢复的未解析引用而未定义\nunresolved-count 选择器类型描述了未解析引用的数量。值包括:\n\tunresolved0 -- 不存在未解析的名称\n\tunresolved1 -- 一个名称未解析\n\tunresolved2 -- 两个或更多名称未解析\nerrors-count 选择器类型描述了错误的数量。值包括:\n\terror0 -- 无错误\n\terror1 -- 一个错误\n\terror2 -- 两个或更多错误\n\n示例:\n\t/set format mymode action '已创建' added-primary\n\t/set format mymode action '更新已替换' replaced-update\n\t/set format mymode display '{pre}{action} 类 {name}{post}' class-ok\n\t/set format mymode display '{pre}{action} 变量 {name}, 重置为空值{post}' replaced-vardecl,varinit-ok-update\n\n请注意, 某个字段的后续选择器可能会覆盖部分或全部以前使用的选择器 -- 采用最后一个选择器\n\n不带 <格式> 的格式显示当前格式设置。\n指定 <模式> 时, 将仅显示该模式的格式设置。\n同时指定 <模式> 和 <字段> 时, 将仅显示该模式和字段的\n格式设置。示例:\n\t/set format mymode\n显示模式 mymode 的格式设置\n

help.set.truncation.summary = 设置显示值的最大长度

help.set.truncation = 设置显示值的最大长度:\n\n\t/set truncation <模式> <长度> <选择器>...\n\n显示当前截断设置:\n\n\t/set truncation [<模式>]\n\n其中 <模式> 是以前定义的反馈模式名称 -- 请参阅 '/help /set mode'。\n而 <长度> 是无符号整数, 表示最大长度。\n<选择器> 只有在您希望根据上下文微调值截断长度时才需要,\n<选择器> 是在其中应用截断的上下文。\n选择器结构是一个连字符分隔的选择器类型列表。\n选择器类型列表是一个包含某种选择器类型的值的逗号分隔列表。\n选择器在所有选择器类型列表匹配时匹配; 选择器类型列表\n则在其中一个值匹配时匹配。\n\n下面是用于截断的相关选择器类型。\n\ncase 选择器类型描述了片段的类型。值包括:\n\tvardecl    -- 不带初始化的变量声明\n\tvarinit    -- 带初始化的变量声明\n\texpression -- 表达式 -- 注: {name}==暂存变量名称\n\tvarvalue   -- 变量值表达式\n\tassignment -- 分配变量\n\t操作选择器类型描述了对片段执行的操作。值包括:\n\tadded     -- 片段已添加\n\tmodified  -- 现有片段已修改\n\treplaced  -- 现有片段已替换为新片段\n示例:\n\t/set trunc mymode 80\n\t/set truncation mymode 45 expression\n\t/set truncation mymode 0 vardecl-modified,replaced\n\n请注意, 某个字段的后续选择器可能会覆盖部分或全部以前使用的选择器 -- 采用最后一个选择器\n\n不带 <长度> 的格式显示截断设置。\n指定 <模式> 时, 将仅显示该模式的截断设置。\n示例:\n\t/set truncation mymode\n显示模式 mymode 的截断设置\n

help.set.feedback.summary = 设置用于描述为所输入片段和命令显示的反馈的反馈模式

help.set.feedback = 设置反馈模式, 该模式描述为所输入的片段和命令显示的反馈:\n\n\t/set feedback [-retain] <模式>\n\n保留当前反馈模式以便在将来会话中使用:\n\n\t/set feedback -retain\n\n显示反馈模式并列出可用模式:\n\n\t/set feedback\n\n其中 <模式> 是以前定义的反馈模式名称。\n您可以使用足够多的字母来提供唯一的名称。\n可以添加用户定义的模式, 具体请参阅 '/help /set mode'\n\n使用 -retain 选项时, 将在本次运行和将来运行 jshell 工具时\n使用此设置。\n\n不带 <模式> 的格式或 -retain 显示当前反馈模式和可用模式。\n

help.set.mode.summary = 创建用户定义的反馈模式, 可以选择从现有模式复制

help.set.mode = 创建用户定义的反馈模式, 也可以选择从现有模式复制:\n\n\t/set mode <新模式> [<旧模式>] (-command|-quiet)\n\n保留用户定义的反馈模式以便在将来会话中使用:\n\n\t/set mode -retain <模式>\n\n删除用户定义的反馈模式:\n\n\t/set mode -delete [-retain] <模式>\n\n显示反馈模式设置:\n\n\t/set mode [<模式>]\n\n其中 <新模式> 是您希望创建的模式的名称。\n其中 <旧模式> 是现有反馈模式的名称。\n其中 <模式> 是现有反馈模式的名称。\n\n如果存在 <旧模式>, 其设置将会复制到新模式。\n\n模式为所输入片段提供的反馈由 '/set format' 设置确定。\n不过, 对于输入的命令, 反馈的启用或禁用是根据创建模式时\n使用的选项确定的。必须指定选项 '-command' 或\n选项 '-quiet'。如果使用 '-command', 则在新模式\n下时会显示信息性和验证命令反馈。如果使用 '-quiet',\n则命令只提供基本反馈 (例如, 错误)。\n\n一旦创建新模式, 即可使用 '/set format', '/set prompt' 和 '/set truncation'\n进行配置。使用 '/set feedback' 可使用新模式。\n\n使用 -retain 选项 (不带 '-delete' 选项) 时, 将存储\n模式 (包括其当前提示, 格式和截断设置) 以便在将来运行\njshell 工具时使用。如果不使用 retain, 则仅在当前会话\n中定义模式。在更新模式的设置之后, 再次保留模式以便在\n各个会话之间保留更新。\n\n仅使用 '-delete' 选项时, 将从当前会话中删除模式。\n同时使用 '-retain' 和 '-delete' 时, 将从当前会话和\n将来会话中删除模式。\n\n使用不带选项的格式时, 将显示模式设置。\n指定 <模式> 时, 将仅显示该模式的模式设置。\n注: 模式设置包括提示, 格式和截断的\n设置。\n示例:\n\t/set mode mymode\n\n显示模式 mymode 的模式, 提示, 格式和截断设置

help.set.prompt.summary = 设置提示

help.set.prompt = 设置提示。必须同时设置正常提示和更多提示：\n\n\t/set prompt <模式> "<提示>" "<更多提示>"\n\n显示正常提示和更多提示：\n\n\t/set prompt [<模式>]\n\n其中 <模式> 是以前定义的反馈模式名称。\n而 <提示> 和 <更多提示> 是作为输入提示输出的带引号的字符串；\n它们均可选择性地包含 '%%s'，该变量将被替换为下一个片段 ID --\n请注意，可能无法向所输入内容分配该 ID，例如这可能是一个错误或命令。\n更多提示在多行片段的第二行以及后续行上使用。\n\n不带 <提示> 的格式显示当前设置的提示。\n指定 <模式> 时，将仅显示该模式的提示。\n示例：\n\t/set prompt mymode\n显示为模式 mymode 设置的提示\n

help.set.editor.summary =指定要为 /edit 命令启动的命令

help.set.editor =指定要为 /edit 命令启动的命令:\n\n\t/set editor [-retain] [-wait] <命令>\n\n\t/set editor [-retain] -default\n\n\t/set editor [-retain] -delete\n\n保留当前编辑器设置以便在将来会话中使用:\n\n\t/set editor -retain\n\n显示要为 /edit 命令启动的命令:\n\n\t/set editor\n\n<命令> 是与操作系统相关的字符串。\n<命令> 可以包含用空格分隔的参数 (例如标记)\n\n如果指定了 -default 选项, 将使用内置默认编辑器。\n\n如果指定了 -delete 选项, 将忽略以前的设置 -- 启动\njshell 工具时将初始化编辑器设置。具体来说, 如果存在\n保留的设置, 将使用保留的设置 (除非同时指定 -retain 和 -delete --\n这将删除保留的设置), 如果设置了以下某个环境变量, \n将使用它: JSHELLEDITOR, VISUAL 或 EDITOR (按此顺序)。否则将使用\n内置默认编辑器。\n\n如果指定了 <命令>, 它将用作外部编辑器。<命令>\n由程序及零个或多个程序参数组成。使用 <命令>\n时, 要编辑的临时文件将作为最后一个参数附加。\n通常, 编辑模式将持续到退出外部编辑器为止。某些外部编辑器\n将立即退出 (例如, 如果退出编辑窗口), 应使用外部编辑器\n标记阻止立即退出, 或者使用 -wait 选项\n提示用户指示何时应结束编辑模式。\n\n注: 在编辑模式下, 不会显示任何命令输入。退出编辑模式后, \n将不会显示对编辑的片段所做的任何更改。\n\n使用 -retain 选项时, 将在本次运行和将来运行 jshell 工具时\n使用该设置。\n\n不带 <命令> 或选项的格式显示编辑器设置。\n

help.set.start.summary =设置启动配置

help.set.start =设置启动配置 -- 启动时读取的片段和命令序列：\n\n\t/set start [-retain] <file>...\n\n\t/set start [-retain] -default\n\n\t/set start [-retain] -none\n\n保留启动配置以便在将来会话中使用：\n\n\t/set start -retain\n\n显示启动设置：\n\n\t/set start\n\n在此会话中使用 /reset、/reload 或 /env 命令时，\n指定 <file> 的内容将成为使用的启动片段和命令。\n如果改为指定 -default 选项，则将使用预定义的\n启动导入片段。\n如果使用 -none 选项，则启动设置将为空 -- 将不使用\n启动片段或命令\n此命令对于测试启动设置非常有用。要保留这些内容\n以便将来运行 jshell 工具时使用，请使用命令：\n\t/set start -retain\n\n使用 -retain 选项时，将在本次运行和将来\n运行 jshell 工具时使用该设置。\n\n不带 <file> 或选项的格式显示启动设置。\n注：如果上次是从文件设置的启动配置，则会随\n'set start' 命令显示此内容（命令后跟文件内容）。\n\n<file> 可以是操作系统文件名，也可是预定义的\n启动文件名之一：DEFAULT、PRINTING、TOOLING 或 JAVASE。\n这些项的说明分别如下：默认导入片段（如 -default 所使用的）、\nprint()、println() 和 printf() 方法片段的定义，或\n所有 Java SE 程序包的导入项。\n可以指定多个 <file>，例如：\n\n\t/set start -retain DEFAULT PRINTING

help.set.indent.summary =指定应用于缩进片段的空格数

help.set.indent =指定应用于缩进片段的空格数：\n\n\t/set indent <number>\n\n显示缩进设置：\n\n\t/set indent\n
startup.feedback = /set mode verbose -command    \n\n/set prompt verbose '\\njshell> '   '   ...> '    \n\n/set format verbose pre '|  '    \n/set format verbose post '%n'    \n/set format verbose errorpre '|  '    \n/set format verbose errorpost '%n'    \n\n/set format verbose errorline '{post}{pre}    {err}'    \n\n/set format verbose action '已创建' added-primary    \n/set format verbose action '已修改' modified-primary    \n/set format verbose action '已替换' replaced-primary    \n/set format verbose action '已覆盖' overwrote-primary    \n/set format verbose action '已删除' dropped-primary    \n/set format verbose action '  更新已创建' added-update    \n/set format verbose action '  更新已修改' modified-update    \n/set format verbose action '  更新已替换' replaced-update    \n/set format verbose action '  更新已覆盖' overwrote-update    \n/set format verbose action '  更新已删除' dropped-update    \n\n/set format verbose until '，不过，它无法实例化或者其方法无法调用，直至'   defined-class,record-primary    \n/set format verbose until ', 不过, 其方法无法调用, 直至'                      defined-interface-primary    \n/set format verbose until ', 不过, 它无法使用, 直至'                                  defined-enum,annotation-primary    \n/set format verbose until ', 不过, 它无法调用, 直至'                               defined-method-primary    \n/set format verbose until ', 不过, 它无法引用, 直至'                            notdefined-primary    \n/set format verbose until '它无法实例化或者其方法无法调用，直至'          defined-class,record-update    \n/set format verbose until ' 其方法无法调用, 直至'                              defined-interface-update    \n/set format verbose until ' 它无法调用, 直至'                                      defined-method-update    \n/set format verbose until ' 它无法引用, 直至'                                   notdefined-update    \n\n/set format verbose unrerr '{unresolved} 已声明'                                           unresolved1-error0    \n/set format verbose unrerr '{unresolved} 已声明'                                          unresolved2-error0    \n/set format verbose unrerr ' 此错误已更正: {errors}'                                 unresolved0-error1    \n/set format verbose unrerr '{unresolved} 已声明, 并且此错误已更正: {errors}'     unresolved1-error1    \n/set format verbose unrerr '{unresolved} 已声明, 并且此错误已更正: {errors}'    unresolved2-error1    \n/set format verbose unrerr ' 这些错误已更正: {errors}'                              unresolved0-error2    \n/set format verbose unrerr '{unresolved} 已声明并且这些错误已更正: {errors}'  unresolved1-error2    \n/set format verbose unrerr '{unresolved} 已声明并且这些错误已更正: {errors}' unresolved2-error2    \n\n/set format verbose resolve '{until}{unrerr}'                                                   defined,notdefined-added,modified,replaced,used    \n\n/set format verbose typeKind '类'                  class    \n/set format verbose typeKind '接口'              interface    \n/set format verbose typeKind '枚举'                   enum    \n/set format verbose typeKind \
'批注接口'   annotation    \n/set format verbose typeKind '记录'                 record    \n\n/set format verbose result '{name} ==> {value}{post}'                                        added,modified,replaced-ok-primary    \n\n/set format verbose display '{result}{pre}已创建暂存变量 {name} : {type}{post}'    expression-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}{name} 的值: {type}{post}'                    varvalue-added,modified,replaced-primary    \n/set format verbose display '{result}{pre}已分配给 {name} : {type}{post}'                 assignment-primary    \n/set format verbose display '{result}{pre}{action} 变量 {name} : {type}{resolve}{post}'  varinit,vardecl    \n/set format verbose display '{pre}{action} 变量 {name}{resolve}{post}'                   vardecl,varinit-notdefined    \n/set format verbose display '{pre}{action} 变量 {name}{post}'                            dropped-vardecl,varinit,expression    \n/set format verbose display '{pre}{action} 变量 {name}, 重置为空值{post}'             replaced-vardecl,varinit-ok-update    \n\n/set format verbose display '{pre}{action} {typeKind} {name}{resolve}{post}'                 class,interface,enum,annotation,record    \n/set format verbose display '{pre}{action} 方法 {name}({type}){resolve}{post}'             method    \n\n/set format verbose display '{pre}已尝试使用 {typeKind} {name}{resolve}{post}'         used-class,interface,enum,annotation,record    \n/set format verbose display '{pre}已尝试调用方法 {name}({type}){resolve}{post}'    used-method    \n\n/set truncation verbose 80\n/set truncation verbose 1000                                                                  varvalue,expression\n\n/set mode normal -command verbose    \n/set format normal display ''                                                               added,modified,replaced,overwrote,dropped-update    \n/set format normal display '{pre}{action} 变量 {name}, 重置为空值{post}'             replaced-vardecl,varinit-ok-update    \n/set format normal display '{pre}{action} 变量 {name}{resolve}{post}'                   replaced-vardecl,varinit-notdefined    \n/set format normal display '{result}'                                                       added,modified,replaced-expression,varvalue,assignment,varinit,vardecl-ok-primary    \n/set mode concise -quiet normal    \n\n/set prompt concise 'jshell> '   '   ...> '    \n\n/set format concise display ''                                                              class,interface,enum,annotation,record,method,assignment,varinit,vardecl-ok    \n\n/set feedback normal    \n\n/set mode silent -quiet    \n/set prompt silent '-> ' '>> '    \n/set truncation silent 80\n/set truncation silent 1000                                                                  varvalue,expression\n/set format silent pre '|  '    \n/set format silent post '%n'    \n/set format silent errorpre '|  '    \n/set format silent errorpost '%n'    \n/set format silent display ''    \n
