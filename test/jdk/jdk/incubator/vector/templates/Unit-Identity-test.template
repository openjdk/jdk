
    @Test(dataProvider = "$type$UnaryOpProvider")
    static void testIdentityValues(IntFunction<$type$[]> fa) {
        $type$[] a = fa.apply(SPECIES.length());

        for (int i = 0; i < a.length; i++) {
            $type$ x = a[i];

            // ADD identity: 0 + x == x
            Assert.assertEquals(($type$)(ADD_IDENTITY + x), x,
                                "ADD(ADD_IDENTITY, " + x + ") != " + x);
#if[BITWISE]

            // AND identity: -1 & x == x
            Assert.assertEquals(($type$)(AND_IDENTITY & x), x,
                                "AND(AND_IDENTITY, " + x + ") != " + x);
#end[BITWISE]

            // FIRST_NONZERO identity: firstNonZero(0, x) == x
            Assert.assertEquals(firstNonZero(FIRST_NONZERO_IDENTITY, x), x,
                                "FIRST_NONZERO(FIRST_NONZERO_IDENTITY, " + x + ") != " + x);

            // MAX identity: max($Wideboxtype$.$MinValue$, x) == x
            Assert.assertEquals(($type$) Math.max(MAX_IDENTITY, x), x,
                                "MAX(MAX_IDENTITY, " + x + ") != " + x);

            // MIN identity: min($Wideboxtype$.$MaxValue$, x) == x
            Assert.assertEquals(($type$) Math.min(MIN_IDENTITY, x), x,
                                "MIN(MIN_IDENTITY, " + x + ") != " + x);

            // MUL identity: 1 * x == x
            Assert.assertEquals(($type$)(MUL_IDENTITY * x), x,
                                "MUL(MUL_IDENTITY, " + x + ") != " + x);
#if[BITWISE]

            // OR identity: 0 | x == x
            Assert.assertEquals(($type$)(OR_IDENTITY | x), x,
                                "OR(OR_IDENTITY, " + x + ") != " + x);

            // SUADD identity: addSaturatingUnsigned(0, x) == x
            Assert.assertEquals(($type$) VectorMath.addSaturatingUnsigned(SUADD_IDENTITY, x), x,
                                "SUADD(SUADD_IDENTITY, " + x + ") != " + x);

            // UMAX identity: maxUnsigned(0, x) == x
            Assert.assertEquals(($type$) VectorMath.maxUnsigned(UMAX_IDENTITY, x), x,
                                "UMAX(UMAX_IDENTITY, " + x + ") != " + x);

            // UMIN identity: minUnsigned(-1, x) == x
            Assert.assertEquals(($type$) VectorMath.minUnsigned(UMIN_IDENTITY, x), x,
                                "UMIN(UMIN_IDENTITY, " + x + ") != " + x);

            // XOR identity: 0 ^ x == x
            Assert.assertEquals(($type$)(XOR_IDENTITY ^ x), x,
                                "XOR(XOR_IDENTITY, " + x + ") != " + x);
#end[BITWISE]
        }
    }

    @Test(dataProvider = "$type$UnaryOpProvider")
    static void testMaskedReductionIdentityAllFalse(IntFunction<$type$[]> fa) {
        $type$[] a = fa.apply(SPECIES.length());
        VectorMask<$Wideboxtype$> allFalseMask = SPECIES.maskAll(false);

        for (int i = 0; i < a.length; i += SPECIES.length()) {
            $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);

            // When mask is all false, reduction should return identity value
            Assert.assertEquals(av.reduceLanes(VectorOperators.ADD, allFalseMask), ADD_IDENTITY,
                                "ADD with all-false mask should return ADD_IDENTITY");
#if[BITWISE]
            Assert.assertEquals(av.reduceLanes(VectorOperators.AND, allFalseMask), AND_IDENTITY,
                                "AND with all-false mask should return AND_IDENTITY");
#end[BITWISE]
            Assert.assertEquals(av.reduceLanes(VectorOperators.FIRST_NONZERO, allFalseMask), FIRST_NONZERO_IDENTITY,
                                "FIRST_NONZERO with all-false mask should return FIRST_NONZERO_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.MAX, allFalseMask), MAX_IDENTITY,
                                "MAX with all-false mask should return MAX_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.MIN, allFalseMask), MIN_IDENTITY,
                                "MIN with all-false mask should return MIN_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.MUL, allFalseMask), MUL_IDENTITY,
                                "MUL with all-false mask should return MUL_IDENTITY");
#if[BITWISE]
            Assert.assertEquals(av.reduceLanes(VectorOperators.OR, allFalseMask), OR_IDENTITY,
                                "OR with all-false mask should return OR_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.SUADD, allFalseMask), SUADD_IDENTITY,
                                "SUADD with all-false mask should return SUADD_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.UMAX, allFalseMask), UMAX_IDENTITY,
                                "UMAX with all-false mask should return UMAX_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.UMIN, allFalseMask), UMIN_IDENTITY,
                                "UMIN with all-false mask should return UMIN_IDENTITY");
            Assert.assertEquals(av.reduceLanes(VectorOperators.XOR, allFalseMask), XOR_IDENTITY,
                                "XOR with all-false mask should return XOR_IDENTITY");
#end[BITWISE]
        }
    }
