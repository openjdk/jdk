/*
 * Copyright 2025 Arm Limited and/or its affiliates.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


/**
 * @test
 * @bug 8307084
 * @summary Test the optimization about vectorized drain loop with some testcases
 *          generated by fuzzer.
 *          Interpreter run is for verification with exact constant results.
 *
 * @run main/othervm compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xint compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xbatch -XX:-TieredCompilation
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xcomp -XX:-TieredCompilation
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -XX:-TieredCompilation
 *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xcomp -XX:-TieredCompilation
 *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 */

package compiler.loopopts.superword;

public class TestVectorizedDrainLoop {

    public static int N = 400;
    public static long long_check_sum = 0;
    public static long long_seed = 1L;
    public static float float_seed = -1.303F;
    public static short s_array[] = new short[N];
    public static long l_array[] = new long[N];
    public static int i_array[] = new int[N];
    public static long shift_count = -30723L;
    public static float float_factor = 27.992F;
    public static double double_adder = 0.55984;

    public static void init(int[] a, int seed) {
        for (int j = 0; j < a.length; j++) {
            a[j] = (j % 2 == 0) ? seed + j : seed - j;
        }
    }

    public static void init(long[] a, long seed) {
        for (int j = 0; j < a.length; j++) {
            a[j] = (j % 2 == 0) ? seed + j : seed - j;
        }
    }

    public static void init(float[] a, float seed) {
        for (int j = 0; j < a.length; j++) {
            a[j] = (j % 2 == 0) ? seed + j : seed - j;
        }
    }

    public static long checkSum(int[] a) {
        long sum = 0;
        for (int j = 0; j < a.length; j++) {
            sum += a[j];
        }
        return sum;
    }

    public static double checkSum(float[] a) {
        double sum = 0;
        for (int j = 0; j < a.length; j++) {
            sum += a[j];
        }
        return sum;
    }

    public static long checkSum(long[] a) {
        long sum = 0;
        for (int j = 0; j < a.length; j++) {
            sum += a[j];
        }
        return sum;
    }

    public static void test1_helper(long l) {
        int i3 = 1, i5 = 5, i7 = 65,
            i9 = 47833, iArr[] = new int[N];
        init(iArr, 1);
        for (i5 = 1; 155 > i5; ++i5) {
            iArr[i5 + 1] = i3;
        }
        while (--i7 > 0) {
            i9 -= i5;
        }
        long_check_sum = l + i3 + i5 + i9;
    }

    public static void test1() {
        int i1 = 118;
        while (++i1 < 398) {
            test1_helper(long_seed);
        }
        if (long_check_sum != 38070) {
            throw new RuntimeException("wrong result at test1: " + long_check_sum);
        }
    }

    public static void test2() {
        int i = -18, i21 = -3, i23 = 18, i25 = -12, iArr1[] = new int[N];
        for (i = 14; i < 397; i++) {
            for (i21 = 1; i21 < 66; ++i21) {
                for (i23 = 2; i23 > 1; --i23) {
                    iArr1[i23 + 1] += i21;
                }
                for (i25 = 1; i25 < 2; ++i25) {
                    switch ((i % 2) + 16) {
                        case 16:
                            s_array[i21] = (short)float_seed;
                            l_array[i21] -= i;
                    }
                }
            }
        }
        long check_sum = checkSum(iArr1);
        if (check_sum != 821535) {
            throw new RuntimeException("wrong result at test2: " + check_sum);
        }
    }

    public static void test3_helper() {
        float f1 = 7F;
        int i18 = -15;
        for (i18 = 6; i18 < 285; ++i18) {
            f1 *= 8;
            i_array[i18 - 1] += -203;
        }
        long_check_sum = Float.floatToIntBits(f1) + i18;
    }

    public static void test3() {
        for (int i = 0; i < 10000; i++ ) {
            test3_helper();
        }
        if (long_check_sum != 2139095325) {
            throw new RuntimeException("wrong result at test3: " + long_check_sum);
        }
    }

    public static void test4_helper(int i6, long l1) {
        int i7 = -33872, i8 = 65468, i9 = 7, i10 = 40154, i11 = -148, iArr[] = new int[N];
        boolean b = true;
        i7 = 187;
        while (--i7 > 0) {
            iArr[i7 + 1] = 8;
            for (i8 = 1; i8 < 9; i8++) {
                i6 += (((i8 * shift_count) + float_factor) - i7);
                if (b) break;
                for (i10 = 1; i10 < 2; ++i10) {
                    l1 >>= shift_count;
                    i11 += (((i10 * float_factor) + shift_count) - i9);
                    double_adder += i7;
                    i9 += i10;
                    i6 += (i10 | i8);
                }
            }
        }
        long_check_sum = i6 + l1 + i7 + i8 + i9 + (b ? 1 : 0) + i10 + i11;
   }

    public static void test4() {
        int i2 = -15478;
        for (int i = 0; i < 10000; i++ ) {
            test4_helper(i2, shift_count);
        }
        if (long_check_sum != -5732847) {
            throw new RuntimeException("wrong result at test4: " + long_check_sum);
        }
    }

    // test5_helper is an example where PhaseIdealLoop::resolve_input_for_drain_or_post()
    // cannot find an existing Phi node 'drain_input' among the uses of 'main_incr'.
    public static int test5_helper() {
        int i6 = 0, i7 = 1, i8 = 0, iArr[] = new int[N];
        float f=1F;
        for (i6 = 4; i6 < 166; i6++) {
          iArr[i6] *= -38756;
          i7 += (i6 + f);
        }
        for (i8 = 6; i8 < 282; ++i8) {
          long_check_sum = i7;
        }
        long meth_res = i6 + i7 + Float.floatToIntBits(f) + i8;
        return (int)meth_res;
    }

    public static void test5() {
        for (int i = 0; i < 10000; i++ ) {
            test5_helper();
        }
        if (long_check_sum != 13852) {
            throw new RuntimeException("wrong result at test5: " + long_check_sum);
        }
    }

    // Example test case where phi_list.size() > 1 in
    // PhaseIdealLoop::fix_data_uses_for_vectorized_drain().
    public static int test6_helper(long l) {

        int i4 = 7, i5 = -8, iArr[] = new int[N];
        short s3 = -11204;
        float fArr[] = new float[N];
        long lArr[] = new long[N];

        init(fArr, -1.587F);
        init(iArr, -12);
        init(lArr, -8L);
        short s2 = 6902;
        for (i4 = 19; i4 < 337; ++i4) {
            fArr[i4] *= i5;
            i5 = s2;
        }
        iArr[(26391) % N] >>= i4;
        lArr[(i4 >>> 1) % N] -= -5740;
        i5 = s3;
        i5 -= i4;
        iArr[(459) % N] = i4;
        l = -48557;
        iArr[(i5 >>> 1) % N] = i4;
        l += i4;
        long meth_res = l + i4 + i5 + Double.doubleToLongBits(checkSum(fArr)) +
                        checkSum(iArr) + checkSum(lArr);
        return (int)meth_res;
    }

    public static void test6() {
        int int_check_sum = 0;
        for (int i = 0; i < 10000; i++) {
            int_check_sum = test6_helper(long_seed);
        }
        if (int_check_sum != -316996328) {
            throw new RuntimeException("wrong result at test6: " + int_check_sum);
        }

    }

    public static void main(String[] strArr) {
        for (int i = 0; i < 10; i++)
            test1();
            test2();
            test3();
            test4();
            test5();
            test6();
        }
}
