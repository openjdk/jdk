/*
 * Copyright (c) 2025, Arm Limited. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


/**
 * @test
 * @bug 8307084
 * @summary Test the optimization about vectorized drain loop with some testcases
 *          generated by fuzzer.
 *
 * @run main/othervm -Xint compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xbatch -XX:-TieredCompilation
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xcomp -XX:-TieredCompilation
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -XX:-TieredCompilation
 *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 * @run main/othervm -Xcomp -XX:-TieredCompilation
 *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*
 *                   compiler.loopopts.superword.TestVectorizedDrainLoop
 */

package compiler.loopopts.superword;

public class TestVectorizedDrainLoop {

    public static int N = 400;
    public static long res_check_sum = 0;
    public static long long_seed = 1L;
    public static float float_seed = -1.303F;
    public static short s_array[] = new short[N];
    public static long l_array[] = new long[N];
    public static int i_array[] = new int[N];
    public static long shift_count = -30723L;
    public static float float_factor = 27.992F;
    public static double double_adder = 0.55984;

    public static long checkSum(int[] a) {
        long sum = 0;
        for (int j = 0; j < a.length; j++) {
            sum += a[j];
        }
        return sum;
    }

    public static void init(int[] a, int seed) {
        for (int j = 0; j < a.length; j++) {
            a[j] = (j % 2 == 0) ? seed + j : seed - j;
        }
    }

    public static void test1_helper(long l) {
        int i3 = 1, i5 = 5, i7 = 65,
            i9 = 47833, iArr[] = new int[N];
        init(iArr, 1);
        for (i5 = 1; 155 > i5; ++i5) {
            iArr[i5 + 1] = i3;
        }
        while (--i7 > 0) {
            i9 -= i5;
        }
        res_check_sum = l + i3  + i5 + i9;
    }

    public static void test1(String[] strArr1) {
        int i1 = 118;
        while (++i1 < 398) {
            test1_helper(long_seed);
        }
        if (res_check_sum != 38070) {
            throw new RuntimeException("wrong result at test1: " + res_check_sum);
        }
    }

    public static void test2(String[] strArr1) {
        int i = -18, i21 = -3, i23 = 18, i25 = -12, iArr1[] = new int[N];
        for (i = 14; i < 397; i++) {
            for (i21 = 1; i21 < 66; ++i21) {
                for (i23 = 2; i23 > 1; --i23) {
                    iArr1[i23 + 1] += i21;
                }
                for (i25 = 1; i25 < 2; ++i25) {
                    switch ((i % 2) + 16) {
                        case 16:
                            s_array[i21] = (short)float_seed;
                            l_array[i21] -= i;
                    }
                }
            }
        }
        long check_sum = checkSum(iArr1);
        if (check_sum != 821535) {
            throw new RuntimeException("wrong result at test2: " + check_sum);
        }
    }

    public static void test3_helper() {
        float f1 = 7F;
        int i18 = -15;
        for (i18 = 6; i18 < 285; ++i18) {
            f1 *= 8;
            i_array[i18 - 1] += -203;
        }
        res_check_sum = Float.floatToIntBits(f1) + i18;
    }

    public static void test3(String[] strArr) {
        for (int i = 0; i < 10000; i++ ) {
            test3_helper();
        }
        if (res_check_sum != 2139095325) {
            throw new RuntimeException("wrong result at test3: " + res_check_sum);
        }
    }

    public static void test4_helper(int i6, long l1) {
        int i7 = -33872, i8 = 65468, i9 = 7, i10 = 40154, i11 = -148, iArr[] = new int[N];
        boolean b = true;
        i7 = 187;
        while (--i7 > 0) {
            iArr[i7 + 1] = 8;
            for (i8 = 1; i8 < 9; i8++) {
                i6 += (((i8 * shift_count) + float_factor) - i7);
                if (b) break;
                for (i10 = 1; i10 < 2; ++i10) {
                    l1 >>= shift_count;
                    i11 += (((i10 * float_factor) + shift_count) - i9);
                    double_adder += i7;
                    i9 += i10;
                    i6 += (i10 | i8);
                }
            }
        }
        res_check_sum = i6 + l1 + i7 + i8 + i9 + (b ? 1 : 0) + i10 + i11;
   }

    public static void test4(String[] strArr) {
        int i2 = -15478;
        for (int i = 0; i < 10000; i++ ) {
            test4_helper(i2, shift_count);
        }
        if (res_check_sum != -5732847) {
            throw new RuntimeException("wrong result at test4: " + res_check_sum);
        }
    }

    public static void main(String[] strArr) {
        for (int i = 0; i < 10; i++)
            test1(strArr);
            test2(strArr);
            test3(strArr);
            test4(strArr);
        }
}
