#
# Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#
lexer.error.edit.string.missing.brace=Edit string expression missing closing brace
lexer.error.here.missing.end.marker=Here string missing end marker "{0}"
lexer.error.missing.close.quote=Missing close quote
lexer.error.missing.space.after.number=Missing space after numeric literal
lexer.error.invalid.hex=Invalid hex digit
lexer.error.strict.no.octal=cannot use octal escapes in strict mode
lexer.error.json.invalid.number=Invalid JSON number format
lexer.error.invalid.escape.char=Invalid escape character
lexer.error.illegal.identifier.character=Illegal character in identifier

parser.error.illegal.continue.stmt=Illegal continue statement
parser.error.illegal.break.stmt=Illegal break statement
parser.error.invalid.lvalue=Invalid left hand side for assignment
parser.error.undefined.label=Undefined Label "{0}"
parser.error.duplicate.label=Duplicate Label "{0}"
parser.error.duplicate.default.in.switch=Switch already has default case
parser.error.expected.literal=Expected a literal but found {0}
parser.error.expected.operand=Expected an operand but found {0}
parser.error.expected.stmt=Expected statement but found {0}
parser.error.expected.comma=Expected comma but found {0}
parser.error.expected.property.id=Expected property id but found {0}
parser.error.expected.lvalue=Expected l-value but found {0}
parser.error.expected=Expected {0} but found {1}
parser.error.invalid.return=Invalid return statement
parser.error.no.func.decl.here=Function declarations can only occur at program or function body level. You should use a function expression here instead.
parser.error.no.func.decl.here.warn=Function declarations should only occur at program or function body level. Function declaration in nested block was converted to a function expression.
parser.error.property.redefinition=Property "{0}" already defined
parser.error.unexpected.token=Unexpected token: {0}
parser.error.for.each.without.in=for each can only be used with for..in
parser.error.many.vars.in.for.in.loop=Only one variable allowed in for..in loop
parser.error.not.lvalue.for.in.loop=Invalid left side value of for..in loop
parser.error.missing.catch.or.finally=Missing catch or finally after try
parser.error.regex.unsupported.flag=Unsupported RegExp flag: {0}
parser.error.regex.repeated.flag=Repeated RegExp flag: {0}
parser.error.regex.syntax={0}

# strict mode error messages
parser.error.strict.no.with="with" statement cannot be used in strict mode
parser.error.strict.name="{0}" cannot be used as {1} in strict mode
parser.error.strict.cant.delete.ident=cannot delete identifier "{0}" in strict mode
parser.error.strict.param.redefinition=strict mode function cannot have duplicate parameter name "{0}"
parser.error.strict.no.octal=cannot use octal value in strict mode
parser.error.strict.no.func.decl.here=In strict mode, function declarations can only occur at program or function body level. You should use a function expression here instead.
type.error.strict.getter.setter.poison=In strict mode, "caller", "callee", and "arguments" properties can not be accessed on functions or the arguments object

# not the expected type in a given context
type.error.not.an.object={0} is not an Object
type.error.not.a.boolean={0} is not a Boolean
type.error.not.a.date={0} is not a Date
type.error.not.a.number={0} is not a Number
type.error.not.a.regexp={0} is not a RegExp
type.error.not.a.string={0} is not a String
type.error.not.a.function={0} is not a function
type.error.not.a.constructor={0} is not a constructor function
type.error.not.a.file={0} is not a File

# operations not permitted on undefined
type.error.cant.call.undefined=Cannot call undefined
type.error.cant.read.property.of.undefined=Cannot read property "{0}" from undefined
type.error.cant.set.property.of.undefined=Cannot set property "{0}" of undefined
type.error.cant.delete.property.of.undefined=Cannot delete property "{0}" of undefined

# other wrong usages of property
type.error.property.has.no.setter=Cannot set property "{0}" of {1} that has only a getter
type.error.cant.set.proto.to.non.object=Cannot set Object {0}'s __proto__ to be a non-object like {1}
type.error.no.such.function={1} has no such function "{0}"
type.error.cant.get.property=Cannot get property "{0}" of {1}
type.error.cant.set.property=Cannot set property "{0}" of {1}
type.error.cant.delete.property=Cannot delete property "{0}" of {1}
type.error.cant.redefine.property=Cannot redefine property "{0}" of {1}
type.error.property.not.writable="{0}" is not a writable property of {1}
type.error.object.non.extensible=Cannot add new property "{0}" to non-extensible {1}

# miscellaneous
type.error.regex.cant.supply.flags=Cannot supply flags when constructing one RegExp from another
type.error.inconsistent.property.descriptor=inconsistent property descriptor
type.error.bad.default.value=bad default value: {0}
type.error.function.apply.expects.array=Function.prototype.apply expects an Array for second argument
type.error.instanceof.on.non.object=instanceof must be called with a javascript or java object as the right-hand argument
type.error.cannot.convert.to.interface=object {0} cannot be converted to {1} due to "{2}"
type.error.array.reduce.invalid.init=invalid initialValue for Array.prototype.reduce
type.error.array.reduceright.invalid.init=invalid initialValue for Array.prototype.reduceRight
type.error.cannot.get.default.string=Cannot get default string value
type.error.cannot.get.default.number=Cannot get default number value
type.error.cant.apply.with.to.null=Cannot apply "with" to null
type.error.cant.apply.with.to.undefined=Cannot apply "with" to undefined
type.error.in.with.non.object=Right hand side of "in" cannot be non-Object, found {0}
type.error.prototype.not.an.object="prototype" of {0} is not an Object, it is {1}
type.error.cant.load.script=Cannot load script from {0}
type.error.JSON.stringify.cyclic=JSON.stringify got a cyclic data structure
type.error.cant.convert.string.to.char=Cannot convert string to character; its length must be exactly 1
type.error.cant.convert.number.to.char=Cannot convert number to character; it's out of 0-65535 range
type.error.cant.convert.to.java.string=Cannot convert object of type {0} to a Java argument of string type
type.error.cant.convert.to.java.number=Cannot convert object of type {0} to a Java argument of number type
type.error.cant.convert.to.javascript.array=Can only convert Java arrays and lists to JavaScript arrays. Can't convert object of type {0}.
type.error.extend.expects.at.least.one.argument=Java.extend needs at least one argument.
type.error.extend.expects.at.least.one.type.argument=Java.extend needs at least one type argument.
type.error.extend.expects.java.types=Java.extend needs Java types as its arguments.
type.error.extend.ambiguous.defining.class=There is no class loader that can see all of {0} at once.
type.error.extend.ERROR_FINAL_CLASS=Can not extend final class {0}.
type.error.extend.ERROR_NON_PUBLIC_CLASS=Can not extend/implement non-public class/interface {0}.
type.error.extend.ERROR_NO_ACCESSIBLE_CONSTRUCTOR=Can not extend class {0} as it has no public or protected constructors.
type.error.extend.ERROR_MULTIPLE_SUPERCLASSES=Can not extend multiple classes {0}. At most one of the specified types can be a class, the rest must all be interfaces.
type.error.extend.ERROR_NO_COMMON_LOADER=Can not find a common class loader for ScriptObject and {0}.
type.error.no.constructor.matches.args=Can not construct {0} with the passed arguments; they do not match any of its constructor signatures.
type.error.no.method.matches.args=Can not invoke method {0} with the passed arguments; they do not match any of its method signatures.
type.error.method.not.constructor=Java method {0} can't be used as a constructor.
type.error.env.not.object=$ENV must be an Object.
type.error.unsupported.java.to.type=Unsupported Java.to target type {0}.
range.error.inappropriate.array.length=inappropriate array length: {0}
range.error.inappropriate.array.buffer.length=inappropriate array buffer length: {0}
range.error.invalid.fraction.digits=fractionDigits argument to {0} must be in [0, 20]
range.error.invalid.precision=precision argument toPrecision() must be in [1, 21]
range.error.invalid.radix=radix argument must be in [2, 36]
range.error.invalid.date=Invalid Date
range.error.too.many.errors=Script contains too many errors: {0} errors

reference.error.not.defined="{0}" is not defined
reference.error.cant.be.used.as.lhs="{0}" can not be used as the left-hand side of assignment

syntax.error.invalid.json=Invalid JSON: {0}
syntax.error.strict.cant.delete=cannot delete "{0}" in strict mode

io.error.cant.write=cannot write "{0}"
config.error.no.dest=no destination directory supplied

uri.error.bad.uri=Bad URI "{0}" near offset {1}

