/*
 * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.nashorn.internal.objects;

import static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;
import static jdk.nashorn.internal.runtime.linker.Lookup.MH;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import jdk.nashorn.internal.codegen.objects.FunctionObjectCreator;
import jdk.nashorn.internal.runtime.GlobalFunctions;
import jdk.nashorn.internal.runtime.Property;
import jdk.nashorn.internal.runtime.PropertyMap;
import jdk.nashorn.internal.runtime.ScriptFunction;
import jdk.nashorn.internal.runtime.ScriptFunctionData;
import jdk.nashorn.internal.runtime.ScriptObject;
import jdk.nashorn.internal.runtime.ScriptRuntime;
import jdk.nashorn.internal.runtime.linker.Lookup;
import jdk.nashorn.internal.runtime.linker.MethodHandleFactory;

/**
 * Concrete implementation of ScriptFunction. This sets correct map for the
 * function objects -- to expose properties like "prototype", "length" etc.
 */
public class ScriptFunctionImpl extends ScriptFunction {

    private static final MethodHandle BOUND_FUNCTION    = findOwnMH("boundFunction",    Object.class, ScriptFunction.class, Object.class, Object[].class, Object.class, Object[].class);
    private static final MethodHandle BOUND_CONSTRUCTOR = findOwnMH("boundConstructor", Object.class, ScriptFunction.class, Object[].class, Object.class, Object[].class);

    private static final PropertyMap nasgenmap$;

    /**
     * Constructor called by Nasgen generated code, no membercount, use the default map.
     * Creates builtin functions only.
     *
     * @param name name of function
     * @param invokeHandle handle for invocation
     * @param specs specialized versions of this method, if available, null otherwise
     */
    ScriptFunctionImpl(final String name, final MethodHandle invokeHandle, final MethodHandle[] specs) {
        super(name, invokeHandle, nasgenmap$, null, specs, false, true);
        init();
    }

    /**
     * Constructor called by Nasgen generated code, no membercount, use the map passed as argument.
     * Creates builtin functions only.
     *
     * @param name name of function
     * @param invokeHandle handle for invocation
     * @param map initial property map
     * @param specs specialized versions of this method, if available, null otherwise
     */
    ScriptFunctionImpl(final String name, final MethodHandle invokeHandle, final PropertyMap map, final MethodHandle[] specs) {
        super(name, invokeHandle, map.addAll(nasgenmap$), null, specs, false, true);
        init();
    }

    /**
     * Constructor called by Global.newScriptFunction (runtime).
     *
     * @param name name of function
     * @param methodHandle handle for invocation
     * @param scope scope object
     * @param specs specialized versions of this method, if available, null otherwise
     * @param strict are we in strict mode
     * @param builtin is this a built-in function
     */
    ScriptFunctionImpl(final String name, final MethodHandle methodHandle, final ScriptObject scope, final MethodHandle[] specs, final boolean strict, final boolean builtin) {
        super(name, methodHandle, getMap(strict), scope, specs, strict, builtin);
        init();
    }

    /**
     * Constructor called by (compiler) generated code for {@link ScriptObject}s.
     * Code is generated by {@link FunctionObjectCreator}
     *
     * @param data static function data
     * @param methodHandle handle for invocation
     * @param scope scope object
     * @param allocator instance constructor for function
     */
    public ScriptFunctionImpl(final ScriptFunctionData data, final MethodHandle methodHandle, final ScriptObject scope, final MethodHandle allocator) {
        super(data, getMap(data.isStrict()), scope);
        // Set method handles in script data
        if (data.getInvoker() == null) {
            data.setMethodHandles(methodHandle, allocator);
        }
        init();
    }

    static {
        PropertyMap map = PropertyMap.newMap(ScriptFunctionImpl.class);
        map = Lookup.newProperty(map, "prototype", Property.NOT_ENUMERABLE | Property.NOT_CONFIGURABLE, G$PROTOTYPE, S$PROTOTYPE);
        map = Lookup.newProperty(map, "length",    Property.NOT_ENUMERABLE | Property.NOT_CONFIGURABLE | Property.NOT_WRITABLE, G$LENGTH, null);
        map = Lookup.newProperty(map, "name",      Property.NOT_ENUMERABLE | Property.NOT_CONFIGURABLE | Property.NOT_WRITABLE, G$NAME, null);
        nasgenmap$ = map;
    }

    // function object representing TypeErrorThrower
    private static ScriptFunction typeErrorThrower;

    static synchronized ScriptFunction getTypeErrorThrower() {
        if (typeErrorThrower == null) {
            //name handle
            final ScriptFunctionImpl func = new ScriptFunctionImpl("TypeErrorThrower", Lookup.TYPE_ERROR_THROWER_SETTER, null, null, false, false);
            // clear constructor handle...
            func.setConstructHandle(null);
            func.setPrototype(UNDEFINED);
            typeErrorThrower = func;
        }

        return typeErrorThrower;
    }

    // add a new property that throws TypeError on get as well as set
    static synchronized PropertyMap newThrowerProperty(final PropertyMap map, final String name, final int flags) {
        return map.newProperty(name, flags, -1, Lookup.TYPE_ERROR_THROWER_GETTER, Lookup.TYPE_ERROR_THROWER_SETTER);
    }

    // property map for strict mode functions - lazily initialized
    private static PropertyMap strictmodemap$;

    // Choose the map based on strict mode!
    private static PropertyMap getMap(final boolean strict) {
        if (strict) {
            synchronized (ScriptFunctionImpl.class) {
                if (strictmodemap$ == null) {
                    // In strict mode, the following properties should throw TypeError
                    strictmodemap$ = nasgenmap$;
                    strictmodemap$ = newThrowerProperty(strictmodemap$, "arguments", Property.NOT_ENUMERABLE | Property.NOT_CONFIGURABLE);
                    strictmodemap$ = newThrowerProperty(strictmodemap$, "caller",    Property.NOT_ENUMERABLE | Property.NOT_CONFIGURABLE);
                }
            }
            return strictmodemap$;
        }

        return nasgenmap$;
    }

    // Instance of this class is used as global anonymous function which
    // serves as Function.prototype object.
    private static class AnonymousFunction extends ScriptFunctionImpl {
        private static final PropertyMap nasgenmap$$ = PropertyMap.newMap(AnonymousFunction.class);

        AnonymousFunction() {
            super("", GlobalFunctions.ANONYMOUS, nasgenmap$$, null);
        }
    }

    static ScriptFunctionImpl newAnonymousFunction() {
        return new AnonymousFunction();
    }

    /**
     * Factory method for non-constructor built-in functions
     *
     * @param name   function name
     * @param methodHandle handle for invocation
     * @param specs  specialized versions of function if available, null otherwise
     * @param strict are we in strict mode
     * @return new ScriptFunction
     */
    public static ScriptFunction makeFunction(final String name, final MethodHandle methodHandle, final MethodHandle[] specs, final boolean strict) {
        final ScriptFunctionImpl func = new ScriptFunctionImpl(name, methodHandle, null, specs, strict, true);
        func.setConstructHandle(null);
        func.setPrototype(UNDEFINED);

        return func;
    }

    /**
     * Factory method for non-constructor built-in functions
     *
     * @param name   function name
     * @param methodHandle handle for invocation
     * @param specs  specialized versions of function if available, null otherwise
     * @return new ScriptFunction
     */
    public static ScriptFunction makeFunction(final String name, final MethodHandle methodHandle, final MethodHandle[] specs) {
        return makeFunction(name, methodHandle, specs, false);
    }

    /**
     * Factory method for non-constructor built-in functions
     *
     * @param name   function name
     * @param methodHandle handle for invocation
     * @return new ScriptFunction
     */
    public static ScriptFunction makeFunction(final String name, final MethodHandle methodHandle) {
        return makeFunction(name, methodHandle, null);
    }

    /**
     * This method is used to create a bound function. See also
     * {@link NativeFunction#bind(Object, Object...)} method implementation.
     *
     * @param thiz this reference to bind
     * @param args arguments to bind
     */
    @Override
    public ScriptFunction makeBoundFunction(final Object thiz, final Object[] args) {
        Object[] allArgs = args;

        if (allArgs == null) {
            allArgs = ScriptRuntime.EMPTY_ARRAY;
        }

        final Object boundThiz = convertThisObject(thiz);
        final MethodHandle   boundMethod = MH.insertArguments(BOUND_FUNCTION, 0, this, boundThiz, allArgs);
        final ScriptFunction boundFunc   = makeFunction("", boundMethod, null, true);

        MethodHandle consHandle  = this.getConstructHandle();

        if (consHandle != null) {
            consHandle = MH.insertArguments(BOUND_CONSTRUCTOR, 0, this, allArgs);
        }

        boundFunc.setConstructHandle(consHandle);
        int newArity = this.getArity();
        if (newArity != -1) {
            newArity -= Math.min(newArity, allArgs.length);
        }
        boundFunc.setArity(newArity);

        return boundFunc;
    }

    @SuppressWarnings("unused")
    private static Object boundFunction(final ScriptFunction wrapped, final Object boundThiz, final Object[] boundArgs, final Object thiz, final Object[] args) {
        final Object[] allArgs = new Object[boundArgs.length + args.length];

        System.arraycopy(boundArgs, 0, allArgs, 0, boundArgs.length);
        System.arraycopy(args, 0, allArgs, boundArgs.length, args.length);

        return ScriptRuntime.apply(wrapped, boundThiz, allArgs);
    }

    @SuppressWarnings("unused")
    private static Object boundConstructor(final ScriptFunction wrapped, final Object[] boundArgs, final Object thiz, final Object[] args) {
        final Object[] allArgs = new Object[boundArgs.length + args.length];
        System.arraycopy(boundArgs, 0, allArgs, 0, boundArgs.length);
        System.arraycopy(args, 0, allArgs, boundArgs.length, args.length);

        return ScriptRuntime.construct(wrapped, allArgs);
    }

    // return Object.prototype - used by "allocate"
    @Override
    protected final ScriptObject getObjectPrototype() {
        return Global.objectPrototype();
    }

    // Internals below..
    private void init() {
        this.setProto(Global.instance().getFunctionPrototype());
        this.setPrototype(new PrototypeObject(this));

        if (isStrict()) {
            final ScriptFunction func = getTypeErrorThrower();
            // We have to fill user accessor functions late as these are stored
            // in this object rather than in the PropertyMap of this object.
            setUserAccessors("arguments", func, func);
            setUserAccessors("caller", func, func);
        }
    }

    private static MethodHandle findOwnMH(final String name, final Class<?> rtype, final Class<?>... types) {
        try {
            return MethodHandles.lookup().findStatic(ScriptFunctionImpl.class, name, MH.type(rtype, types));
        } catch (final NoSuchMethodException | IllegalAccessException e) {
            throw new MethodHandleFactory.LookupException(e);
        }
    }
}
