#
# Copyright (c) 2011, 2025, Oracle and/or its affiliates. All rights reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the LICENSE file that accompanied this code.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
# or visit www.oracle.com if you need additional information or have any
# questions.
#

include MakeIncludeStart.gmk
ifeq ($(INCLUDE), true)

################################################################################

BUFFER_INPUT_DIR := $(MODULE_SRC)/share/classes/java/nio
BUFFER_OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)/gensrc/java.base/java/nio

################################################################################
# Helper method to setup generation of bin snippets.
# Will add the generated snippet file name to $1_BIN_SNIPPET_FILES.
#
# arg $1: $1 as passed into SetupGenBuffer
# arg $2: type for this bin snippet
define SetupGenBufferBinSnippets
  $1_$2_TMP := $$(BUFFER_OUTPUT_DIR)/$1.java.bin-snippet.$2

  $1_$2_LBPV :=  $$(call Conv, $2, LBPV)
  ifeq ($$($1_READ_ONLY), true)
    $1_$2_RW_KEYS := ro
    $1_$2_RW_REPLACEMENT := R
  else
    $1_$2_RW_KEYS := rw
    $1_$2_RW_REPLACEMENT :=
  endif

  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_BIN_$1_$2, \
      SOURCE_FILE := $$(BUFFER_INPUT_DIR)/$$($1_TEMPLATE)-bin.java.template, \
      OUTPUT_FILE := $$($1_$2_TMP), \
      INFO := Generating buffer class bin snippets for $1 ($2), \
      BEGIN_END := true, \
      KEYS := \
          $$($1_$2_RW_KEYS), \
      REPLACEMENTS := \
          type=$2 \
          RW=$$($1_$2_RW_REPLACEMENT) \
          LG_BYTES_PER_VALUE=$$($1_$2_LBPV) \
          BYTES_PER_VALUE="(1$$$$(SPACE)<<$$$$(SPACE)$$($1_$2_LBPV))" \
          a=$$(call Conv, $2, a) \
          fulltype=$$(call Conv, $2, fulltype) \
          memtype=$$(call Conv, $2, memtype) \
          Memtype=$$(call Conv, $2, Memtype) \
          nbytes=$$(call Conv, $2, nbytes) \
          nbytesButOne=$$(call Conv, $2, nbytesButOne) \
          Type=$$(call Conv, $2, Type) \
          fromBits=$$(call Conv, $2, fromBits, $$($1_BYTE_ORDER)) \
          toBits=$$(call Conv, $2, toBits, $$($1_BYTE_ORDER)), \
  ))
  TARGETS += $$(GEN_BUFFER_$1_$2)

  $1_BIN_SNIPPET_FILES += $$($1_$2_TMP)
endef

################################################################################
# Setup make rules that creates a generated buffer class java source file,
# according to specifications provided.
#
# Parameter 1 is the name of the rule. This name is used as variable prefix,
# and the targets generated are listed in a variable by that name. The output
# file name is also based on this.
#
# Remaining parameters are named arguments. These include:
#   TYPE          The native type
#   TEMPLATE      The base file name of the template to use
#   BYTE_ORDER    (U)nswapped/(S)wapped/(L)ittle/(B)ig
#   READ_ONLY     Set to true to generate read-only buffers (default: false)
#   GENERATE_BIN  Set to true to generate bin snippets (default: false)
#
SetupGenBuffer = $(NamedParamsMacroTemplate)
define SetupGenBufferBody
  $1_OUTPUT := $$(BUFFER_OUTPUT_DIR)/$1.java
  ifeq ($$($1_GENERATE_BIN), true)
    # After generating the buffer class, we need to do further post processing,
    # so output to a temporary file
    $1_REAL_OUTPUT := $$($1_OUTPUT)
    $1_OUTPUT := $$($1_OUTPUT).bin-snippet.tmp
  endif

  $1_LBPV := $$(call Conv, $$($1_TYPE), LBPV)
  ifeq ($$($1_READ_ONLY), true)
    $1_RW_KEYS := ro
    $1_RW_REPLACEMENT := R
  else
    $1_RW_KEYS := rw
    $1_RW_REPLACEMENT :=
  endif

  $$(eval $$(call SetupStreamPreProcessing, GEN_BUFFER_$1, \
      SOURCE_FILE := $$(BUFFER_INPUT_DIR)/$$($1_TEMPLATE).java.template, \
      OUTPUT_FILE := $$($1_OUTPUT), \
      INFO := Generating buffer class $1.java, \
      KEYS := \
          $$($1_TYPE) \
          $$($1_RW_KEYS) \
          bo$$($1_BYTE_ORDER) \
          $$(call Conv, $$($1_TYPE), category) \
          $$(call Conv, $$($1_TYPE), streams), \
      REPLACEMENTS := \
          type=$$($1_TYPE) \
          BO=$$($1_BYTE_ORDER) \
          RW=$$($1_RW_REPLACEMENT) \
          LG_BYTES_PER_VALUE=$$($1_LBPV) \
          BYTES_PER_VALUE="(1$$$$(SPACE)<<$$$$(SPACE)$$($1_$2_LBPV))" \
          a=$$(call Conv, $$($1_TYPE), a) \
          A=$$(call Conv, $$($1_TYPE), A) \
          fulltype=$$(call Conv, $$($1_TYPE), fulltype) \
          Fulltype=$$(call Conv, $$($1_TYPE), Fulltype) \
          memtype=$$(call Conv, $$($1_TYPE), memtype) \
          Memtype=$$(call Conv, $$($1_TYPE), Memtype) \
          streamtype=$$(call Conv, $$($1_TYPE), streamtype) \
          Streamtype=$$(call Conv, $$($1_TYPE), Streamtype) \
          Type=$$(call Conv, $$($1_TYPE), Type) \
          x=$$(call Conv, $$($1_TYPE), x) \
          fromBits=$$(call Conv, $$($1_TYPE), fromBits, $$($1_BYTE_ORDER)) \
          toBits=$$(call Conv, $$($1_TYPE), toBits, $$($1_BYTE_ORDER)) \
          swap=$$(call Conv, $$($1_TYPE), swap, $$($1_BYTE_ORDER)) \
          Swaptype=$$(call Conv, $$($1_TYPE), Swaptype, $$($1_BYTE_ORDER)), \
  ))
  TARGETS += $$(GEN_BUFFER_$1)
  $1 += $$(GEN_BUFFER_$1)

  ifeq ($$($1_GENERATE_BIN), true)
    # Setup generation of snippet files, one for each non-byte type. This will
    # populate $1_BIN_SNIPPET_FILES.
    $1_BIN_SNIPPET_FILES :=
    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \
      $$(eval $$(call SetupGenBufferBinSnippets,$1,$$t)) \
    )

    # Inject these snippets in the file generated by GEN_BUFFER_$1
    $$($1_REAL_OUTPUT): $$($1_OUTPUT) $$($1_BIN_SNIPPET_FILES)
	$$(call LogInfo, Concatenating buffer class bin snippets for $1)
        # Delete everything from the line containing #BIN and below
	$$(SED) -e '/#BIN/,$$$$d' < $$($1_OUTPUT) > $$($1_REAL_OUTPUT).tmp
	$$(CAT) $$($1_BIN_SNIPPET_FILES) >> $$($1_REAL_OUTPUT).tmp
	$$(ECHO) "}" >> $$($1_REAL_OUTPUT).tmp
	$$(MV) $$($1_REAL_OUTPUT).tmp $$($1_REAL_OUTPUT)

    TARGETS += $$($1_REAL_OUTPUT)
    $1 += $$($1_REAL_OUTPUT)
  endif
endef

################################################################################
# Helper method to setup generation of all buffer classes, for a given
# modifiability state (read-only or not)
#
# arg $1: READ_ONLY argument, true or false
# arg $2: Modifiability marker for class name (R or empty)
define SetupGenerateBuffersWithRO
  ifeq ($1, false)
    # The basic buffer classes are not generated in READ_ONLY versions
    $$(eval $$(call SetupGenBuffer, ByteBuffer, \
        TYPE := byte, \
        TEMPLATE := X-Buffer, \
        GENERATE_BIN := true, \
    ))
    TARGETS += $$(ByteBuffer)

    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \
      $$(eval $$(call SetupGenBuffer, $$(call titlecase, $$t)Buffer, \
          TYPE := $$t, \
          TEMPLATE := X-Buffer, \
      )) \
      $$(eval TARGETS += $$($$(call titlecase, $$t)Buffer)) \
    )
  endif

  # Buffers whose contents are heap-allocated, one for every type
  $$(foreach t, $$(NUMBER_TYPES), \
    $$(eval $$(call SetupGenBuffer, Heap$$(call titlecase, $$t)Buffer$2, \
        TYPE := $$t, \
        TEMPLATE := Heap-X-Buffer, \
        READ_ONLY := $1, \
    )) \
    $$(eval TARGETS += $$(Heap$$(call titlecase, $$t)Buffer$2)) \
  )

  # Treat byte special for DirectByteBuffer classes
  $$(eval $$(call SetupGenBuffer, DirectByteBuffer$2, \
      TEMPLATE := Direct-X-Buffer, \
      TYPE := byte, \
      GENERATE_BIN := true, \
      READ_ONLY := $1, \
  ))
  TARGETS += $$(DirectByteBuffer$2)

  # Generate Swapped and Unswapped views of the direct byte buffers, each for
  # every non-byte type
  $$(foreach b, U S, \
    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \
      $$(eval $$(call SetupGenBuffer, Direct$$(call titlecase, $$t)Buffer$2$$b, \
          TYPE := $$t, \
          TEMPLATE := Direct-X-Buffer, \
          BYTE_ORDER := $$b, \
          READ_ONLY := $1, \
      )) \
      $$(eval TARGETS += $$(Direct$$(call titlecase, $$t)Buffer$2$$b)) \
    ) \
  )

  # Generate Big and Little endian views of the direct byte buffers, each for
  # every non-byte type
  $$(foreach b, B L, \
    $$(foreach t, $$(NON_BYTE_NUMBER_TYPES), \
      $$(eval $$(call SetupGenBuffer, ByteBufferAs$$(call titlecase, $$t)Buffer$2$$b, \
          TYPE := $$t, \
          TEMPLATE := ByteBufferAs-X-Buffer, \
          BYTE_ORDER := $$b, \
          READ_ONLY := $1, \
      )) \
      $$(eval TARGETS += $$(ByteBufferAs$$(call titlecase, $$t)Buffer$2$$b)) \
    ) \
  )
endef

################################################################################
# Generate buffers in both read-write and read-only variants for all buffers

$(eval $(call SetupGenerateBuffersWithRO,false,))
$(eval $(call SetupGenerateBuffersWithRO,true,R))

################################################################################

endif # include guard
include MakeIncludeEnd.gmk
